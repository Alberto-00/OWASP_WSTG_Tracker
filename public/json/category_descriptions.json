{
    "Information Gathering": "Questa fase prevede l’identificazione passiva e attiva di informazioni utili sul target. Si analizzano nomi di dominio, tecnologie, configurazioni esposte e metadati per ottenere un vantaggio iniziale. Fondamentale per pianificare attacchi efficaci e personalizzati.",
    "Configuration and Deployment Management Testing": "Esamina errori nella configurazione e deployment delle applicazioni, come file dimenticati, porte aperte o debug attivo. Questi problemi possono esporre l’intero ambiente a rischi critici facilmente evitabili. Una cattiva configurazione equivale spesso a una porta spalancata per l’attaccante.",
    "Identity Management Testing": "Valuta il modo in cui l’applicazione gestisce gli utenti e la separazione dei ruoli. Include test su provisioning, deprovisioning, gestione identità federate e sicurezza dei meccanismi di SSO. Una cattiva gestione può compromettere l'integrità dell'intero sistema di accesso.",
    "Authentication Testing": "Analizza i meccanismi di login alla ricerca di vulnerabilità come brute force, bypass e token prevedibili. Testa la robustezza delle credenziali e l’eventuale esposizione di endpoint critici. Il controllo sull’autenticazione è spesso il primo passo per compromettere un account.",
    "Authorization Testing": "Verifica che gli utenti possano accedere solo alle risorse per cui hanno i permessi. Esegue test verticali e orizzontali su endpoint, dati e funzionalità sensibili. Le escalation di privilegi sono tra le vulnerabilità più impattanti nei sistemi reali.",
    "Session Management Testing": "Esamina la gestione delle sessioni, inclusi token, cookie, timeout e meccanismi anti-fixation. Un token debole o gestito male consente hijacking e accessi persistenti non autorizzati. Un’app sicura deve garantire isolamento, scadenza e protezione della sessione utente.",
    "Input Validation Testing": "Valuta la sanificazione degli input utente per prevenire attacchi come XSS, SQLi, e command injection. Una validazione lato client non è sufficiente: si verifica il comportamento lato server. Le vulnerabilità qui presenti possono portare a compromissioni totali del sistema.",
    "Testing for Error Handling": "Analizza la gestione degli errori per identificare leak di stack trace, messaggi interni o comportamenti anomali. Errori non gestiti possono rivelare informazioni sensibili o causare crash controllabili. Una buona gestione degli errori è invisibile all’utente e informativa per i log.",
    "Testing for Weak Cryptography": "Verifica l'uso corretto della crittografia nei dati in transito e a riposo. Include test su algoritmi obsoleti, chiavi deboli e implementazioni custom non sicure. La sicurezza crittografica è spesso trascurata ma fondamentale per la protezione dei dati sensibili.",
    "Business Logic Testing": "Testa i flussi logici dell’applicazione per scoprire comportamenti abusabili o aggirabili. Esempi includono ordini a prezzo zero, override di limiti, o bypass di step critici. Richiede approccio creativo e conoscenza del dominio applicativo.",
    "Client-side Testing": "Esamina la sicurezza del codice eseguito nel browser: JavaScript, storage locale, DOM e meccanismi CORS. Verifica se un utente malintenzionato può manipolare il client per attaccare altri utenti o il backend. Essenziale in applicazioni moderne con logica spostata sul frontend.",
    "API Testing": "Questa categoria si concentra sull'analisi della superficie d'attacco esposta dalle API. Si valutano autenticazione, autorizzazione, rate limiting, esposizione eccessiva di dati e coerenza dei metodi HTTP. Le API sono spesso target ad alta priorità per gli attaccanti, specialmente in architetture moderne basate su microservizi."
}