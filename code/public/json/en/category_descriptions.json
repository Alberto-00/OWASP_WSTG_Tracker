{
  "Information Gathering": "This phase involves passive and active identification of useful information about the target. Domain names, technologies, exposed configurations, and metadata are analyzed to gain an initial advantage. It is essential for planning effective, tailored attacks.",
  "Configuration and Deployment Management Testing": "Examines errors in application configuration and deployment, such as forgotten files, open ports, or enabled debugging. These issues can expose the entire environment to critical, easily avoidable risks. Poor configuration often amounts to leaving the door wide open to an attacker.",
  "Identity Management Testing": "Assesses how the application handles users and the separation of roles. It includes tests on provisioning, deprovisioning, federated identity management, and the security of SSO mechanisms. Poor management can compromise the integrity of the entire access system.",
  "Authentication Testing": "Analyzes login mechanisms for vulnerabilities such as brute force, bypasses, and predictable tokens. It tests the strength of credentials and any exposure of critical endpoints. Control over authentication is often the first step to compromising an account.",
  "Authorization Testing": "Verifies that users can access only the resources they are permitted to. It performs vertical and horizontal tests on endpoints, data, and sensitive functionality. Privilege escalations are among the most impactful vulnerabilities in real systems.",
  "Session Management Testing": "Examines session handling, including tokens, cookies, timeouts, and anti-fixation mechanisms. A weak or poorly managed token enables hijacking and persistent unauthorized access. A secure application must ensure isolation, expiry, and protection of the user session.",
  "Input Validation Testing": "Evaluates the sanitization of user inputs to prevent attacks such as XSS, SQLi, and command injection. Client-side validation is not sufficient: server-side behavior must be verified. Vulnerabilities here can lead to complete system compromise.",
  "Testing for Error Handling": "Analyzes error handling to identify leaks of stack traces, internal messages, or anomalous behavior. Unhandled errors can reveal sensitive information or cause controllable crashes. Good error handling is invisible to the user and informative for logs.",
  "Testing for Weak Cryptography": "Verifies the correct use of cryptography for data in transit and at rest. It includes tests for obsolete algorithms, weak keys, and insecure custom implementations. Cryptographic security is often overlooked but essential for protecting sensitive data.",
  "Business Logic Testing": "Tests the application's logical flows to uncover behaviors that can be abused or circumvented. Examples include zero-priced orders, overriding limits, or bypassing critical steps. It requires a creative approach and knowledge of the application domain.",
  "Client-side Testing": "Examines the security of code executed in the browser: JavaScript, local storage, the DOM, and CORS mechanisms. It checks whether a malicious user can manipulate the client to attack other users or the backend. This is essential in modern applications with logic moved to the frontend.",
  "API Testing": "This category focuses on analyzing the attack surface exposed by APIs. Authentication, authorization, rate limiting, excessive data exposure, and consistency of HTTP methods are evaluated. APIs are often high-priority targets for attackers, especially in modern microservice-based architectures."
}
